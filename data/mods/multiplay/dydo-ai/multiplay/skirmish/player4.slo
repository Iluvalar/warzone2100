/*
DyDo-AI Rel 2.2.4
Mod Developer: "DylanDog" on http://forums.wz2100.net/
AI webpage: http://www.obooma.net/dydo/       
                                                                
DyDo-AI is for challenges, skirmish & multiplayer games.

#################################################################
For changelog and downloads see DyDo-AI homepage http://www.obooma.net/dydo/ 
    or Warzone SVN
#################################################################

________________ CHANGELOG ___________________________________


{change} - DyDo to use new sunburst AA defence

*/
#define DYDOBP_RELEASE "DyDo-AI ver 2.2.4"

#define	GAME_TIME_IN_SECS	(gameTime / 10)
#define	GAME_TIME_IN_MIN	(gameTime / 10 / 60)
#define TIME_MINUTE 600
#define MAX_WHILE_LOOPS 99
#define PLAYER_NUMBER 0
#define TEAM_NUMBER 1

//gametype
#define MAP_SMALL  0
#define MAP_MEDIUM 1
#define MAP_BIG    2

#define T1_GAME 0
#define T2_GAME 1
#define T3_GAME 2

#define GT_2PLAYERS_1HP 0
#define GT_4PLAYERS_1HP_2T 1
#define GT_4PLAYERS_1HP_34T 2
#define GT_8PLAYERS_1HP_23T 3
#define GT_8PLAYERS_1HP_4567T 4
#define GT_4PLAYERS_2HP_2T 5
#define GT_4PLAYERS_2HP_34T 6 
#define GT_8PLAYERS_2HP_23T 7
#define GT_8PLAYERS_2HP_4567T 8
#define GT_8PLAYERS_3HP_23T 9
#define GT_STANDARD 10

//stats
#define OC_WEAPON_COST 0
#define OC_RESLABS 1
#define OC_PHYTON 2
#define OC_MANTIS 3
#define OC_TIGER 4
#define OC_CYBORGS 5
#define OC_TANKS 6
#define OC_VTOLS 7
#define OC_DERRICKS 8
#define OC_DEF_STRUCT 9
#define OC_CYB_POWER 10
#define OC_TK_POWER 11
#define OC_VTOL_POWER 12
#define OC_CYB_HP 13
#define OC_TK_HP 14
#define OC_VTOL_HP 15

#define WUI_TOTUNITS 0
#define WUI_POWER 1
#define WUI_HP 2

#define DROIDTYPE_CYBORG 0
#define DROIDTYPE_TANK 1
#define DROIDTYPE_HOVER 2
#define DROIDTYPE_COMM 3

//used with aPl[][]
#define X_COORD 0
#define Y_COORD 1
#define IS_ENEMY 2
#define PL_POSITION 3

//used with AIPersonality
#define AI_STANDARD 1
#define AI_VTOL 2
#define AI_TURTLE 3
#define AI_CYBORG 4

//select tank template
#define BODY_HEAVY 0
#define BODY_MEDIUM 1
#define BODY_LIGHT 2
#define WEAPON_AR  0
#define WEAPON_AT  1
#define WEAPON_AP  2

//used with minDefDroids[][x]
#define MINDEF_TANKS 0
#define MINDEF_CYBORGS 1
#define MINDEF_VTOLS 2

#define EVENT_CHECK_NUMBER 32

#define NUM_AI_PERSONALITIES 4
#define	MAX_PLAYERS	8
#define	TILE				128
#define	MAX_DROIDS	150

#define MAX_HELP_DISTANCE 70*TILE
#define STR_TANK_FACTORY 0
#define STR_RESLAB 1
#define STR_CYB_FACTORY 2
#define STR_VTOL_FACTORY 3

#define MAX_DEFSTR_DERRICKS  3 
#define MAX_DEFSTR_SPOT  4 
#define MAX_REPAIRFAC 5

#define VERY_LOW_POWER_MAP 0
#define LOW_POWER_MAP 1
#define NORMAL_POWER_MAP 2
#define HIGH_POWER_MAP 3

//harvTrucks+buildTrucks+defTrucks
#define MIN_BUILDING_TANKS 6
#define MIN_CYB_CONSTENG 4

#define TIME_MOVE_TOGATEWAYS 70
#define THREAT_RANGE_TILES 8
//used for repairing and building derricks
#define THREAT_RANGE_TILES_SHORT 7
#define THREAT_RANGE_TILES_LONG 10

#define BUILDDEF_GRP  0
#define CYBENG_GRP    1
#define BUILD_GRP     2
#define HARVEST_GRP   3

#define STRUCT_REPAIR_DAMAGE 25

#define RED_ALERT     3
#define YELLOW_ALERT  2
#define GREEN_ALERT   1
#define ALERT_INACTIVE 0

//standard
#define RESTMPL_0 0 
//(Flamers/Lasers - POD/Lancer/TK/Scourge)
#define RESTMPL_1 1 
//Gunners, Cannons
#define RESTMPL_2 2 

//used to compare combat strenghts
#define	COMBAT_RANGE			(TILE * 12)

//repairing untis
#define MAX_REPAIR_UNITS 2
#define MIN_HEALT_REPAIR_BASE 80
#define MIN_HEALT_SWITCH_TO_TANK 95
#define MIN_HEALT_SWITCH_TO_CYBORG 95
#define DAMAGE_REPAIR_LEVEL 65
#define DAMAGE_REPAIR_LEVEL_LOW 25
#define VTOL_DAMAGE_REPAIR_LEVEL 75
#define STRUCT_REPAIR_DAMAGE 25

//tanks
#define MIN_ATTACKING_TANKS 10
#define MAX_ATTACK_TANKS_ADD 20
#define MIN_DEFUNIT_DEFEND 2
#define MIN_SURVIVOR_TANKS 5

#define MIN_HELPING_UNITS 10
//this is for both cybDefGRP and tkDefGRP, therefore the max helping is 10!
#define MAX_HELPING_UNITS 15 
//attack enemy and defend with defGrp only if we have at least these number of units
#define MIN_DEFUNIT_ATTACK 5

//cyborgs
#define MIN_DEFCYB_DEFEND 2
#define MIN_ATT_CYBORGS 10
#define MAX_ATTACK_CYBORG_ADD 20
#define MIN_SURVIVOR_CYBORGS 5

//VTOLs   - code cleaning stopped here
#define MAX_VTOLS   15
#define MAX_VTOLS_PERS2   25
//attack only if this number of VTOLs has been reached
#define MIN_VTOLS_ATTACK 3
#define MIN_VTOLS_ATTACK_BASE 7
//Personality 2 aims for a quick buoild of these VTOLs
#define MIN_VTOLS 3
#define MIN_VTOLS_PERS2 6
#define	AA_THREAT_RANGE	(TILE * 18)
#define	AA_THREAT_RANGE_LONG	(TILE * 20)

//defend
#define MAX_DEFEND_RANGETILES 60
#define MIN_BASE_DEF_STRUCTS 12 
#define MAX_BASE_DEF_STRUCTS 20 

//AA
#define RANGE_BUILD_AADEF 7*TILE
#define MAX_AADEF_INRANGE 3
#define MIN_AA_INBASERANGE 7
//add to nRangeBase

#define MIN_TOT_UNITS 8
//build derrick defences only after this time
#define VALID_TIME_DERRICK_DEF 3600
//change the units to add to build up the attacking group every this interval time
#define TIME_CHANGE_TANKSTOADD 3000

//build more then 2 repair centres aonly after this time
#define VALID_TIME_REPAIRFAC 4200
//build 4-5 Research and Cyborg Factory after this time
#define VALID_TIME_EXTRABUILD 4800
//build oilDef only after this time
#define VALID_TIME_CYBATTACK 6000
//after 4 min all oil should be got
#define TIME_HARVESTING_PHASE 5000
//after this time alert is set to DEACTIVATED anyway 
#define TIME_TO_RESET_ALERT 100
//build gateway def only after this time
#define VALID_TIME_GATEWAYDEF 3600
//start researching VTOL stuff only after this time
#define TIME_START_VTOLRESEARCH 3000
//force the building of a defence every x min
#define TIME_TOFORCE_BUILDDEF 2000
//turtle AI
#define TIME_TOFORCE_BUILDDEF_2 1400

//power
#define VERY_LOW_POWER 0
#define LOW_POWER 1
#define HIGH_POWER 2
#define TIME_SWITCH_WORKSTRUCT 900

#define BEST_VTOL_TEMPLATES 3

public int player;   // player for this instance.
//public BOOL LIFE;        // feature switch
public int numMaxDerricks;   // rate of exploration

// structures
public int baseX,baseY,minx,miny,maxx,maxy,defSpotX,defSpotY;
public int nScavStruct,numStructs,numAA,numIncendrys, numFortressDef,numWallWeaps,numSuperCyb, numSense, numGenAA;

public STRUCTURESTAT wall,aScavBaseStr[4],incendrys[8],structs[51],defStructs[20],structChoice[30],fortressDef[4],wallWeaps[20],vtolDefStruct[10],sense[3],vtolGenStruct[10];
public STRUCTURESTAT sensorTower,sensorHardTower,resLab,powGen,playerHQ,demAnomallyFix,lassat,scavFactory,factory,derrick,cybFactory,vtolPad,vtolFactory,repairFacility, uplinkCenter,CBSense;
public STRUCTURESTAT HMGhardPoint,MGbunker,miniRocketTower,LancerTower, powModule,facModule,resModule;
public STRUCTURESTAT defMortar,defBombard, defPepperpot,defRippleRockets;
public RESEARCHSTAT SunburstAAsite,WhirlwindAASite,HurricaneAASite;
public RESEARCHSTAT MortarFastLoad3;
public RESEARCHSTAT defRippleRes,VTOLPadRes,lancerATweap,cyborgFactory,MGTower;
public int nStat,aStat[20][8],structsLimits[4][4],strToBuild[4][4],numDefStructs,minDefDroids[4][3];

//keep even if not used
public RESEARCHSTAT nexusDefence, powerAddOn;

public STRUCTURESTAT pickStrQueue[15];           
public int pickStrQueueDepth;
public STRUCTURESTAT pickDefQueue[50];          
public int pickDefQueueDepth;
public STRUCTURESTAT pickWallDefQueue[60];      
public int pickWallDefQueueDepth;
public STRUCTURESTAT pickFortQueue[4];           
public int pickFortQueueDepth;

private STRUCTURESTAT pickStructureQueue[80];
private int pickStructureQueueDepth;

public bool showAIPersonality;
public int AIPersonality,AIstrength;
private int nAI_Pers;

// unit templates
public int numPath1[10], numPath2[10], numRes[10],numResGen2[10],numResGen3[10],numResGen4[10],numCheapRes[1],numCheapResGen2[1],numCheapResGen3[1],numCheapResGen4[1];
public RESEARCHSTAT resPath2[10][62],resPath1[10][62],research[10][62],general2[10][62],general3[10][62],general4[10][62],researchCheap[1][23],general2Cheap[1][21],general3Cheap[1][21],general4Cheap[1][21];
private int nResearchCounter,nResTmplPath;
public int numTmpls, numTmpl_01, numTmpl_02, numTmpl_AR;
public TEMPLATE tmpl0[64],tmpl_p1[52],tmpl_p2[64],tmpl_AR[24];
public TEMPLATE tmpl1[5];
public TEMPLATE superCyb[20];
public TEMPLATE constructor,constructor2,VTOLconstr,cybMech,cybcondroid,repairTank,CobraHoverBB;

// special - template recognizer
public PROPULSION cyborgPropulsion;

//build
private INT buildX,buildY;
public FEATURESTAT oilRes;


// GROUPS
public GROUP vtolHunterGr, vtolGr ,vtolAttGr, tankGroup, buildGrp, harvesterGroup, toBeRepairedTankGroup, repairGroup, toBeRepairedCyborgGroup, cyborgDefGroup,  cyborgAttGroup;
private GROUP xGroup;

// generic
private STRUCTURE structure,structure2,structure3;
private DROID droid,droid2,dNearestEnemyCmd;
private FEATURE feature,feature2;
private BASEOBJ baseobj;
private INT count,count1,count2,count3,count4;
private BOOL boolResult,boolResult2,boolResult3;

private INT aPlayers[8][8];

public BASEOBJ lassatTarget,myBaseObject,enemyBaseObject;

//// DEBUG-MODE
public BOOL EnableSliders;// DylanDog

//// T1 cyborgs problem
public RESEARCHSTAT CyborgLegs; //remove?

public WEAPON Commander1,Commander2,Commander3,Commander4;
public WEAPON MortarWeap,MortarIncWeap,BombardWeap,PepperpotWeap;
public WEAPON HowitzerWeap,HowitzerIncWeap,GroundSheakWeap,HellstormWeap;
public WEAPON MGun, TwinMGun , HMGun, TwinAGun, AGun, Flamer ,PlasmFlamer ,Inferno;
public WEAPON FlashLight,PulseLaser,HeavyLaser;
public WEAPON NeedleGun , RailGun, GaussCannon ,PlasmaCannon ,EMPCannon ,LCannon;
public WEAPON MCannon ,ACannon ,HCannon ,TACannon ,HVCannon ,RocketBB, RocketPod;
public WEAPON RocketMRL , Lancer, RcketBB ,TankKiller ,RippleRockets ,ScourgeMissle;
public WEAPON SeraphMissile ,ArchangelMissile;
public WEAPON cybCannon,cybChainGun,cybFlamer,cybThermite,cybRotMg,cybAtmiss,cybHvyAcannon,cybHvyMcannon,cybHvyRailGun;
public WEAPON cybGren, cybLancer, cybScourge, cybNeedle, cybFlashLight, cybSuperHPV, cybSuperScourge, cybTankKiller, cybSuperPulsLas;
public WEAPON NEXUS_WEAPON1,NEXUS_WEAPON2;
public RESEARCHSTAT mediumCannon,heavyCannon,HalftrackProp,trackPropulsion,hoverPropulsion;
public RESEARCHSTAT powUpgrades0,powUpgrades1,powUpgrades2,powUpgrades3,powUpgrades4,powUpgrades5,powUpgrades6;
public RESEARCHSTAT cobraBody, phytonBody, scorpionBody, mantisBody, leopardBody, pantherBody, tigerBody, retaliationBody, retributionBody,  vengeanceBody,  wyvernBody, dragonBody;
public RESEARCHSTAT BBRocket,resCBSense,mortarPit, bombardPit, pepperpotPit, rippleRockets;
public RESEARCHSTAT Res_Lassat,Res_SuperCannon,Res_SuperMissile,Res_SuperRocket,Res_MassDriver;

public STRUCTURESTAT baseStructs[10];


// ========================= PRIVATE =====================================
private GROUP buildDefGrp,cybConstGrp,tankDefGroup,helpGroup;
private BASEOBJ attackCybObj,attackTankObj;
private BASEOBJ objTargetHelpTeam,objTargetCybDefGRP,objTargetTankDefGRP; 
private FEATURE _oilRes;
private DROID _droid, _droid1, _droid2,_idleTruck,_notIdleTruck,mydroid;
private STRUCTURE _derrick,_struct;
private BASEOBJ oTargetVTOLAtt[3],oTargetVTOLDef[3];

private bool bPlayWithBB,bPowerNormalized,bAttackHumanDerrick,bAttackingHumanDerrick,debugCenterView, bAttackedByMortars;
private bool bEarlyAttack,bAttackedByLongRangeWeap,sentToGateway,isBackinBase;
private bool bFactUpgraded1Module,bFactUpgraded2Modules,alertIsOn;
private bool bDyDoHasHeavyBody,bCybAttIsOn,lCybSentToGatheringPoint,bCybAlreadyGathered;
private bool bScoutOrder,bOilResLeft,lStopVTOLProduction,lStopVTOLFactBuilding,lStopResLabUpgrade;
private bool lMinBaseStructBuilt,lStopBuildingStructures,lStopBuildRepFacility,lStopCybEngProd;
private bool lStopBuildTankProd,lStopTankProduction, lStopCybProduction, lStopResearch;
private bool lStopCheapResearch, lStopPowGenUpgrade,lStopFactUpgrade, lStopBuildDefDerricks,lStopBuildDefGateway;
private bool lForceUnitsProduciton,lPathSet,lStopBuildDef,lStopFactUpgrade2,bVTOLTargetIsDerrick,_bVTOLTarget;
private bool bPositionUpdated,bEnemyIsNear,bLastMembPersIsSet,bLastMember,bHumPlUsesCommanders;
private bool bIsEnemyHumanOnly,bForceResPowUp,bFinalAttack_1vs1,bAttackTeamAttacked,bAAgroupsAttacked;
private bool _mustBeHuman,lTankSentToGatheringPoint, bTankAttIsOn, bTankAlreadyGathered;
private bool _bNoTrucks,bNeedDerrick,bScavAreActive,bDroidSelected,bAttackedByVTOL;


private int aPl[8][4];
private int oilResTargetId[11], oilResTargetX[11], oilResTargetY[11];
private int aGatewayPosX[4],aGatewayPosY[4],nTotGateways,lastTimeRepairBuilt;
private int nStdDef,nWallDef,nNearestEnemy,nEarlyMortars,nDroidsEarlyAtt,nEarlyAttack,numDefStrAtGateway,numGatewaysFound,defTruckSentTime,lastBuildDefX;
private int lastBuildDefY,nRealGatewaysFound,nMidX,nMidY,nTotOilInAtStart;
private int nDefPhase,nLastTimeBuiltRepFac,lastTruckBuilt,lastCybEngBuilt,lastDisplayAI;
private int lastDisplayAIcheck,nDefendRange,gatewaysRangeTiles,numBaseStructs;
private int nTeamMates,nBaseRange,aaRange,gatherDefCybX,gatherDefCybY,gatherDefTankX,gatherDefTankY;
private int lastResIndex, nAttackingUnitsToAdd, nCybAttUnitsToAdd;
private int nDefendBasePos,nArtilleryPos,nRippleRocketsPos,nTime,nAttackTime,nFrWeapStructs,nFrWeapDroids,nFrWeapDrStr;
private int nTanksDefGrp,nMapPower,nEnWeapStructs,nEnWeapDroids,nEnWeapDrStr;
private int tVTOLAttackReset,tGatheringHelp,tGatheringCyb,tGatheringTank,tTargetTime,tFinishOilHack,alertX,alertY,alertTime,alertLevel,nX,nY;
private int tLongRangeTime,tLastRRBuilt,tLastArtilleryBuilt,tLastPowerGen,tChangeTimeTankToAdd,nHelpX,nHelpY,tLastHelp,tTotalAttack,tLastTankAttack,tLastCyborgAttack;
private int tGtwDefBuilt,tTimeForceAttack,tTanksReSentToGathering,tTanksSentToGathering,nTankGatheringX,nTankGatheringY,tankAttackX;
private int tStartBaseAttacks,tankAttackY,targetPlayerTank,targetPlayerVTOL;
private int tCybReSentToGathering,tCybSentToGathering,tCybAttackAction,tHelpAction,tTankAttackAction;
private int nWeapCybSelection,nWeapSelection,nCybGatheringX,nCybGatheringY,cybAlertX,cybAlertY,cybAttackX,cybAttackY,targetPlayerCyb;
private int tHarvestNearOilRes,tEveryMin, tEvery3Min;
private int playerLeft,nVTOLFactories,nWorkingVTOLFac,nTotTanks,nTotCyborgs,nMyDerricks,nPower,nFact1Mod,nFact2Mod,nFactories,nResLabs,nCybFact,nWorkingFact,nWorkingCybFac;
private int nKineticX,nKineticY,nWorkingLab,nTotDefences,nFreeOilRes,nTotBaseDefences;
private int _lastResIndex,_targetPlayer,nLastDefSpotUpdate,_nOilRes, _t, _pos;
private int nT_Game, nTotCybAR, nTotCybAP, nTotCybAT, nTotCybKK, nTotCybErr; 

private int nRepairFac,nTotEnemyDroids,nTotFriendlyDroids,nCybMechanic,nStructToBeBuilt,nAllyBeingHelped,nPODMRLTank, nWeakTank,nTotCyborgBuilt,nTotTankBuilt;
private int tCBSense,tLastCybMech,tLastFinalAttack,nFinalAttacks,nDamageLevelRepair, nProdSelect, tLastPowerSwitch,tLastbuildBaseDef,nEnemyPlayers,nLastEnemyPlayer,nTeam,nHumanPlayers,nPlayersInGame,nDerricksAtStart;
private int tLastBBbuilt,tVtolAction,tDefTankAction,tDefCybAction,tLastResearch;

private int nBigHelp_ok,nBigHelpRequests,tBigHelpRequest;

private int num_aDroid,aDroid_Id[50],aDroid_X[50],aDroid_Y[50],aDroid_counter[50];
private int nAttHumanPlayer,nAttAIPlayer,nAPCyborgBuilt,nAPTankBuilt; 

private int _numModules,_nWeapon, _nBody;

public	TEMPLATE		vtols[18];
public	int				  numAAinBase,tLastAAbuilt,tLastVTOLFactBuild,numVtolTemplates;
private BASEOBJ     defTargetVTOL,attTargetVTOL;

private int aPower[3],nAAPos,nAIcheck,tAIbrain,eventCheckReport[EVENT_CHECK_NUMBER],eventCheckTime[EVENT_CHECK_NUMBER],eventCheckTrigger[EVENT_CHECK_NUMBER],eventCheckCounter[EVENT_CHECK_NUMBER];

public PROPULSION Half_Track,TrackedProp,HoverProp;
public BODY Viper;

//communication
private int			_sender,sender, x, y, tBeaconTimeout, beaconX[8], beaconY[8], tBeacon[8];
private int     _fromPlayer, _choice;
private string	message,_message,_cstr;
private bool    _bBlipMessage,_bToHuman,_bCompletedStructOlny;

private int tBeaconSent,_fromX,_fromY,_targetX,_targetY;

private bool _DEBUG,_DEBUG1,_dbg, bRunning;

//===================================================================
// USED FOR PRODUCTION ONLY

private int nProd1, nProd2, nProd3, nProd4, nProd5;
private float fProd1, fProd2, fProd3, fProd4, fProd5;
private int tProd1, tProd2, tProd3, tProd4, tProd5;
private bool bProd1, bProd2, bProd3, bProd4, bProd5;
private string sProd1, sProd2, sProd3, sProd4, sProd5;


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ TRIGGERS *+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//trigger finishStructsTr    (every,300);
#region triggers

trigger droidBuiltTr        (CALL_NEWDROID,player, ref droid,ref structure);
trigger AIattackedTr        (CALL_ATTACKED, player, ref myBaseObject, ref enemyBaseObject);
trigger vtolDefendTr				(CALL_STRUCT_ATTACKED, player, ref structure, ref enemyBaseObject);
trigger multiMsgTr					(CALL_AI_MSG, player, ref sender, ref message);
trigger	beaconTr					  (CALL_BEACON, player, ref sender, ref x, ref y, ref message);
trigger consoleTr					  (CALL_CONSOLE, ref sender, ref message);
trigger reassignPlayersTr		(CALL_PLAYERLEFT,ref playerLeft);
trigger newObjectReportTr		(CALL_OBJ_SEEN, player, ref enemyBaseObject, ref myBaseObject);

trigger difficultyModifierTr  (wait,3);

trigger wait100Tr             (wait,100);
trigger shutDownAITr          (every,4);

trigger AIbrainTr             (every,10);
trigger AIcheckTr             (every,10);
trigger buildRepFirstTr       (every,10);
trigger harvesterOperateTr    (every,10);
trigger upgradeStructuresTr   (every,10);

trigger TankAttackTr          (every,10);
trigger CyborgAttackTr        (every,10);
trigger manageDefCyborgsTr    (every,10);
trigger manageDefTankTr       (every,10);
trigger manageHelpTeamTr      (every,10);

trigger manageIdleTrucksTr    (every,15);
trigger manageDefTrucksTr     (every,15);

trigger unitRepairSwitchTr    (every,20);

trigger reSortUnitsTr         (every,30);
trigger	SelectCyborgTemplateTr(every,30);
trigger	SelectTankTemplateTr  (every,30);
trigger sendBackDamagedUnitsTr(every,30);
trigger manageRepairTeamTr    (every,30);
trigger doResearchTr          (every,30);
trigger buildBaseTr           (every,30);
trigger buildRepFacSuppAttackTr (every,30);
trigger vtolStructsTr          (every,30);
trigger buildVtolsTr           (every,30);
trigger manageDefVTOLTr    (every,30);
trigger threatCheckTr         (every,30);

trigger manageAttVTOLTr       (every,40); 
trigger unitAssignationCheckTr(every,50);
trigger truckGroupSliderTr    (every,50);
trigger storeEnemyCommandersTr (every,50);

trigger evDebugTr             (every,100);
trigger earlyAttackTr         (every,100);
trigger evPrintDebugTr        (every,100);

trigger updateBaseDetailsTr   (every,200);
trigger vtolEnablerTr				  (every,200);
trigger activateAttackTr      (every,300);

trigger useLassatTr					  (every,3000);
trigger showAImessageTr       (every,6000);


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ DylanDog - EVENTS DECLARATION *+*+*+*+*+*+*++*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*

//event 0
event evDebug;

//main event 1-2
event AIbrain;
event AIcheck;

//harvesting - events 3-4
event	truckGroupSlider;
event	harvesterOperate;


//building  ebvents 5-8
event	upgradeStructures;
event	buildBase;
event	buildRepFirst;
event buildRepFacSuppAttack;


//Research  event 9
event	doResearch;

//event 10-12
event manageDefTank;
event manageDefCyborgs;
event manageAttVTOL;

//ebent 13
event AIattacked;

//attack   event 14-16
event activateAttack; 
event CyborgAttack;
event TankAttack;

//VTOL  event 17-19
event vtolEnabler;
event vtolStructs;
event vtolDefend;

//repair  event 20-22
event manageRepairTeam;
event	unitRepairSwitch;
event sendBackDamagedUnits;

//idleTrucks  event 23
event manageIdleTrucks;

//Units production 24-26 
event	SelectCyborgTemplate;
event	SelectTankTemplate;
event buildVtols;


//Group Management 27-29
event	droidBuilt;
event	unitAssignationCheck;
event	reSortUnits;

//uncategorized 30-34
event	initialisedEvent;
event useLassat;
event difficultyModifier;
event updateBaseDetails;
event showAImessage;

//chat 35-38
event multiMsgEv;
event	beaconEv;
event manageHelpTeam;
event shutDownAI;

//debug  39-41
event evPrintDebug;
event manageDefVTOL;
event reassignPlayers;

//event 42-43
event threatCheck;
event VTOLhunter;

//events 44-45-46
event earlyAttack;
event storeEnemyCommanders;
event manageDefTrucks;

#endregion triggers

//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ DylanDog - FUNCTION DECLARATION *+*+*+*+*+*+*++*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*

function DROID getADroid(GROUP _theGRP);
function bool	droidOrderIdle(DROID _droid);
function void displayMsg(STRING _message);
function FEATURE closestOilRes(DROID _droid, int _x, int _y);
function STRUCTURE closestDerrickToDefend();
function int getNumDerricks(int _player);
//reset oilResTargetId, oilResTargetX, oilResTargetY
function void checkDerrickIsBuilt(int _player);
//return a free position on the array of oilResTargetId & Co.
function int getOilResTargetFree();
function void debugCentreView(DROID _droid);
//gateways and defences
function void helpBuild(DROID _idleTruck);
function bool repairDefStructs(int _group);
function bool repairStructs(int _group);
function int updateGateways();
function void initAssignUnitToGrp();

//base stats
function void updateBaseRange();
function void updateBaseCoord();

//structure
function int numStructsByType(STRUCTURESTAT _structure, int _player, bool _bCompletedStructOlny);

//research
function bool do_Research(STRUCTURE _resFac);
function int do_CheapResearch(STRUCTURE _resFac, int _lastResIndex);
function int find_Research(int _searchStart, int _techTree, int whichArray);

//repair
function DROID unitToBeRepaired(GROUP _group);
function DROID nearestDroidToBeRepaired(GROUP _group, int _x, int _y);
function DROID idleRepairDroid(int _x, int _y);
function void moveUnitsBetweenGRPs(GROUP _toGRP, GROUP _fromGRP, int _unitsToMove, bool _bNoTrucked);
function void attackedByDroid(DROID _droid);
//used when struct attacks my base
function void attackedByStruct(STRUCTURE _struct);
function void sendIdleBackToTheBase(int _group);

//brain
function int getNumStructNotIdle(STRUCTURESTAT _structToCheck);
function int getTotDerricksMap(); 
function bool bAnyOilResLeft(); 
function int numRemainingOilRes();

function STRUCTURE closestEnemyDerrick(bool _mustBeHuman,int _targetPlayer);
function int getCoordRelated(int _x1, int _y1, int _x2, int _y2,int _nWhichCooord, int _nDist);
function BASEOBJ findEnemyOBJ(bool _mustBeHuman,int _targetPlayer);
function int getRandomEnemyPlayer(bool _mustBeHuman);
function int getNearestEnemyPlayer(bool _humanPlayer);
function void updatePlCoord();
function int getEnemy_baseCoord( int _player, STRING sCoord );
function bool friendlyPlayer(int _playerToCheck);

//VTOLS
function void buildRearmPads();
function void vtolFactoryBuildVtol(STRUCTURE _factory);

//others
function void deactivateTankAttack();
function void deactivateCybAttack();
function BASEOBJ objStrTargetInRange(int _xCoord,int _yCoord, int _Range);
function BASEOBJ objDroidTargetInRange(int _xCoord,int _yCoord,int _Range, bool bIsVTOL);
function void orderGroupMoveCMD(GROUP _grp, int _x, int _y);
function void orderGroupScoutCMD(GROUP _grp, int _x, int _y);
function bool harvestNearOilRes();
function void displayErrMsg(STRING _message);

//AI personality
function void SetDyDoPersonality(int nPersonality, int _player);

function bool aiResponsibleForPlayer(int _player);
function void assignDroidToGrp(DROID droid);
function void manageVeryLowPower();
function void manageVeryLowPower2();
function void manageVeryLowPower3();
function void manageVeryLowPower4();
function STRUCTURE getVTOLstructTarget();
function int numEnemyAAInRange(int _x, int _y, int _range);
function bool canHelpAlly(int _sender);
function bool bHelpingAnyAlly();
function void helpAlly(int _ally);
function void deactivateHelp();
//Communication
function void processCommand(STRING _message, int _sender, bool _bBlipMessage);
function void notifyAll(STRING _cstr);
function void sendMsgToAllAllies(STRING _message, bool _bToHuman);
function void dropBeaconToAllies(STRING _message, int _x, int _y, int _z, bool _bToHuman);
function void notifyStatus(int _choice, int _player);
function bool haveBeacon(int _player);
function bool haveAnyBeacon();
function bool beaconTimeout(int _player);
function void updateBeacons();
function void updatePlayersStats();
function int getDroidsInfo(int _player, int _choice);
function int getTeamNumber(int _player);
function BASEOBJ getTargetObj();
function float getPowerIndex(int _player);
function int gameType();
function int getWeaponUnitsInfo( int _player, int _choice);
function int getTargetEnemy(bool _dbg);
function bool bHasHumanEnemies(int _player);

function bool coordChanged(DROID _droid);
function bool hasCoordStored(DROID _droid);
function int getFreePosDroid();
function void updateDroidCoord(DROID _droid);
function void storeDroidCoord(DROID _droid);
function void checkIfDroidIsStuck(GROUP _group);
function void cleanDroidPos(int _droidId);
function void cleanDroidCoordArray();
function void stopDroidHarvesting();
function bool incrementDroidCounter(int droid_id);
function bool isPlayerStillLive(int _player);
function bool buildDefStruct(DROID _droid, int _x, int _y );
function int getSafeBuildCoord( DROID _droid, STRUCTURESTAT _struct, int _x, int _y, int _choice);
function BASEOBJ objHumanDerrick(bool bVTOLTarget, int _numDef, int _distInTiles);
function int numStructinRange(STRUCTURESTAT _struct, int _player, int _xCoord, int _yCoord, int _Range);
function void printDebug(STRING _message);
function void printDebug1( STRING _message);
function bool createAIalliance(int _player1, int _player2);
function STRUCTURESTAT getDefStruct(bool _mustBeWallDef);
function DROID closestIdleDroid(GROUP _group, int _x, int _y);
function DROID closestDroidCanBuild(GROUP _group, int _x, int _y);
function STRUCTURE undefendedEnemyDerrick(bool _bVTOLTarget);
function STRUCTURE getAAStruct(bool _bVTOLTarget);
function void updateDefendRange();
function void shutDownThisAI();
function void activateAI();
function bool buildHeavyTank( int _nWeapon, STRUCTURE _struct );
function bool buildMediumTank( int _nWeapon, STRUCTURE _struct );
function bool buildLightTank( int _nWeapon, STRUCTURE _struct );
function int checkBestBody(int _nBody, int _nWeapon, STRUCTURE _struct );
function void droidMicroManager(GROUP _group,int _range, int _x, int _y);
function DROID getEnemyDroid(int _x,int _y,int _dist,int _droidType);
function bool isAntiPersonnel(DROID _droid);
function bool isAntiTank(DROID _droid);
function BASEOBJ getAAgroups(bool _mustBeHuman);
function int mapSize();
function void setTankGatheringPoint(int _fromX,int _fromY,int _targetX,int _targetY);
function bool isScavenger( int _player );
function bool isFlamer(DROID _droid);
function void vtolAttack(BASEOBJ oTarget);
function bool isLongRange(DROID _droid);
function STRUCTURE getEnemyDefStruct(GROUP _group,int _range);
function bool buildHeavyTank1( int _nWeapon, STRUCTURE _struct );
function bool buildMediumTank1( int _nWeapon, STRUCTURE _struct );
function bool buildLightTank1( int _nWeapon, STRUCTURE _struct );
function int checkBestBody1(int _nBody, int _nWeapon, STRUCTURE _struct );
function int numFactModule(int _player, int _numModules);
function int numDroidsBuilding(GROUP _group, int _x, int _y);
function bool buildHeavyTank2( int _nWeapon, STRUCTURE _struct );
function bool buildMediumTank2( int _nWeapon, STRUCTURE _struct );
function bool buildLightTank2( int _nWeapon, STRUCTURE _struct );
function int checkBestBody2(int _nBody, int _nWeapon, STRUCTURE _struct );
function DROID getNearestIdleDroid(int _x, int _y);
function bool IsTeamLeader();
function void SetDyDoPath();
function int getNumTeamMates();
function DROID getNearestEnemyCmd(int _player);
function int canBigHelpAlly(int _sender);
function int getPlayerPos(int _player);
function void buildAAdef(DROID _droid);
function void buildArtillery(DROID _droid);
function void defFromLongRangeWeap(DROID _droid);
function void defendBase(DROID _droid);
function void buildGatewayDef(DROID _defTruck);
function void defendDerrick(DROID _droid);
function void buildRippleRockets(DROID _droid);
function int getPosToBuildDef(int _pos);
function int playerIsNear(int _player);
function void resetVTOLAttack();
function int getAA_OnTheWay(int _grpX, int _grpY, int _destX, int _destY, int _range);
function int numIdleVTOLs(GROUP _grp);
function int numVTOLRepRearm(GROUP _grp);
function int numAttackVTOLs(GROUP _grp);
function bool isVTOLidle(DROID _droid);
function bool isVTOLRepRearm(DROID _droid);
function bool isVTOLRepairing(DROID _droid);
function bool isAntiStruct(DROID _droid);
function bool isVeryLongRange(DROID _droid);


//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+ MAIN SCRIPT *+*+*+*+*+*+*++*+*+*+*+*+*+*+*+*+*+*+*
//+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*


// HouseKeeping

event initialisedEvent(CALL_GAMEINIT)
{

  //player = getPlayer();//trunk
  
  lassatTarget = NULLOBJECT; defSpotY = 0 ; defSpotX = 0 ; maxy = 0 ; maxx = 0;
  miny = 0 ; minx = 0 ; baseY = 0 ; baseX = 0 ;
  
  //DEBUGMESSAGE
  dbgMsgOn(player, false);
  debugCenterView = false;
  _DEBUG = true;//print off debug messages every 5 min
  _DEBUG1 = true;//print off debug messages 
  bRunning = false;  //true if AI controls this player
  
  count =0;
  while (count < 8){
    aPl[count][X_COORD]  = -1;
    aPl[count][Y_COORD]  = -1;
    aPl[count][IS_ENEMY] = -1;
    aPl[count][PL_POSITION] = -1;
    count++;
  }
  
  count =0;
  while (count < 4){
    aGatewayPosX[count]       = -1;
    aGatewayPosY[count]       = -1;
    count++;
  }
  tGtwDefBuilt = 0;
  nResTmplPath = -1;
  bScoutOrder = true;
  bFactUpgraded2Modules = false;
  bFactUpgraded1Module = false;
  bDyDoHasHeavyBody = false;
  bIsEnemyHumanOnly = false;
  nAI_Pers = 0;
  nTotCyborgBuilt = 0;
  nTotTankBuilt = 0;
  tFinishOilHack = gameTime;
  nAIcheck        = 0;
  tAIbrain        = 0;
  defTruckSentTime= -1;
  sentToGateway   = false;
  isBackinBase    = false;
  bNeedDerrick    = false;
  bAttackTeamAttacked = false;
  bFinalAttack_1vs1 = false;
  nAllyBeingHelped = -1;
  nStructToBeBuilt = STR_TANK_FACTORY;
  tVtolAction  = 0;
  tDefTankAction  = 0;
  tDefCybAction   = 0;
  tLastResearch   = 0;
  tLastHelp       = 0;
  tLastArtilleryBuilt = 0;
  tLastRRBuilt = 0;
  tLongRangeTime = 0;
  nHelpX          = -1;
  nHelpY          = -1;
  tLastbuildBaseDef = 0;
  nRealGatewaysFound = 0;
  lastBuildDefX   = -1;
  lastBuildDefY   = -1;
  lastResIndex    = -1;
  nMidX           = -1;
  nMidY           = -1;
  gatherDefTankX = -1;
  gatherDefTankY = -1;
  gatherDefCybX   = -1;
  gatherDefCybY   = -1;
  nTotGateways    = 3;
  nTotOilInAtStart = 0;
  bLastMember = false;
  bLastMembPersIsSet = false;
  lastDisplayAI   = 0;
  lastDisplayAIcheck = 0;
  nTeamMates = 0;
  lastTruckBuilt  = 0;
  lastCybEngBuilt = 0;
  lPathSet = false;
  nPlayersInGame  = -1;
  nAAPos = 0;
  nHumanPlayers   = 0;
  nTeam = -1;
  nEnemyPlayers = -1;
  nLastEnemyPlayer = -1;
  nLastTimeBuiltRepFac = 0;
  nDefPhase = 0;
  numDefStrAtGateway  = -1;
  lastTimeRepairBuilt = 0;
  nLastDefSpotUpdate  = -1;
  tLastPowerSwitch = 0;
  nProdSelect   = 0;
  nDamageLevelRepair = 0;
  nFinalAttacks = 0;
  tLastFinalAttack = 0;
  bEarlyAttack = false;
  alertIsOn    = false;
  alertX       = baseX;
  alertY       = baseY;
  alertTime    = gameTime;
  bCybAttIsOn  = false;
  lCybSentToGatheringPoint = false;
  bCybAlreadyGathered      = false;
  bAttackedByVTOL = false;
  cybAlertX    = -1;
  cybAlertY    = -1;
  cybAttackX = 0;
  cybAttackY = 0;
  bPositionUpdated = false; 
  nCybGatheringX        = -1;
  nCybGatheringY        = -1;
  targetPlayerCyb       = -1;
  tCybSentToGathering   = 0;
  tCybReSentToGathering = 0;
  tCybAttackAction      = 0;
  tTankAttackAction     = 0;
  tHelpAction           = 0;
  tChangeTimeTankToAdd  = 0;
  tLastPowerGen         = 0;
  tLastTankAttack       = 0;
  tTotalAttack = random(3000);
  tLastCyborgAttack     = 0;
  tLastVTOLFactBuild    = 0;
  tLastAAbuilt          = 0;
  tLastBBbuilt          = 0;
  nEarlyMortars = 0;
  //tank attack    
  bTankAttIsOn              = false;
  lTankSentToGatheringPoint = false;
  bTankAlreadyGathered        = false;
  nTankGatheringX           = -1;
  nTankGatheringY           = -1;
  tankAttackX                = -1;           
  tankAttackY                = -1;
  targetPlayerTank         = -1;
  targetPlayerVTOL          = -1;
  tTanksSentToGathering     = 0;
  tTanksReSentToGathering     = 0;
  pickWallDefQueueDepth = 0; 
  nResearchCounter = 0;
  nKineticX = -1;
  nKineticY = -1;
  tCBSense = 0;
  nAttHumanPlayer = 0;
  nAttAIPlayer = 0;
  tEveryMin  = 0; 
  tEvery3Min = 0;
  tHarvestNearOilRes = 0; 
  tBeaconSent = 0;
  nTanksDefGrp=0;
  nAttackingUnitsToAdd  = random(MAX_ATTACK_TANKS_ADD);
  nCybAttUnitsToAdd     = random(MAX_ATTACK_CYBORG_ADD);
  bScavAreActive        = false;
  lStopBuildDef 	      = false;
  lStopBuildDefDerricks = false;
  lStopBuildDefGateway  = false;
  lStopTankProduction   = false;
  lStopBuildTankProd    = false;
  lStopCybEngProd       = false;
  lStopCybProduction    = false;
  lStopResearch         = false;
  lStopCheapResearch    = false;
  lStopBuildRepFacility = false;
  lStopBuildingStructures  = false;	
  lMinBaseStructBuilt      = false;  
  lStopResLabUpgrade       = false; 
  lStopVTOLFactBuilding    = false; 
  lStopVTOLProduction      = false; 
  attackCybObj             = NULLOBJECT;
  bDroidSelected           = false;
  tBeaconTimeout           = 45;	//in secs
  bAttackHumanDerrick    = false;//alternate attacks
  bAttackingHumanDerrick = false; //identify if an attack to a human derrick is active or not
  bAttackedByMortars       = false;
  bAttackedByLongRangeWeap   = false;
  bAAgroupsAttacked = false;
  bPowerNormalized = false;
  bPlayWithBB = false;
  tLastCybMech = 0;
  nCybMechanic = 0;
  tTargetTime = 0;
  tGatheringTank  = 0;
  tGatheringCyb  = 0;
  nArtilleryPos = 0;
  nRippleRocketsPos = 0;
  nDefendBasePos = 0;
  nAPTankBuilt = 0;
  nAPCyborgBuilt = 0;
  nEarlyAttack = 0;
  lStopPowGenUpgrade = true;
  bHumPlUsesCommanders = false;
  dNearestEnemyCmd = NULLOBJECT;
  nBigHelp_ok = 0;
  tBigHelpRequest = 0;
  nBigHelpRequests = 0;
  bEnemyIsNear = false;
  nNearestEnemy = -1;
  nStdDef = 0;
  nWallDef = 0;
  tVTOLAttackReset = 0;
  nWeapSelection = 0;
  nWeapCybSelection = 0;
  
  nDroidsEarlyAtt = random(2)+1; 
  
  num_aDroid = 50;
  count = 0;
  while ( count < num_aDroid ){
    aDroid_Id[count]  = -1;
    aDroid_X[count]   = -1;
    aDroid_Y[count]   = -1;
    aDroid_counter[count] = 0;
    count++;
  }
  
  count=0;
  while ( count < MAX_PLAYERS){
    beaconX[count] = -1;
  	beaconY[count] = -1;
  	tBeacon[count] = -1;
  	count++;
  }
  
  aPower[VERY_LOW_POWER]  = 300; 
  aPower[LOW_POWER]       = 600; 
  aPower[HIGH_POWER]      = 1000; 
  
  count = 0;
  while ( count < 11 )
  {
    oilResTargetId[count] = -1; oilResTargetX[count] = -1; oilResTargetY[count] = -1;
    count++;
  }
  
  count = 0;
  nStat = 20;
  while ( count < nStat )
  {
    //reset array players stats
    count2 = 0;
    while ( count2 < MAX_PLAYERS )
    {
      aStat[count][count2] = -1;
      count2++;
    }
    count++;
  }
  
  numMaxDerricks    = 40; //max number of derricks per player
  
  structure = getStructure(playerHQ, player);
  if(structure != NULLOBJECT)
  {
  	baseX = structure.x;
  	baseY = structure.y;
  }
  else
  {
    groupAddArea(buildGrp, player, 0, 0, (mapWidth*128), (mapHeight*128));
  	if(buildGrp.members > 0)
  	{
  		baseX = buildGrp.x;
  		baseY = buildGrp.y;
  	}
  	else
  	{
  		baseX = (128*mapWidth)/2;
  		baseY = (128*mapHeight)/2;
  	}
  }
  
  
  if ( AIPersonality == AI_TURTLE ){
    tTimeForceAttack = (20*TIME_MINUTE + random(1800));
  } else {
    tTimeForceAttack = (8*TIME_MINUTE + random(2000));
  }

  tStartBaseAttacks = (20*TIME_MINUTE + random(3000));
  
  //AIstrength
  if ( AIstrength <= 0 or AIstrength > 5){
    AIstrength = 1+random(5);
  }
  
  initAssignUnitToGrp();
  //initialises all the no go areas to 0. 
  //Should be called when a new map is loaded
  initAllNoGoAreas();
  
  //for all players, avoid attacking themselves 
  createAlliance(player,player);
  
  //makes a research available to a player regardless of its pre-requisites
  enableResearch(CyborgLegs, player); 
  completeResearch(CyborgLegs, player);
  
  //LIFE = true;
  nBaseRange=TILE*12;
  
  //nDefend range
  updateDefendRange();
  
  //estimate the range for the gateways and the defend range
  if ( nDefendRange > 0 ){
    gatewaysRangeTiles  = nDefendRange/TILE;
  } else {
    if ( max(mapWidth,mapHeight) <= 92 ){
      gatewaysRangeTiles  = 22;
    } else if ( max(mapWidth,mapHeight) > 92 and max(mapWidth,mapHeight) <= 105 ){
      gatewaysRangeTiles  = 28;
    } else if ( max(mapWidth,mapHeight) > 105 and max(mapWidth,mapHeight) <= 128 ){
      gatewaysRangeTiles  = 36;
    } else {
      gatewaysRangeTiles  = 40;
    }
  }
  
  //time to force droids production. This is the time gone from last attack, if reached
  //droids production is forced 
  nAttackTime = 7000 + random(4000);
  
  //store the numb of derricks at the beginning
  nDerricksAtStart = getNumDerricks(player);
  
  //oilRes available in the map
  nFreeOilRes      = numRemainingOilRes();
  
  //player stats, updates nPlayersInGame
  updatePlayersStats();
  
  //play with BB? false as default
  if ( nTeamMates == 1 ){
    if ( random(100) < 50 ){
      bPlayWithBB = true;
    }
  } else if (  nTeamMates >= 2  ) {
    bPlayWithBB = true;
  }

  //_______ AI PERSONALITY SETTINGS ________________
  SetDyDoPersonality(AIPersonality, player);
   
  //search if gateways have been added in the map
  nRealGatewaysFound = updateGateways();
  
  
  printDebug1( DYDOBP_RELEASE & ", starting power: (" & playerPower(player) & ") map("& mapWidth &"-"& mapHeight &") mapSize:"& mapSize() &" scavengers("& scavengersActive() &") " );

  //initialize eventCheckTime[]
  count=0;
  while (count < EVENT_CHECK_NUMBER){
    eventCheckTime[count]    = gameTime;
    eventCheckCounter[count] = 0;
    count++;
  }
  
  //set trigger time
  count=0;
  while (count < EVENT_CHECK_NUMBER){
    eventCheckTrigger[count] = 600;
    eventCheckReport[count] = 0;
    count++;
  }
  eventCheckTrigger[0] = 3050;//lassat
  
  
  //scavenger stuff
  if ( scavengersActive() ){ bScavAreActive = true; }
  
  if( aiResponsibleForPlayer(player) )
  {
  	bRunning = true;
    activateAI();
  } else {
    shutDownThisAI();
  }
  
  if ( !bScavAreActive  ){
   if ( random(10) < 5 or AIstrength > 3){
     bEarlyAttack = true;//force quick prod of droids to run earlyAttack
    //printDebug1("event earlyAttack ACTIVATED, AI level("& AIstrength &") nDroidsEarlyAtt("& nDroidsEarlyAtt &")"); 
     setEventTrigger(earlyAttack,earlyAttackTr);
   }
  }
  

  /*
  if (  isScavenger(7) ){
   createAlliance(player,7);
   console("Dydo-AI: Alliance created ("& allianceExistsBetween(player,7) &")("& alliancesLocked() &")");
  }
  */
  
}
//=============================================
event VTOLhunter (inactive){
  
  //dbg("dbg->VTOLhunter: start ("& vtolHunterGr.members  &")",player);
  
  eventCheckTime[23] = gameTime;

  if ( vtolHunterGr.members < 0 ){
    setEventTrigger(VTOLhunter, inactive);
    exit;
  }
  
  /*
  if ( oVTOLhunterTarget == NULLOBJECT ){
    //oilRes
    if (bOilResLeft){
      droid = getADroid(VTOLhunter);
      _oilRes = closestOilRes(droid, droid.x, droid.y);//uses droidCanReach  
      if ( _oilRes == NULLOBJECT ){
      }
    
    }
    //move
  } else {
  }
  */

}
//==============================print stats and debug messages ===============
event evPrintDebug (inactive)
{
  
	local string _sPlPow, _sPlInf1,_sPlInf2,_sPlInf3, _sPlInf4,_strTeams, _sWallDef, _sDef; 
  local string _sRes, _sRes2, _str0, _str1, _str2, _str3, _str4, _str5,_str6, _sFort;
  local int _count,_nMax;
    
  if ( gameTime - tEveryMin >= 600 ) {
    //printDebug1("Structs not idle; nProdSelect("& nProdSelect &") (Fac-Cyb-Res-VTOLfac)  ("& nWorkingFact &"-"& nWorkingCybFac &"-"& nWorkingLab &"-"& nWorkingVTOLFac &") power["& playerPower(player) &"] Low Power("& aPower[VERY_LOW_POWER] &") tot Tank+Cyb("& nTotTanks+nTotCyborgs &") nAttackTime("& gameTime-nTime &"/"& nAttackTime &")");
    tEveryMin = gameTime;
  }       
  /*
  if ( gameTime - tEvery3Min >= 1800 ) {
    
    _count = 0;
    while ( _count < numWallWeaps ){
      _sWallDef = _sWallDef & " ["& _count &"]("& isStructureAvailable(wallWeaps[_count],player) &") ";
      _count++;
    }
    _count = 0;
    while ( _count < numDefStructs ){
      _sDef = _sDef & " ["& _count &"]("& isStructureAvailable(defStructs[_count],player) &") ";
      _count++;
    }
    _count = 0;
    while ( _count < numFortressDef ){
      _sFort = _sFort & " ["& _count &"]("& isStructureAvailable(fortressDef[_count],player) &") ";
      _count++;
    }
    

    if ( nResTmplPath == RESTMPL_1 ){//nResTmplPath == RESTMPL_1 
      _nMax = numPath1[0];
    } else {
      if ( nResTmplPath == RESTMPL_2 ){
      _nMax = numPath2[0];
      } else {
        _nMax = numRes[0];
      }
    }
    if ( AIPersonality == AI_CYBORG ){
      _nMax = numResGen4[0];
    }


    _count = 0;
    while ( _count < 20){
      _str0 = _str0 & " ["& _count &"]"& numResearchLeft(player,research[0][_count]) &" ";
      _count++;
    }
    while ( _count < 40){  
      _str1 = _str1 & " ["& _count &"]"& numResearchLeft(player,research[0][_count]) &" ";
      _count++;
    }
    while ( _count < _nMax){
      _str2 = _str2 & " ["& _count &"]"& numResearchLeft(player,research[0][_count]) &" ";
      _count++;
    }
    

    if ( nResTmplPath == RESTMPL_1 ){
      _nMax = numPath1[1];
    } else {
      if ( nResTmplPath == RESTMPL_2 ){
        _nMax = numPath2[1];
      } else {
        _nMax = numRes[1];
      }
    }
    if ( AIPersonality == AI_CYBORG ){
      _nMax = numResGen4[1];
    }

    _count = 0;
    while ( _count < 20){
      _str3 = _str3 & " ["& _count &"]"& numResearchLeft(player,research[1][_count]) &" ";
      _count++;
    }
    while ( _count < 39){
      _str4 = _str4 & " ["& _count &"]"& numResearchLeft(player,research[1][_count]) &" ";
      _count++;
    }
    while ( _count < _nMax){//numRes[1]){
      _str5 = _str5 & " ["& _count &"]"& numResearchLeft(player,research[1][_count]) &" ";
      _count++;
    }

    _count = 0;
    while ( _count < numCheapRes[0] ){
      _sRes2 = _sRes2 & " ["& _count &"]"& numResearchLeft(player,researchCheap[0][_count]) &" ";
      _count++;
    }
    
    _count = 0;
    while ( _count < numRes[9] ){
      _str6 = _str6 & " ["& _count &"]"& numResearchLeft(player,research[9][_count]) &" ";
      _count++;
    }
    
    _count = 0;
    while (_count < MAX_PLAYERS){
      if (isPlayerStillLive(_count)){
        _strTeams = _strTeams & " '"& getPlayerName(_count) &"' #"& _count &" ["& aPlayers[TEAM_NUMBER][_count] &"] ";
      }
      _count++;
    }
    
    _count=0;
    while( _count < 2){
      if (isPlayerStillLive(_count)){
        _sPlInf1 = _sPlInf1 & " *["& getPlayerName(_count) &"] RL(" & aStat[OC_RESLABS][_count] & ") Der("& aStat[OC_DERRICKS][_count] &") Cy-Tk-VTOL("& aStat[OC_CYBORGS][_count] &"-"& aStat[OC_TANKS][_count] &"-"& aStat[OC_VTOLS][_count] &") Pow("& aStat[OC_CYB_POWER][_count] &"-"& aStat[OC_TK_POWER][_count] &"-"& aStat[OC_VTOL_POWER][_count] &") hp("& aStat[OC_CYB_HP][_count] &"-"& aStat[OC_TK_HP][_count] &"-"& aStat[OC_VTOL_HP][_count] &")";
      }
      _count++;
    }
    while( _count < 4 ){
      if (isPlayerStillLive(_count)){
        _sPlInf2 = _sPlInf2 & " *["& getPlayerName(_count) &"] RL(" & aStat[OC_RESLABS][_count] & ") Der("& aStat[OC_DERRICKS][_count] &") Cy-Tk-VTOL("& aStat[OC_CYBORGS][_count] &"-"& aStat[OC_TANKS][_count] &"-"& aStat[OC_VTOLS][_count] &") Pow("& aStat[OC_CYB_POWER][_count] &"-"& aStat[OC_TK_POWER][_count] &"-"& aStat[OC_VTOL_POWER][_count] &") hp("& aStat[OC_CYB_HP][_count] &"-"& aStat[OC_TK_HP][_count] &"-"& aStat[OC_VTOL_HP][_count] &")";
      }
      _count++;
    }
    while( _count < 6 ){
      if (isPlayerStillLive(_count)){
        _sPlInf3 = _sPlInf3 & " *["& getPlayerName(_count) &"] RL(" & aStat[OC_RESLABS][_count] & ") Der("& aStat[OC_DERRICKS][_count] &") Cy-Tk-VTOL("& aStat[OC_CYBORGS][_count] &"-"& aStat[OC_TANKS][_count] &"-"& aStat[OC_VTOLS][_count] &") Pow("& aStat[OC_CYB_POWER][_count] &"-"& aStat[OC_TK_POWER][_count] &"-"& aStat[OC_VTOL_POWER][_count] &") hp("& aStat[OC_CYB_HP][_count] &"-"& aStat[OC_TK_HP][_count] &"-"& aStat[OC_VTOL_HP][_count] &")";
      }
      _count++;
    }
    while( _count < MAX_PLAYERS ){
      if (isPlayerStillLive(_count)){
        _sPlInf4 = _sPlInf4 & " *["& getPlayerName(_count) &"] RL(" & aStat[OC_RESLABS][_count] & ") Der("& aStat[OC_DERRICKS][_count] &") Cy-Tk-VTOL("& aStat[OC_CYBORGS][_count] &"-"& aStat[OC_TANKS][_count] &"-"& aStat[OC_VTOLS][_count] &") Pow("& aStat[OC_CYB_POWER][_count] &"-"& aStat[OC_TK_POWER][_count] &"-"& aStat[OC_VTOL_POWER][_count] &") hp("& aStat[OC_CYB_HP][_count] &"-"& aStat[OC_TK_HP][_count] &"-"& aStat[OC_VTOL_HP][_count] &")";
      }
      _count++;
    }
    
    printDebug("------------------------------------------------------------------");
    if ( nResTmplPath == RESTMPL_1){
      if ( resPath1[0][8] != research[0][8]){
        printDebug("#### Research path 1 is NOT fine!!!");
      } else {
        printDebug("Research path 1 is fine: Flamers and Rockets");
      }
    }
    if ( nResTmplPath == RESTMPL_2){
      if ( resPath2[0][8] != research[0][8]){
        printDebug("#### Research path 2 is NOT fine!!!");
      } else {
        printDebug("Research path 2 is fine: Gunners and Cannons");
      }
    }
    
    printDebug("Stats A: nAIcheck("& nAIcheck &") gameType("& gameType() &") map("& mapWidth &"-"& mapHeight &") BaseRange("& nBaseRange/TILE &") gtwRange("& gatewaysRangeTiles &") DefRange("& nDefendRange/TILE &") Base("& baseX/TILE &"-"& baseY/TILE &") tk("& nTotTanks &") cyb("& nTotCyborgs &")");
    printDebug("Stats B: lMinBaseStructBuilt("& lMinBaseStructBuilt &") bIsEnemyHumanOnly("& bIsEnemyHumanOnly &") nTotBaseDefences("& nTotBaseDefences &") bAttackedByVTOL("& bAttackedByVTOL &") numAAinBase("& numAAinBase &") ");
    printDebug("Stats C: Cyb built(AR-AT-AP-KK)(Err) ("& nTotCybAR &" - "& nTotCybAT &" - "& nTotCybAP &" - "& nTotCybKK &")("& nTotCybErr &") lastTK("& gameTime - tLastTankAttack &")lastCyb("& gameTime - tLastCyborgAttack &") tStBaseAtt("& tStartBaseAttacks &") bEnIsNear("& bEnemyIsNear &") nNearEn("& nNearestEnemy &")");
    printDebug("Stats D: tLastCyborgAttack("& tLastCyborgAttack &") tLastTankAttack("& tLastTankAttack &") nResTmplPath ("& nResTmplPath &") " & _strTeams &" Teams("& nTeam &")");
    printDebug("Stats E: nEnemyPlayers ("& nEnemyPlayers &") nHumanPlayers("& nHumanPlayers &") nPlayersInGame("& nPlayersInGame &") Att Human Player("& nAttHumanPlayer &") Att AI("& nAttAIPlayer &") anyOilResLeft("&  bOilResLeft &") nTotEnemyDroids("& nTotEnemyDroids &")");
    printDebug("Stats1:" & _sPlInf1 );
    printDebug("Stats2:" & _sPlInf2 );
    printDebug("Stats3:" & _sPlInf3 );
    printDebug("Stats4:" & _sPlInf4 );
    printDebug("Std Def: Depth("& pickDefQueueDepth  &") - " & _sDef );
    printDebug("Wall Def: Depth("& pickWallDefQueueDepth  &") - "& _sWallDef);
    printDebug("Fortresses: Depth("& pickFortQueueDepth  &") - "& _sFort);
    printDebug("Res 1 [0]: " & _str0 );
    printDebug("Res 2 [0]: " & _str1 );
    printDebug("Res 3 [0]: " & _str2 );
    printDebug("Res 4 [1]: " & _str3 );
    printDebug("Res 5 [1]: " & _str4 );
    printDebug("Res 6 [1]: " & _str5 );
    printDebug("Cheap Res: "& numCheapRes[0] & " " & _sRes2);
    printDebug("VTOL Res: "& _str6);
    count = getTargetEnemy(true);
    printDebug("------------------------------------------------------------------");
    
    tEvery3Min = gameTime;
  }
  */
}
//==============================event used to fix errors===============
event evDebug (inactive)
{
    
  if ( nAllyBeingHelped < 0 and helpGroup.members > 0 and gameTime - tLastHelp > 30){
    groupAddGroup(tankDefGroup, helpGroup);
    orderGroup(tankDefGroup, DORDER_RTB);
  }
    
  //Search for stucked droids
  //cleanDroidCoordArray();
  //checkIfDroidIsStuck(buildGrp);
  //checkIfDroidIsStuck(buildDefGrp);
  //checkIfDroidIsStuck(harvesterGroup);

}
//-----------------------------------------------------------------
event shutDownAI(inactive)
{

  eventCheckTime[24] = gameTime;

  //check if all enemies are dead
  count = 0;
  boolResult  = true;
  boolResult2 = false;

  while ( count < MAX_PLAYERS and boolResult ){
    if ( !friendlyPlayer(count) ){
      if ( isPlayerStillLive(count) ){
        boolResult = false;
      }
    }
    count++;
  }
  //then check if this AI is dead
  if ( !isPlayerStillLive(player) ){
      boolResult2 = true;
      printDebug(" ________shutting down this AI: game lost______");
  }
  if ( boolResult ){
      printDebug(" _________shutting down this AI: game won_______");
  }

  //check if this player is dead...
  if ( boolResult or boolResult2 ){
    shutDownThisAI();
  }
  
}
//================================================================
//this event checks that most important events are not stucked
event AIcheck (inactive)   //event 3
{
  local string errorMSG, errorMSG2, errorMSG3, errorMSG4;
  local int tTimeGone;

  if ( gameTime-tFinishOilHack < 100 ) {exit;}//harvestoperate would generate an error
  

  errorMSG   = "An error occurred on the Dydo-AI script player ("& player &"), this error message will appear only 4 times";
  errorMSG2  = "Please report the below DEBUG REPORT to http://forums.wz2100.net/ or on the AI webpage http://www.obooma.net/dydo/";
  errorMSG3  = "DEBUG REPORT: ";
  
  //TEST
  
  count=0;
  while (count < EVENT_CHECK_NUMBER){
   tTimeGone = (gameTime - eventCheckTime[count]);
   	if (  tTimeGone > eventCheckTrigger[count]  ){
  		if (eventCheckCounter[count] < 4){
        nAIcheck++;
  		  eventCheckCounter[count]  = eventCheckCounter[count] + 1;
        eventCheckReport[count]   = eventCheckReport[count] + 1;
  			errorMSG3 = errorMSG3 & "   event:"& count &"["& eventCheckTime[count] &"] time gone:("& tTimeGone &") should be("& eventCheckTrigger[count] &") ";
    	}
  	} else {
  		if (eventCheckReport[count] > 0){
        eventCheckReport[count] = 0;
        eventCheckCounter[count] = 0;
      }
    }
    count++;
  }	
        

  count=0;
  while (count < EVENT_CHECK_NUMBER){
   if (  eventCheckReport[count] > 0  and eventCheckCounter[count] < 4 and  (gameTime - lastDisplayAIcheck) > 50 ){
      printDebug1( "### AIcheck; " & errorMSG3 );
   		lastDisplayAIcheck = gameTime;
  	}
    count++;
  }	
  
   //DEBUG MESSAGE
  if ( gameTime - lastDisplayAIcheck >= 600 ){
    lastDisplayAIcheck = gameTime;
  }
  
}
//-----------------------------------------------------------------
event showAImessage(wait,60) {
  //let human player know he is playing with DyDo-AI mod
  local string _strMessage,_strAIDesc;
  local bool bWebSite;
  
  count = 0;
  while(count < MAX_PLAYERS)
	{
    
    if ( isHumanPlayer(count) and count != player ){
      if (showAIPersonality){
        if ( AIPersonality == AI_STANDARD){ _strAIDesc = "Standard AI"; }
        if ( AIPersonality == AI_VTOL){ _strAIDesc = "VTOL AI"; }
        if ( AIPersonality == AI_TURTLE){ _strAIDesc = "Turtle AI"; }
        if ( AIPersonality == AI_CYBORG){ _strAIDesc = "Cyborg AI"; }
        if(allianceExistsBetween(count,player)){
          _strMessage = "player " & player & "; " & DYDOBP_RELEASE & "; " & _strAIDesc &"; Level ["& AIstrength &"] research path["& nResTmplPath &"]  (Ally)";
        } else {
          _strMessage = "player " & player & "; " & DYDOBP_RELEASE & "; " & _strAIDesc &"; Level ["& AIstrength &"] research path["& nResTmplPath &"]  (Enemy)" ;
        }
      } else {
        _strMessage = DYDOBP_RELEASE & " is active";
      }
      msg( _strMessage, player, count );
    }
    count++;
  }
  setEventTrigger(showAImessage, showAImessageTr);
}
//-----------------------------------------------------------------
	// find my lassat
	// fire it at my attack objective.
event useLassat(inactive)
{

	local BASEOBJ _targetStruct;
	local int _loop,_pos,_xCoord,_yCoord,_targetPl,_rnd,_nTargets;
	local bool _mustBeHuman;
	local STRUCTURESTAT _aTargets[7];
  
  eventCheckTime[0] = gameTime;
  
  _nTargets   = 7;
  _aTargets[0] = powGen;
  _aTargets[1] = factory;
  _aTargets[2] = cybFactory;
  _aTargets[3] = vtolFactory;
  _aTargets[4] = lassat;
  _aTargets[5] = playerHQ;
  _aTargets[6] = uplinkCenter;
 
  _targetPl     = -1;
  _targetStruct = NULLOBJECT;
  
  if ( !isStructureAvailable(lassat,player) ){
    exit;
  } 

  if ( AIstrength > 3 and bHasHumanEnemies(player) ){
    _mustBeHuman = true;
  } else {
    _mustBeHuman = false;
  }
  
    
  //find the nearest enemy player
  _targetPl = getNearestEnemyPlayer(_mustBeHuman);
  if (_targetPl < 0 ){
    _targetPl = getRandomEnemyPlayer(_mustBeHuman);//be sure we have a target player
  }
  
  if ( _targetPl < 0 ){ 
    printDebug1("#### useLassat; _targetPl < 0 ("& _mustBeHuman &")");
    exit; 
  }
  //get a target struct
  _pos      = random(_nTargets);
  _loop     = 0;
  while( _loop < _nTargets and _targetStruct == NULLOBJECT)
  {
    if ( AIstrength < 4 ){
      initEnumStruct(false, _aTargets[_pos], _targetPl, player);//get only visible enemy structs
    } else {
      initEnumStruct(false, _aTargets[_pos], _targetPl, _targetPl);//get also enemy structs not visible to player
    }
    _targetStruct = enumStruct();
    _loop++;
    _pos++;
    if ( _pos == _nTargets ){ _pos = 0; }
  }
  
  //target found!!
  boolResult=false;
  if(_targetStruct != NULLOBJECT)
	{
   //printDebug1("useLassat; target found !! _targetPl("& getPlayerName(_targetPl) &") _pos("& _pos &")"); 
    initEnumStruct(FALSE,lassat,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if( structureComplete(structure) )
			{
       //printDebug1("useLassat; Lassat ("& structure.id &") fires to struct.id ("& _targetStruct.id &") player ("& getPlayerName(_targetStruct.player) &") ");
        skFireLassat(player,_targetStruct);
        boolResult = true;
			}
			structure= enumStruct();
		}
	} 
  //else { 
    //printDebug1("useLassat; No target found, _targetPl("& getPlayerName(_targetPl) &") _loop("& _loop &")"); 
  //}

	if ( !boolResult ){
	 printDebug1("##### useLassat; Lassat hasn`t fired at all!");
  }

}
//================================================================
event AIbrain (inactive)
{
  
  local int _nMaxCybEngineers, _nMaxTrucks;
  local int _nDefRangeCheck, _player, _nAA;

  eventCheckTime[1] = gameTime;

  //which type of Tier at game start
  nT_Game = T1_GAME;
  if ( researchFinished(phytonBody, player) )
  {
    nT_Game = T2_GAME;
  }
  if (researchFinished(tigerBody, player) )
  {
    nT_Game = T3_GAME;
  }

  _player = 0;
	while( _player < MAX_PLAYERS )
	{
		if( !isPlayerStillLive(_player) ){
		  aPl[_player][X_COORD]  = -1;
		  aPl[_player][Y_COORD]  = -1;
		  aPl[_player][IS_ENEMY] = -1;
		  aPl[_player][PL_POSITION] = -1;
    }
		_player++;
	}

  //hack to put all at same power when debugging
  if ( isHumanPlayer(player) and !bPowerNormalized ){
    bPowerNormalized = true;
    count = playerPower(player);
    if ( player == 0 ){  count1 = playerPower(1); } else { count1 = playerPower(0); }
    count2 = count1 - count;
    if ( count2 > 300 ){ 
      addPower(500,player);  
      printDebug1("InitializedEvent; added 500 power to player #"& player &"-"& getPlayerName(player) &", starting was power("& count &") instead of power("& count1 &")");
    }
  } 

  //reset alert
  if (gameTime - alertTime > TIME_TO_RESET_ALERT){
      alertIsOn = false;
      alertX    = -1;
      alertY    = -1;
      alertTime = -1;
      alertLevel= ALERT_INACTIVE;
  }
  
  if ( mapSize() == MAP_SMALL ) { _nDefRangeCheck =  1; }
  if ( mapSize() == MAP_MEDIUM ){ _nDefRangeCheck =  4; }
  if ( mapSize() == MAP_BIG )   { _nDefRangeCheck =  8; }
  nTotBaseDefences = numFriendlyWeapStructsInRange(player, baseX, baseY, nBaseRange+_nDefRangeCheck*TILE , false)-numAAinRange(player, player, baseX, baseY, nBaseRange+_nDefRangeCheck*TILE);
  
  nTotTanks 	    = tankGroup.members+tankDefGroup.members+toBeRepairedTankGroup.members+helpGroup.members;
  nTotCyborgs     = cyborgDefGroup.members + cyborgAttGroup.members + toBeRepairedCyborgGroup.members;
  nMyDerricks     = getNumDerricks(player);
  nPower	        = playerPower(player);
  nFactories	    = numStructsByType(factory, player, false);
  nFact1Mod       = numFactModule(player,1);
  nFact2Mod       = numFactModule(player,2);
  nVTOLFactories  = numStructsByType(vtolFactory, player, false);
  nResLabs	      = numStructsByType(resLab, player, false);
  nCybFact	      = numStructsByType(cybFactory, player, false);
  nRepairFac      = numStructsByType(repairFacility, player, false);
  nWorkingVTOLFac = getNumStructNotIdle(vtolFactory);
  nWorkingFact    = getNumStructNotIdle(factory);
  nWorkingLab	    = getNumStructNotIdle(resLab);
  nWorkingCybFac  = getNumStructNotIdle(cybFactory);
  nFreeOilRes      = numRemainingOilRes();
  bOilResLeft      = bAnyOilResLeft(); 
  numAAinBase = numAAinRange(player, player, baseX, baseY, nBaseRange );
   //nTotDerricks     = getTotDerricksMap();//nTotOilInAtStart
  //update power levels
  
   
  //check how many tanks are in tankDefGroup
  nTanksDefGrp=0;
  if( gameTime - lastDisplayAI >= 90 and tankDefGroup.members > 0 ){
    initIterateGroup(tankDefGroup);
		droid = iterateGroup(tankDefGroup);
		while(droid != NULLOBJECT)
		{
      if(droid.droidType == DROID_WEAPON and droid.propulsion != cyborgPropulsion)
	    {
        nTanksDefGrp++;
      }
		  droid = iterateGroup(tankDefGroup);
    }  
  }

  if ( aPower[VERY_LOW_POWER] < 500 ){
    if ( aPower[VERY_LOW_POWER] < 400 and researchFinished(cobraBody, player) and researchFinished(mediumCannon,player)  ){
      aPower[VERY_LOW_POWER]  = 400; 
      aPower[LOW_POWER]       = 700; 
      aPower[HIGH_POWER]      = 1100;
    }
    if ( aPower[VERY_LOW_POWER] < 500  and researchFinished(trackPropulsion, player) ){
      aPower[VERY_LOW_POWER]  = 500; 
      aPower[LOW_POWER]       = 800; 
      aPower[HIGH_POWER]      = 1200;
    }
  }

  //reactivate all  (but the fact upgrades!!!)
  lStopTankProduction     = false;
  lStopBuildTankProd      = false;
  lStopCybEngProd         = false;	
  lStopCybProduction      = false;
  lStopFactUpgrade 	      = true;
  lStopFactUpgrade2	      = true;
  lStopResearch           = false;
  lStopBuildDef 	        = false; 
  lStopBuildDefDerricks   = false;
  lStopBuildDefGateway    = false;
  lStopBuildRepFacility   = false;
	lStopBuildingStructures = false;
	lStopResLabUpgrade      = false;
	lStopVTOLProduction     = false;
	lStopVTOLFactBuilding   = false;
	
  //base struct built?
  if (nFactories >= strToBuild[nAI_Pers][STR_TANK_FACTORY] and nResLabs >= strToBuild[nAI_Pers][STR_RESLAB]  and nCybFact >= strToBuild[nAI_Pers][STR_CYB_FACTORY] ){
    lMinBaseStructBuilt = true;     
  } else {
    lMinBaseStructBuilt = false;     
  }
  
  //switch working path
  if ( gameTime - tLastPowerSwitch > TIME_SWITCH_WORKSTRUCT ){
     tLastPowerSwitch = gameTime;
     nProdSelect++;
    if (nProdSelect == 8){ nProdSelect = 0; } 
  }

  //Any cheap researche left?
  if ( !lStopCheapResearch ){
    count  = 0;
    count2 = 0;
    while ( count < numCheapRes[0] ){
      if ( researchFinished(researchCheap[0][count], player) ){
        count2++;
      }
      count++;
    }
    if ( count2 == numCheapRes[0] ){ 
     //printDebug1("AIbrain: completed the research of basic techs (cheap researches)");
      lStopCheapResearch = true; 
      nResearchCounter = -9999; 
    }
  }

  
  if (  gameTime > 12*TIME_MINUTE and (nTotCyborgs+nTotTanks) < MIN_TOT_UNITS ){
    lForceUnitsProduciton = true;
    
    //check if need to ask for big help nBigHelpRequests,tBigHelpRequest
    if ( nBigHelpRequests < 3 and gameTime - tBigHelpRequest > 10*TIME_MINUTE ){
      if ( (nFactories+nCybFact+nResLabs) < ( strToBuild[nAI_Pers][STR_TANK_FACTORY]+strToBuild[nAI_Pers][STR_RESLAB]+strToBuild[nAI_Pers][STR_CYB_FACTORY]  ) or alertLevel == RED_ALERT ){
        nBigHelpRequests++;
        tBigHelpRequest = gameTime;
        sendMsgToAllAllies("needbighelp", false );
        //sendMsgToAllAllies("needbighelp", true );
       //printDebug1("AIBrain; asking for big help # ("& nBigHelpRequests &")");
      }
    }

  }

  //activate more tanks and cyb engineers if AA def are required
  if (nMapPower  <= LOW_POWER_MAP){
    if ( gameTime > TIME_HARVESTING_PHASE ){
      _nMaxTrucks        = MIN_BUILDING_TANKS - 2;
      _nMaxCybEngineers  = MIN_CYB_CONSTENG - 2;
    } else {
      _nMaxTrucks        = MIN_BUILDING_TANKS - 1;
      _nMaxCybEngineers  = MIN_CYB_CONSTENG - 1;
    }
  } else {
    if ( gameTime > TIME_HARVESTING_PHASE ){
      _nMaxTrucks        = MIN_BUILDING_TANKS - 1;
      _nMaxCybEngineers  = MIN_CYB_CONSTENG - 1;
    } else {
      _nMaxTrucks        = MIN_BUILDING_TANKS;
      _nMaxCybEngineers  = MIN_CYB_CONSTENG;
    }
  }

  //=========== VERY LOW POWER =============================  
  if ( nPower < aPower[VERY_LOW_POWER] and gameTime > 5*TIME_MINUTE ){
   
    if ( AIPersonality == AI_STANDARD ){manageVeryLowPower(); } 
    if ( AIPersonality == AI_VTOL )    {manageVeryLowPower2();}
    if ( AIPersonality == AI_TURTLE )  {manageVeryLowPower3();  } 
    if ( AIPersonality == AI_CYBORG )  {manageVeryLowPower4();  }
    
  } //================== POWER END ==============================
    
//  ===================  All events ==========================
  //have low numbers of troups 
  if ( lForceUnitsProduciton and gameTime > TIME_HARVESTING_PHASE )
  {	
  
    //force droids production
    if (AIPersonality == AI_CYBORG ){
      lStopCybProduction  = false;
      if ( nWorkingFact >= 1){lStopTankProduction  = true; }
    } else {
      lStopTankProduction = false;  
      lStopCybProduction  = false;
    }
    
    if (nPower < aPower[VERY_LOW_POWER]){
      //builddroids
      count = numTemplatesInProduction(cybcondroid, player);
      count = count + numTemplatesInProduction(constructor, player);
      count = count + numTemplatesInProduction(constructor2, player);
      if ( count + cybConstGrp.members + buildGrp.members + harvesterGroup.members + buildDefGrp.members >= 2 ) {
        //I am in trouble need tanks not trucks!!!
        lStopBuildTankProd = true;
        lStopCybEngProd    = true;
      }     
      if ( (nTotCyborgs+nTotTanks+nWorkingFact+nWorkingCybFac) < MIN_TOT_UNITS ){
        if ( nWorkingLab >= 1){lStopResearch = true; }
        lStopVTOLProduction      = true;
      } else {
        if ( nWorkingLab >= 2 ){lStopResearch = true; }
        if ( nWorkingVTOLFac >= 1){lStopVTOLProduction  = true; }
      }
      lStopBuildDef 	         = true;
      lStopBuildDefDerricks    = true;
      lStopBuildDefGateway     = true;
      //lStopBuildRepFacility    = true;
      lStopResLabUpgrade       = true;
      //lStopVTOLFactBuilding    = true;
    }
  } 

  if ( bFinalAttack_1vs1 and gameTime-tLastFinalAttack < 2*TIME_MINUTE )
  {
    lStopTankProduction     = false;
    lStopCybProduction      = false;
    if (nPower < aPower[VERY_LOW_POWER]){
      lStopBuildTankProd      = true;	
      lStopResearch           = true;
      lStopBuildDef 	        = true; 
      lStopBuildDefDerricks   = true;
      lStopBuildDefGateway    = true;
      //lStopBuildRepFacility   = true;
    	lStopResLabUpgrade      = true;
    	lStopVTOLProduction     = true;
    	//lStopVTOLFactBuilding   = true;
  	}
    nDamageLevelRepair = DAMAGE_REPAIR_LEVEL_LOW;  
  } else {
    nDamageLevelRepair = DAMAGE_REPAIR_LEVEL;
  }
  

//  ===================  Defences ==========================
  //give priority to AA
  if ( nPower < aPower[LOW_POWER] ){
    if ( numAAinBase < 6  and bAttackedByVTOL  ) { 
      lStopBuildDef 	       = true; 
      lStopBuildDefDerricks  = true;
      lStopBuildDefGateway   = true;
    }    
  }

  //complete base first
  if ( !lMinBaseStructBuilt )
  {
    lStopBuildDefGateway  = true;
    lStopBuildDef         = true;
  }

  //start building gateway def a bit later
  if ( gameTime < VALID_TIME_GATEWAYDEF)
  { lStopBuildDefGateway  = true;} 
 
  //-------- activate ---------
  if ( gameTime < TIME_HARVESTING_PHASE and gameTime > 1*TIME_MINUTE ){
     lStopBuildDefDerricks    = false;
  }

  if ( lMinBaseStructBuilt ){
    if ( AIPersonality == AI_TURTLE ){
      if ( gameTime - tLastbuildBaseDef > (TIME_TOFORCE_BUILDDEF_2) ) 
      { 
        lStopBuildDef         = false; 
        lStopBuildDefDerricks = false;
        if ( gameTime > TIME_HARVESTING_PHASE ){
          lStopBuildDefGateway  = false;
        } 
      }
    } else {
      if ( gameTime - tLastbuildBaseDef > TIME_TOFORCE_BUILDDEF and nMapPower > VERY_LOW_POWER_MAP ) 
      { 
        lStopBuildDef         = false; 
        lStopBuildDefDerricks = false; 
        if ( gameTime > TIME_HARVESTING_PHASE ){
          lStopBuildDefGateway  = false;
        } 
      }
    }
  }


//  ===================  Units Production ==========================
  // ---------- VTOL -----------------
  //do not build too many VTOLs
  if ( nPower < aPower[LOW_POWER] ){
    if ( AIPersonality != AI_VTOL  ){
      if ( vtolGr.members > 10 ){
        if ( (float)(vtolGr.members)*2.5 > (float)(nTotTanks + nTotCyborgs) ){
          lStopVTOLProduction = true;
        }
      }
    }
  }

// ---------- Trucks -----------------
  if ( buildGrp.members + harvesterGroup.members + buildDefGrp.members < _nMaxTrucks){
     lStopBuildTankProd = false;
  } else {
    lStopBuildTankProd = true;
  }  
  if ( cybConstGrp.members + numTemplatesInProduction(cybcondroid, player) < _nMaxCybEngineers){
    lStopCybEngProd = false; 
  } else {
    lStopCybEngProd = true;
  }

//  ===================  Research ==========================
  //At least one research every 4 min
  if( gameTime - tLastResearch > 4*TIME_MINUTE )
  { lStopResearch  = false; }
  //power superiority check in 1vs1 games
  bForceResPowUp = false;
  if ( nEnemyPlayers == 1 and gameTime > 15*TIME_MINUTE ){
    if ( getPowerIndex( nLastEnemyPlayer ) >= getPowerIndex( player )  ){ //human player has more or higher power index
      if ( nMyDerricks >= getNumDerricks(nLastEnemyPlayer) ){ //derricks are fine
        bForceResPowUp = true;//force research of power
        lStopResearch  = false;
      }
    }
  }
  
  //checking power in all type of games
  _player=0;
  while( _player < MAX_PLAYERS and gameTime > 15*TIME_MINUTE ){
    if (isPlayerStillLive(_player)){
      if ( getPowerIndex( _player ) > getPowerIndex( player ) ){ //human player has higher power index
        if ( nMyDerricks >= getNumDerricks(_player) ){ //derricks are fine
          bForceResPowUp  = true;//force research of power
          lStopResearch   = false;
        }
      }
    }
    _player++;
  }

  //never stops research at beginning of the game
  if ( gameTime < tStartBaseAttacks ){
    lStopResearch  = false;
  }

//  ===================  Upgrades ==========================
  if ( lMinBaseStructBuilt ) {
    lStopPowGenUpgrade = false;
    if ( researchFinished(cobraBody, player) or researchFinished(hoverPropulsion, player) or researchFinished(scorpionBody, player) )
    { lStopFactUpgrade    = false; }
    if ( bDyDoHasHeavyBody )
    { lStopFactUpgrade2    = false; }
    if ( nPower > aPower[VERY_LOW_POWER] ){
      lStopFactUpgrade  = false; 
      lStopFactUpgrade2 = false; 
    }
  }
  //Upgrades if game starts with T2 or T3
  if ( researchFinished(cobraBody, player) or researchFinished(hoverPropulsion, player) or researchFinished(scorpionBody, player) ){
    if ( nFactories >= 2 ){
      lStopFactUpgrade    = false; 
    }
  }
  //upgrade at least one factory even if not all base struct are built
  if ( bDyDoHasHeavyBody and nFactories >= 2 ){
    if ( nFact1Mod < 2 ){
      lStopFactUpgrade2    = false;
    }
  }
  if ( nFactories + nCybFact + nResLabs >= 5 ){
    lStopPowGenUpgrade = false;
  }
  //upgrade anyway after some time (low power maps...)
  if ( gameTime > 15*TIME_MINUTE ){
     lStopFactUpgrade  = false; 
  }
  if ( gameTime > 20*TIME_MINUTE ){
     lStopFactUpgrade2 = false; 
  }

// ---------- Res Labs -----------------
  //stop res labs upgrade
  //the check on the gameTime allows upgrades when humplay sets res labs limits
  if ( gameTime < TIME_HARVESTING_PHASE ){
    if ( !lMinBaseStructBuilt ){ lStopResLabUpgrade = true; }
  }
//  ===================  Structures ==========================
// ---------- Research Facilities -----------------
  if( nRepairFac >= MAX_REPAIRFAC )
  { lStopBuildRepFacility = true; }

  if( gameTime < 20*TIME_MINUTE and nRepairFac >= 2 )
  { lStopBuildRepFacility = true; }

  if( gameTime < 30*TIME_MINUTE and nRepairFac >= 3 )
  { lStopBuildRepFacility = true; }

  if ( gameTime - nLastTimeBuiltRepFac < 2*TIME_MINUTE )
  { lStopBuildRepFacility = true; }

  if ( !lMinBaseStructBuilt and gameTime < TIME_HARVESTING_PHASE ){
    lStopBuildRepFacility    = true;
  }

// ---------- VTOL Factories -----------------
  //stop VTOL building if fact upgrade is not completed
  if ( !bFactUpgraded2Modules and bDyDoHasHeavyBody or !bFactUpgraded1Module)
  { lStopVTOLFactBuilding = true; }
   
  

  tAIbrain = gameTime;
}
/*======================================================================
                              VTOL STUFF
========================================================================*/
event vtolEnabler(inactive)
{

  eventCheckTime[25] = gameTime;

  if( skVtolEnableCheck(player) )	// check to see if we have vtol technologies
	{
		setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol events
		setEventTrigger(buildVtols,	buildVtolsTr);
		setEventTrigger(manageAttVTOL,	manageAttVTOLTr);
    setEventTrigger(manageDefVTOL,manageDefVTOLTr);    
		setEventTrigger(vtolEnabler,inactive);		//turn off this event
	}
			
}
//----------------------------------------------
event vtolDefend(vtolDefendTr)//(CALL_STRUCT_ATTACKED, player, ref structure, ref enemyBaseObject)
{
	local	int		_numAAdefInRange,_dist,_x,_y;//_x , _y;
  local STRUCTURE _struct;
  local DROID _droid;
  
  _x = -1;
  _y = -1;
  
  if(enemyBaseObject != NULLOBJECT)
  {
  	if(enemyBaseObject.type == OBJ_DROID)
  	{
  		if( isVtol( objToDroid(enemyBaseObject) ) )
  		{
    
  		  //bAttackedByVTOL = true;//force research of AA defences
        if ( structure != NULLOBJECT ){
          _x = structure.x;
          _y = structure.y;
        } else {
          if ( enemyBaseObject != NULLOBJECT ){
            _x = enemyBaseObject.x;
            _y = enemyBaseObject.y;
          }
        }
        if ( _x < 0 or _y < 0 ){ exit; }
        _dist = distBetweenTwoPoints( _x, _y, baseX, baseY);   
  
  			dbg("VTOLdefend: Attacked in range dist<def ("& _dist/TILE &")<("& nDefendRange/TILE &")",player);
        if ( _dist > nDefendRange ){ exit; }
          
  	    _droid  = closestDroidCanBuild(buildDefGrp, _x, _y );
      	if ( nMapPower > VERY_LOW_POWER_MAP){
          if ( _droid == NULLOBJECT ){
        	 _droid = closestIdleDroid(buildGrp,buildX,buildY);
          }
        }
  
        // build AA defenses.
  			if ( _droid != NULLOBJECT ) {
					//if no AA at all in AAdefRange or enough power
			    _numAAdefInRange = numAAinRange(player, player, _x, _y, RANGE_BUILD_AADEF );
          if ( _numAAdefInRange < MAX_AADEF_INRANGE ){
						buildX = _x;
						buildY = _y;
						
						//find best defense we can build.
						count = 0;
						count2 = -1;
						while( count < numGenAA)
						{
							if(isStructureAvailable(vtolGenStruct[count],player)){
								count2 = count;
							}
							count = count + 1;
						}
					  if( count2 >= 0 ){
						  boolResult = pickStructLocation(vtolGenStruct[count2], ref buildX, ref buildY, player);
						  if( boolResult and droidCanReach(_droid, buildX ,buildY) )	// build a vtol defense near the attacked struct...
						  {
							 //printDebug1("vtolDefend; build AA def ["& count2 &"] at ("& buildX/TILE &"-"& buildY/TILE &"), tot AA in struct range ("& _numAAdefInRange &") _dist("& _dist/TILE &")");
                orderDroidStatsLoc(_droid, DORDER_BUILD,vtolGenStruct[count2],buildX,buildY);
                tLastAAbuilt = gameTime;
						  }
					  }  
          } 
  		  }  
  		}
  	}
  }
}

// ------------------ build VTOL structs -----------------------
event vtolStructs(inactive)
{
	local	int		_totalVTOLS;
	local	int		_numVtolFacs,_numRearmPads;

	if( !isStructureAvailable(vtolFactory,player) ){
	 exit;
  }

  // see how many vtol factories we already have
	_numVtolFacs  = nVTOLFactories;
	_numRearmPads = numStructsByType(vtolPad, player, false);
  _totalVTOLS   = vtolGr.members + vtolAttGr.members;
	
  //see if we have enough rearm pads
	if( (float)(_numRearmPads * (4 / 3)) <= (float)(_totalVTOLS) and _totalVTOLS > 0)
	{
		//displayMsg("vtolStructs: need rearming Pads");
		buildRearmPads();
	}

}

// ------------- build VTOL droids --------------------
event buildVtols(inactive)
{
	
  local int _totalVTOLS; 
  
  //displayMsg("buildVtols: buildVtols event called - 1 nProdSelect("& nProdSelect &") lStopVTOLProduction("& lStopVTOLProduction &") lMinBaseStructBuilt("& lMinBaseStructBuilt &")");

	if( lStopVTOLProduction ){
	 exit;
  }

  _totalVTOLS = vtolGr.members + vtolAttGr.members;
  // got enough vtols?
	if( getDroidCount(player) >= MAX_DROIDS ){
		//displayMsg("buildVtols: CAN'T BUILD VTOLS - TOO MANY DROIDS UNITS");
		exit;
	}
	if( (_totalVTOLS >= MAX_VTOLS and AIPersonality != AI_VTOL) or (_totalVTOLS >= MAX_VTOLS_PERS2 and AIPersonality == AI_VTOL) ){
		//displayMsg("buildVtols: CAN'T BUILD VTOLS - TOO MANY VTOLS tot:("& _totalVTOLS &") max VTOLs Gen1-3-4("& MAX_VTOLS &") Gen2("& MAX_VTOLS_PERS2 &")");
		exit;
	}
	

	// build vtols
	boolResult = true;
  initEnumStruct(false,vtolFactory,player,player);
	structure = enumStruct();
	while(structure != NULLOBJECT and boolResult)
	{
		if(structureIdle(structure))	// if factory idle
		{
			vtolFactoryBuildVtol(structure);
      boolResult = false;
		}
		structure = enumStruct();
	}
}

//======================================================
//make use of 
//if ( droid.action == DACTION_NONE)
//{}
event manageAttVTOL(inactive)
{
  local int _aa,_dist,_dist2,_i,_nIdle,_nAtt,_nRepRearm;
  local string _dbgString;
  local DROID _droid;

  if (vtolGr.members < MIN_VTOLS_ATTACK or alertIsOn or defTargetVTOL != NULLOBJECT or nHelpX > 0 ){ 
    resetVTOLAttack();
    exit; 
  }

  _nIdle     = numIdleVTOLs(vtolGr);
  _nRepRearm = numVTOLRepRearm(vtolGr);
  _nAtt     = numAttackVTOLs(vtolGr);


  if ( vtolGr.members - _nRepRearm < 9 and _nRepRearm > 0 ){
    exit;
  }
  
  if ( targetPlayerVTOL >= 0 and targetPlayerVTOL < 8 ){
    if ( friendlyPlayer(targetPlayerVTOL) or  targetPlayerVTOL == player ){
      resetVTOLAttack();
      exit;
    }
  }

  if ( attTargetVTOL != NULLOBJECT ){ 

    if ( !friendlyPlayer(attTargetVTOL.player) ){         
      //use the base as reference as the VTOLs are never all in the same place!!
      _aa = getAA_OnTheWay(baseX, baseY, attTargetVTOL.x, attTargetVTOL.y, AA_THREAT_RANGE);
      if ( vtolGr.members < _aa*4 ){
        resetVTOLAttack();
        exit;
      }

      if (attTargetVTOL.type == OBJ_DROID){ 
        _dist = distBetweenTwoPoints(attTargetVTOL.x, attTargetVTOL.y, baseX, baseY); 
        if ( _dist > nDefendRange ){
           attTargetVTOL    = NULLOBJECT;
           exit;
        }
      }

    } else {
      resetVTOLAttack();
      exit;
    }
  }

  
/*
  if ( gameTime - tVTOLAttackReset < 250 or _nRepRearm > 0 ){
    
    boolResult = false;

  	initIterateGroup(vtolGr);
  	_droid = iterateGroup(vtolGr);
  	while(_droid != NULLOBJECT and !boolResult)
  	{
      _dist = distBetweenTwoPoints( _droid.x, _droid.y, baseX, baseY);
      if ( _dist > nBaseRange ){
        boolResult = true;
      }
      _droid = iterateGroup(vtolGr);
    }  

    if ( boolResult ) { 
      _i = 0;
      while ( _i < 3){
        oTargetVTOLAtt[_i] = NULLOBJECT;
        _i++;
      }
      attTargetVTOL     = NULLOBJECT;
      dNearestEnemyCmd  = NULLOBJECT;
      orderGroup(vtolGr, DORDER_RTR);
      targetPlayerVTOL  = -1;
      exit; 
    }
  }
*/  

  if ( gameTime - tVtolAction > 1000 ){
      resetVTOLAttack();
      tVtolAction = gameTime;
      exit;
  }

  
  //reset target if too far away or if too many AA near the commander
  if ( attTargetVTOL != NULLOBJECT ){          

    _aa = getAA_OnTheWay(baseX, baseY, attTargetVTOL.x, attTargetVTOL.y, AA_THREAT_RANGE);
    if (  _aa*4 > vtolGr.members ){ resetVTOLAttack(); exit; }
    
    _dist = distBetweenTwoPoints( attTargetVTOL.x, attTargetVTOL.y, baseX, baseY);
    _dist2 = distBetweenTwoPoints(attTargetVTOL.x, attTargetVTOL.y,aPl[attTargetVTOL.player][X_COORD],aPl[attTargetVTOL.player][Y_COORD]);

    if ( attTargetVTOL.type == OBJ_DROID ){          
	    _droid = objToDroid(attTargetVTOL);
	    if  ( _droid.droidType != DROID_COMMAND ){
        if ( _dist > nDefendRange ){ resetVTOLAttack(); exit; }
      } else {
      //tagret is commander
        if ( vtolGr.members < MIN_VTOLS_ATTACK or _dist2 < nDefendRange)
        { resetVTOLAttack(); exit; }
        
      }
    } else {
      //target is structure if it is in nDefendRange ok to attack otherwise check the number
      // of VTOLs.
      if ( (_dist > nDefendRange and vtolGr.members < MIN_VTOLS_ATTACK) )
        { resetVTOLAttack(); exit; }
    }
  }
       
  //=========== Search target = Human Commanders =================
  if ( attTargetVTOL == NULLOBJECT ){
//dbg("manageAttVTOL: 4 ",player);
  if ( AIstrength > 3 and dNearestEnemyCmd != NULLOBJECT){ 
   //dbg("manageAttVTOL: checking for commander ("& dNearestEnemyCmd.id &") as VTOl target",player);
    _aa = getAA_OnTheWay(baseX, baseY, dNearestEnemyCmd.x, dNearestEnemyCmd.y, AA_THREAT_RANGE);
    if ( _aa < vtolGr.members*4 and vtolGr.members >= MIN_VTOLS_ATTACK)
    {
      _dist = distBetweenTwoPoints(dNearestEnemyCmd.x, dNearestEnemyCmd.y,aPl[dNearestEnemyCmd.player][X_COORD],aPl[dNearestEnemyCmd.player][Y_COORD]); 
      if ( _dist > nDefendRange )
      {
        attTargetVTOL         = dNearestEnemyCmd;
        targetPlayerVTOL      = attTargetVTOL.player;
        bVTOLTargetIsDerrick  = false; 
      }
    } 
  }
  }
  
  //=========== Search a target in  DefendRange =================
  if ( attTargetVTOL == NULLOBJECT ){
//dbg("manageAttVTOL: 5 ",player);
  if ( vtolGr.members >= MIN_VTOLS_ATTACK ){
    attTargetVTOL = objStrTargetInRange(baseX,baseY,nDefendRange);
    if ( attTargetVTOL != NULLOBJECT ){ 
      targetPlayerVTOL      = attTargetVTOL.player;
      bVTOLTargetIsDerrick  = false; 
    } else {
      attTargetVTOL = objDroidTargetInRange(baseX,baseY,nDefendRange,true);
      if ( attTargetVTOL != NULLOBJECT ){ 
        targetPlayerVTOL      = attTargetVTOL.player;
        bVTOLTargetIsDerrick  = false; 
      }
    }
  }
  }
  
 
  //================== Search target = Enemy Derricks =========================
  if ( attTargetVTOL == NULLOBJECT ){
//dbg("manageAttVTOL: 6 ",player);
  if ( vtolGr.members >= MIN_VTOLS_ATTACK ){
    _aa = vtolGr.members/4;
    attTargetVTOL = objHumanDerrick(true, _aa , 0);  //bool bVTOLTarget, int _numDef, int _distInTiles
    if ( attTargetVTOL != NULLOBJECT ){ 
      targetPlayerVTOL      = attTargetVTOL.player;
      bVTOLTargetIsDerrick  = true; 
    }
    if ( attTargetVTOL == NULLOBJECT ){
      attTargetVTOL = undefendedEnemyDerrick(true);//check also for aa with the rule _aa*4 < vtolGr.members
      if ( attTargetVTOL != NULLOBJECT ){ 
        targetPlayerVTOL      = attTargetVTOL.player;
        bVTOLTargetIsDerrick  = true; 
      }
    }
  }
  }

  //================== Search target = AA structs =========================
  if ( attTargetVTOL == NULLOBJECT ){
//dbg("manageAttVTOL: 7 ",player);
  if ( vtolGr.members >= MIN_VTOLS_ATTACK ){
    attTargetVTOL = getAAStruct(true);
    if ( attTargetVTOL != NULLOBJECT ){ 
      targetPlayerVTOL      = attTargetVTOL.player;
      bVTOLTargetIsDerrick  = true; 
    }
  }
  }

     
  //================== attack Target =====================
  if (idleGroup(vtolGr) > 0 ){
    if ( attTargetVTOL != NULLOBJECT )
    {
      vtolAttack( attTargetVTOL );
      tVtolAction = gameTime;
    }
  } 

  //==================  Nearest Enemy Bases (AA_THREAT_RANGE_LONG) =========================
  if ( attTargetVTOL == NULLOBJECT ){  
//dbg("manageAttVTOL: 8 ",player);
  if ( vtolGr.members >= MIN_VTOLS_ATTACK_BASE ){
    
      _i = 0;
      while ( attTargetVTOL == NULLOBJECT and _i < 5)
      {
        if ( targetPlayerVTOL < 0){
          if ( AIstrength > 3 and _i < 2 ){
            if ( mapSize() > MAP_SMALL ) {
              targetPlayerVTOL = getNearestEnemyPlayer(true);
            } else {
              targetPlayerVTOL = getRandomEnemyPlayer(true);
            }
          } else {
            if ( mapSize() > MAP_SMALL ) {
              targetPlayerVTOL = getNearestEnemyPlayer(true);
            } else {
              targetPlayerVTOL = getRandomEnemyPlayer(true);
            }
            if ( targetPlayerVTOL < 0){
              if ( mapSize() > MAP_SMALL ) {
                targetPlayerVTOL = getNearestEnemyPlayer(false);
              } else {
                targetPlayerVTOL = getRandomEnemyPlayer(false);
              }
            }
          }
        }
        if ( targetPlayerVTOL > 0){
          if ( friendlyPlayer(targetPlayerVTOL) ){ 
            printDebug1("#### manageAttVTOL: targetPlayerVTOL was friendly player pl#("& targetPlayerVTOL &")");   
          }
          attTargetVTOL = getVTOLstructTarget();//uses targetPlayerVTOL & AA_THREAT_RANGE_LONG, return a buuilding as target (not a def struct!)
        	//All VTOLs to attack this struct!!!
          if ( attTargetVTOL != NULLOBJECT and idleGroup(vtolGr) > 0 ){
            orderGroupObj(vtolGr, DORDER_ATTACK, attTargetVTOL);
            tVtolAction = gameTime;
            exit;	
          }
        }
        if ( attTargetVTOL == NULLOBJECT ){ targetPlayerVTOL = -1; } 
        _i++;
      }
    
  }
  }

}

//===================================================================
event buildBase(inactive) //event 8
{
  local int _f,_r,_c,_v,_h,_l,_p,_satUpCen,_pCompleted,_fCompleted,_rCompleted,_cCompleted;
  local bool _bProceed;
  local STRUCTURESTAT SatUplinkCenter;
  
  SatUplinkCenter = baseStructs[7];
  eventCheckTime[2] = gameTime;
  
  
  _f = nFactories;
	_r = nResLabs;
	_c = nCybFact;
	_v = nVTOLFactories;
	_h = numStructsByType(playerHQ, player, false);
	_l = numStructsByType(lassat, player, false);
	_p = numStructsByType(powGen, player, false);
	_satUpCen = numStructsByType(SatUplinkCenter, player, false);
	_fCompleted = numStructsByType(factory, player, true);
	_rCompleted = numStructsByType(resLab, player, true);
	_cCompleted = numStructsByType(cybFactory, player, true);
	_pCompleted = numStructsByType(powGen, player, true);

  //dbg("buildBase; stop("& lStopBuildingStructures &")("& lStopVTOLFactBuilding &") vtolfact("& nVTOLFactories &") to build("& strToBuild[nAI_Pers][STR_VTOL_FACTORY] &") av("& isStructureAvailable(vtolFactory,player) &")",player);

  //help build power generators
  _bProceed = true;
  if ( _pCompleted != _p ){
    initEnumStruct(false,powGen,player,player);
    structure = enumStruct();
    while(structure != NULLOBJECT )
    {
      if ( !structureComplete(structure) ){          
        droid = closestDroidCanBuild(buildGrp,structure.x,structure.y);
  			if( droid != NULLOBJECT )
  			{
          if (droidCanReach(droid, structure.x, structure.y) ){
            orderDroidObj(droid,DORDER_HELPBUILD,structure);
            exit;
          }
        }
      }
      structure = enumStruct();
    }      
  }
  if ( _fCompleted != _f ){
    initEnumStruct(false,factory,player,player);
    structure = enumStruct();
    while(structure != NULLOBJECT )
    {
      if ( !structureComplete(structure) ){          
        droid = closestDroidCanBuild(buildGrp,structure.x,structure.y);
  			if( droid != NULLOBJECT )
  			{
          if (droidCanReach(droid, structure.x, structure.y) ){
            orderDroidObj(droid,DORDER_HELPBUILD,structure);
            exit;
          }
        }
    }
      structure = enumStruct();
    }      
  }
  if ( _cCompleted != _c ){
    initEnumStruct(false,cybFactory,player,player);
    structure = enumStruct();
    while(structure != NULLOBJECT )
    {
      if ( !structureComplete(structure) ){
        droid = closestDroidCanBuild(buildGrp,structure.x,structure.y);
  			if( droid != NULLOBJECT )
  			{
          if (droidCanReach(droid, structure.x, structure.y) ){
            orderDroidObj(droid,DORDER_HELPBUILD,structure);
            exit;
          }
        }
      }
      structure = enumStruct();
    }      
  }
  if ( _rCompleted != _r ){
    initEnumStruct(false,resLab,player,player);
    structure = enumStruct();
    while(structure != NULLOBJECT )
    {
      if ( !structureComplete(structure) ){
        droid = closestDroidCanBuild(buildGrp,structure.x,structure.y);
  			if( droid != NULLOBJECT )
  			{
          if (droidCanReach(droid, structure.x, structure.y) ){
            orderDroidObj(droid,DORDER_HELPBUILD,structure);
            exit;
          }
        }
      }
      structure = enumStruct();
    }      
  }

  //if game starts with no power generators and no derricks and for any reason DyDo never starts harvesting 
  // the below code will ensure DyDo will build a power generator anyway
  if( (_p == 0 and playerPower(player) < 1000) or ( (nMyDerricks-_p*4) > 0 and _f+_c>=2 ) )                                                     
	{
		buildX = baseX;  
		buildY = baseY;
		boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
		if(boolResult)
		{
      droid = closestDroidCanBuild(buildGrp,baseX,baseY);
			if( droid != NULLOBJECT ){
				if ( droidCanReach(droid, buildX, buildY) )
				{
          orderDroidStatsLoc(droid, DORDER_BUILD,powGen, buildX,buildY);
  				tLastPowerGen = gameTime;
  				exit;
				}
			}
		}
	}

  droid = closestDroidCanBuild(buildGrp,baseX,baseY);
  if ( droid == NULLOBJECT ){ exit; }

  //dbg("buildBase: 0 ("& nStructToBeBuilt &")("& lStopBuildingStructures &") fac/cyb/res("& _f &")("& _c &")("& _r &") / ("& _fCompleted &")("& _cCompleted &")("& _rCompleted &") pow("& nMyDerricks-_p*4 &")>0?",player );

  //avoid to run out of money
  if ( _pCompleted == 0 and playerPower(player) < 800 ){ exit; }
 
  if ( (_f >= 1 and _r >= 1 and _c >= 1) or ( (_f+_c) >= 2 and _r >= 1) or lMinBaseStructBuilt )
  {
	
    //check PlayerHQ first
    if(_h == 0 and isStructureAvailable(playerHQ , player) )
    {
    	buildX = baseX;
    	buildY = baseY;
    	boolResult = pickStructLocation(playerHQ, ref buildX, ref buildY, player);
    	if(boolResult){
        if (droidCanReach(droid, buildX ,buildY)){
    		  orderDroidStatsLoc(droid, DORDER_BUILD, playerHQ, buildX, buildY );
          exit;
    		}
    	}
    }
    
    //check lassat 
    if(_l == 0 and isStructureAvailable(lassat , player) and boolResult)
    {
    	buildX = baseX;
    	buildY = baseY;
    	boolResult = pickStructLocation(lassat, ref buildX, ref buildY, player);
    	if(boolResult)
    	{
        if (droidCanReach(droid, buildX ,buildY)){
    			orderDroidStatsLoc(droid, DORDER_BUILD, lassat, buildX, buildY );
          exit;
    		}
    	}
    }

  }

  //Satellite uplink center  -_satUpCen
  if(_satUpCen == 0 and isStructureAvailable(SatUplinkCenter , player) )
	{
		buildX = baseX;
		buildY = baseY;
		boolResult = pickStructLocation(SatUplinkCenter, ref buildX, ref buildY, player);
		if(boolResult)
		{
      if (droidCanReach(droid, buildX ,buildY)){
				orderDroidStatsLoc(droid, DORDER_BUILD, SatUplinkCenter, buildX, buildY );
        exit;
			}		
		}
	}
  
  //check factory as second
  if(_f == 0 and isStructureAvailable(factory , player) )
	{
		buildX = baseX;
		buildY = baseY;
		boolResult = pickStructLocation(factory, ref buildX, ref buildY, player);
		if(boolResult)
		{
      if (droidCanReach(droid, buildX ,buildY)){
				orderDroidStatsLoc(droid, DORDER_BUILD, factory, buildX, buildY );
        exit;
			}		
		}
	}

  //check cybfactory 
  if(_c == 0 and isStructureAvailable(cybFactory , player))
	{
		buildX = baseX;
		buildY = baseY;
		boolResult = pickStructLocation(cybFactory, ref buildX, ref buildY, player);
		if(boolResult)
		{
      if (droidCanReach(droid, buildX ,buildY)){
       //dbg("build struct first cybFact",player);
				orderDroidStatsLoc(droid, DORDER_BUILD, cybFactory, buildX, buildY );
        exit;
			}
		}
	} 

  //check resLab
  if(_r == 0 and isStructureAvailable(resLab , player))
	{
		buildX = baseX;
		buildY = baseY;
		boolResult = pickStructLocation(resLab, ref buildX, ref buildY, player);
		if(boolResult)
		{
      if (droidCanReach(droid, buildX ,buildY)){
       //dbg("build struct first res lab",player);
				orderDroidStatsLoc(droid, DORDER_BUILD, resLab, buildX, buildY );
        exit;
			}
		}
	}


  if ( lStopBuildingStructures and lStopVTOLFactBuilding ){  exit;  }

  if ( _f >= strToBuild[nAI_Pers][STR_TANK_FACTORY] ){
  if ( _r >= strToBuild[nAI_Pers][STR_RESLAB] ){
  if ( _c >= strToBuild[nAI_Pers][STR_CYB_FACTORY] ){
  if ( _v >= strToBuild[nAI_Pers][STR_VTOL_FACTORY] ){
    exit;//all main structs have been built!!
  }
  }
  }
  }
  
  //dbg("buildBase; 2 nStructToBeBuilt("& nStructToBeBuilt &") _f("& _f &") _c("& _c &") _r("& _r &") _v("& _v &")",player);
  if ( nStructToBeBuilt >= 4){ nStructToBeBuilt = STR_TANK_FACTORY; }
  
  if ( nStructToBeBuilt == STR_TANK_FACTORY and _f >= strToBuild[nAI_Pers][STR_TANK_FACTORY] ){
    nStructToBeBuilt++;
  }
  
  if ( nStructToBeBuilt == STR_RESLAB and _r >= strToBuild[nAI_Pers][STR_RESLAB] ){
    nStructToBeBuilt++;
  }
  
  if ( nStructToBeBuilt == STR_CYB_FACTORY and (_c >= strToBuild[nAI_Pers][STR_CYB_FACTORY] or !isStructureAvailable(cybFactory , player)) ){
    nStructToBeBuilt++;
  }
  
  if ( nStructToBeBuilt == STR_VTOL_FACTORY and _v >= strToBuild[nAI_Pers][STR_VTOL_FACTORY] and isStructureAvailable(vtolFactory,player) ){
    nStructToBeBuilt++;
  }
  
  //dbg("buildBase: 2 ("& nStructToBeBuilt &") fac/cyb/res("& _f &")("& _c &")("& _r &") / ("& _fCompleted &")("& _cCompleted &")("& _rCompleted &")",player );
  //all base structs have been built!
  if ( nStructToBeBuilt == 4 or (nStructToBeBuilt == STR_VTOL_FACTORY and !isStructureAvailable(vtolFactory,player)) ){ 
    nStructToBeBuilt = STR_TANK_FACTORY; 
    exit; 
  }
  if ( nStructToBeBuilt == STR_VTOL_FACTORY and lStopVTOLFactBuilding ){ 
    nStructToBeBuilt = STR_TANK_FACTORY; 
    exit; 
  }
  
  //build VTOL only if few main buildings have already been built
  if (  _v >= 1 and !lMinBaseStructBuilt ){ 
    nStructToBeBuilt = STR_TANK_FACTORY; 
    exit; 
  }


  if( isStructureAvailable(structs[nStructToBeBuilt],player) )
  {
  	buildX = baseX;                      // pick a location
  	buildY = baseY;
  	if( pickStructLocation(structs[nStructToBeBuilt], ref buildX, ref buildY,player) )
  	{
  		droid = closestDroidCanBuild(buildGrp,buildX,buildY);
      if( droid == NULLOBJECT and buildGrp.members < 2 ){ 
        droid = closestIdleDroid(cybConstGrp, buildX, buildY); 
      }
  		if( droid != NULLOBJECT){
        if (droidCanReach(droid, buildX ,buildY)){
          orderDroidStatsLoc(droid, DORDER_BUILD,structs[nStructToBeBuilt],buildX,buildY);
          nStructToBeBuilt++;
        } else {
        
          //try another location
        	count = random(4);
          if ( count == 0 ){ 
            buildX = baseX+random(5)*TILE;
            buildY = baseY+random(5)*TILE;
        	}
          if ( count == 1 ){ 
            buildX = baseX-random(5)*TILE;
            buildY = baseY-random(5)*TILE;
        	}
          if ( count == 2 ){ 
            buildX = baseX-random(5)*TILE;
            buildY = baseY+random(5)*TILE;
        	}
          if ( count == 3 ){ 
            buildX = baseX+random(5)*TILE;
            buildY = baseY-random(5)*TILE;
        	}
        	if ( buildX < 2*TILE ){ buildX = 2*TILE; }
        	if ( buildY < 2*TILE ){ buildY = 2*TILE; }
        	if ( buildX > mapWidth*TILE ){ buildX = baseX; }
        	if ( buildY > mapHeight*TILE){ buildY = baseY; }
        	
  
          if( pickStructLocation(structs[nStructToBeBuilt], ref buildX, ref buildY,player) )
        	{
        		if( droid != NULLOBJECT){
              if (droidCanReach(droid, buildX ,buildY)){
                orderDroidStatsLoc(droid, DORDER_BUILD,structs[nStructToBeBuilt],buildX,buildY);
                nStructToBeBuilt++;
              }
            }
          } 
        }
  		}
  	}
  }	

}
//-----------------------------------------
event sendBackDamagedUnits(inactive)
{

	//Check for untis to be repaired
  eventCheckTime[3] = gameTime;
  if(getStructure(repairFacility, player) != NULLOBJECT and toBeRepairedTankGroup.members>0)
	{			
    
    initIterateGroup(toBeRepairedTankGroup);
		droid = iterateGroup(toBeRepairedTankGroup);
		while(droid != NULLOBJECT)
		{
       if ( droid.order != DORDER_RTR ){
        orderDroid(droid,DORDER_RTR);
			 }
      droid = iterateGroup(toBeRepairedTankGroup);			
    }
	
    initIterateGroup(toBeRepairedCyborgGroup);
		droid = iterateGroup(toBeRepairedCyborgGroup);
		while(droid != NULLOBJECT)
		{
       if ( droid.order != DORDER_RTR ){
        orderDroid(droid,DORDER_RTR);
			 }
      droid = iterateGroup(toBeRepairedCyborgGroup);			
    }

  } else {
	  
    //send in the base to be repaired by repair tank!!
    initIterateGroup(toBeRepairedTankGroup);
		droid = iterateGroup(toBeRepairedTankGroup);
		while(droid != NULLOBJECT)
		{
      
      if ( droid.order != DORDER_RTB and droid.order != DORDER_RTR )
			{
        if( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) > nBaseRange )
        {
			    //displayMsg("*** sendBackDamagedUnits: Order droid ("& droid.id &") MOVE to baseX and baseY with health ("& droid.health &") in group toBeRepairedTankGroup ("& toBeRepairedTankGroup.members &")");
          orderDroid(droid, DORDER_RTB);
        }
      }
      
			droid = iterateGroup(toBeRepairedTankGroup);			
    }
  
    initIterateGroup(toBeRepairedCyborgGroup);
		droid = iterateGroup(toBeRepairedCyborgGroup);
		while(droid != NULLOBJECT)
		{
      
      if ( droid.order != DORDER_RTB and droid.order != DORDER_RTR )
			{
        if( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) > nBaseRange )
        {
          orderDroid(droid, DORDER_RTB);
        }
      }
      
			droid = iterateGroup(toBeRepairedCyborgGroup);			
    }

  }
}
//=============================================0
event unitRepairSwitch(inactive)
{

  local DROID _droid;

  eventCheckTime[4] = gameTime;
  
	//Check for untis to be repaired
  if(getStructure(repairFacility, player) != NULLOBJECT or repairGroup.members > 0)
	{

		//Building teams -------------------------------
		initIterateGroup(buildGrp);
		_droid = iterateGroup(buildGrp);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair )
			{
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(buildGrp);
		}

		initIterateGroup(cybConstGrp);
		_droid = iterateGroup(cybConstGrp);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair )
			{
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(cybConstGrp);
		}

		initIterateGroup(buildDefGrp);
		_droid = iterateGroup(buildDefGrp);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair )
			{
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(buildDefGrp);
		}

		//defense tanks -----------------------------------------
		initIterateGroup(tankDefGroup);
		_droid = iterateGroup(tankDefGroup);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair )
			{
        groupAddDroid(toBeRepairedTankGroup, _droid);
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(tankDefGroup);
		}
		
		//attack tanks
		initIterateGroup(tankGroup);
		_droid = iterateGroup(tankGroup);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair and _droid.propulsion != TrackedProp )
			{
        groupAddDroid(toBeRepairedTankGroup, _droid);
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(tankGroup);
		}
		
		//help group
    initIterateGroup(helpGroup);
		_droid = iterateGroup(helpGroup);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair and _droid.propulsion != TrackedProp )
			{
        groupAddDroid(toBeRepairedTankGroup, _droid);
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(helpGroup);
		}

    //cyborgs - defend
		initIterateGroup(cyborgDefGroup);
		_droid = iterateGroup(cyborgDefGroup);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair )
			{
        groupAddDroid(toBeRepairedCyborgGroup, _droid);
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(cyborgDefGroup);
		}
  
    //cyborgs - attack
		initIterateGroup(cyborgAttGroup);
		_droid = iterateGroup(cyborgAttGroup);
		while(_droid != NULLOBJECT)
		{
			if( _droid.health < nDamageLevelRepair)
			{
        groupAddDroid(toBeRepairedCyborgGroup, _droid);
        orderDroid(_droid,DORDER_RTR);
			}
			_droid = iterateGroup(cyborgAttGroup);
		}

  //NO REPAIR FAC, NO REPAIR TRUCK switch back to tankDefGroup
  } else {
    if ( toBeRepairedTankGroup.members > 0 ){
       groupAddGroup(tankDefGroup,toBeRepairedTankGroup);
    }
    if ( toBeRepairedCyborgGroup.members > 0 ){
       groupAddGroup(cyborgDefGroup,toBeRepairedCyborgGroup);
    }
  } 
	                  
	
	//check if units have been repaired and assign back to tank group
	initIterateGroup(toBeRepairedTankGroup);
	_droid = iterateGroup(toBeRepairedTankGroup);
	while(_droid != NULLOBJECT)
	{
		if( _droid.health > MIN_HEALT_SWITCH_TO_TANK )
    { 
      if (_droid.droidType == DROID_REPAIR) 
			{
        groupAddDroid(repairGroup,_droid);
			}
      if (_droid.droidType == DROID_WEAPON)
			{
        groupAddDroid(tankDefGroup,_droid);
			}
      //mixed group checks!!!
      if (_droid.droidType == DROID_CYBORG and _droid.droidType != DROID_CYBORG_CONSTRUCT)
			{
        nTotCyborgBuilt++;
			  if ( AIPersonality == AI_CYBORG){
				  groupAddDroid(cyborgDefGroup, _droid);
        } else {
          if (nTotCyborgBuilt > 2){
    				groupAddDroid(tankDefGroup, _droid);
    				nTotCyborgBuilt = 0;
          } else {
				    groupAddDroid(cyborgDefGroup, _droid);
          }
        }
      }

		} else {
		  orderDroid(_droid,DORDER_RTR);
    }
	  _droid = iterateGroup(toBeRepairedTankGroup);
	}

	//check if units have been repaired and assign back to tank group
	initIterateGroup(toBeRepairedCyborgGroup);
	_droid = iterateGroup(toBeRepairedCyborgGroup);
	while(_droid != NULLOBJECT)
	{
		if( _droid.health > MIN_HEALT_SWITCH_TO_CYBORG )
    { 
      groupAddDroid(cyborgDefGroup,_droid);
		} else {
		  orderDroid(_droid,DORDER_RTR);
    }
	  _droid = iterateGroup(toBeRepairedCyborgGroup);
  }

}
//--------------------------------------------------------------
//wait for at least 3 droids
//search for human derrick target
//move droids to attack team(s)
//deactivate itself
event earlyAttack( inactive ) 
{
 
  if ( gameTime > 9*TIME_MINUTE ){ 
    bEarlyAttack = false;
    setEventTrigger(earlyAttack,inactive);
    exit; 
  }
  /*
  if ( nPlayersInGame > 4 ){ 
    bEarlyAttack = false;
    setEventTrigger(earlyAttack,inactive);
    exit; 
  }
  */
  if ( cyborgDefGroup.members < nDroidsEarlyAtt ){ 
    exit; 
  }
  
  if ( AIstrength > 3 ){
    attackCybObj = objHumanDerrick(false,1,nDefendRange*2);//(bool bVTOLTarget, int _numDef, int _distInTiles);
  } else {
    attackCybObj = closestEnemyDerrick( false, -1 );
  }
  //backup
  if ( attackCybObj == NULLOBJECT ){
    attackCybObj = closestEnemyDerrick( false, -1 );
  }
  
  if ( attackCybObj == NULLOBJECT ){
    exit; 
  }
  
  if ( numEnemyWeapStructsInRange(player, attackCybObj.x, attackCybObj.y, COMBAT_RANGE , false) > 2 ){
    exit; 
  }
  
  moveUnitsBetweenGRPs(cyborgAttGroup, cyborgDefGroup, nDroidsEarlyAtt, true);
  bAttackingHumanDerrick = true;//do not stop to attack if droids attacking are few units

 //printDebug1("earlyAttack; attacking player("& getPlayerName(attackCybObj.player) &") human("& isHumanPlayer(attackCybObj.player) &") derrick("& attackCybObj.x/TILE &"-"& attackCybObj.y/TILE &") with cyb("& cyborgAttGroup.members &")");

  setEventTrigger(CyborgAttack,CyborgAttackTr);
  setEventTrigger(earlyAttack,inactive);
  
}
//--------------------------------------------------------------
event activateAttack( inactive ) 
{
	local int _nTankUnitsToBeMoved,_nTotTankUnits,_nTankRequiredToAttack;
	local int _nCybUnitsToBeMoved,_nTotCybUnits,_nCybUnitsRequiredToAttack;
	local bool _bUseCybUnitsToo,_bUseTkUnitsToo;

  local int _nMyUnitsTot, _nMyUnitsPower, _nMyUnitsHP;
  local int _nEnUnitsTot, _nEnUnitsPower, _nEnUnitsHP;
  local int _cybRequired,_tankRequired,_player;
  local float _nMyPowerIndex,_nEnPowerIndex; 

  eventCheckTime[22] = gameTime;
  
  //get all players stats
  updatePlayersStats();

  if ( tankDefGroup.members < minDefDroids[nAI_Pers][MINDEF_TANKS] and cyborgDefGroup.members < minDefDroids[nAI_Pers][MINDEF_CYBORGS]){
    exit;
  }
  if ( alertIsOn ){ exit; }
  
 
  // ----------------------------------------------------------------------
  //Check for Final Attack in 1vs1 game or if just one enemy player exists
  _nMyUnitsTot    = helpGroup.members + tankGroup.members + tankDefGroup.members + cyborgDefGroup.members + cyborgAttGroup.members;

  if ( gameTime < 5*TIME_MINUTE ){
    exit;
  }

  _nMyUnitsPower  = getWeaponUnitsInfo( player, WUI_POWER);
  _nMyUnitsHP     = getWeaponUnitsInfo( player, WUI_HP);
  _nMyPowerIndex  = getPowerIndex( player );
  
  _nEnUnitsTot    = getWeaponUnitsInfo( nLastEnemyPlayer, WUI_TOTUNITS);
  _nEnUnitsPower  = getWeaponUnitsInfo( nLastEnemyPlayer, WUI_POWER);
  _nEnUnitsHP     = getWeaponUnitsInfo( nLastEnemyPlayer, WUI_HP);
  _nEnPowerIndex  = getPowerIndex( nLastEnemyPlayer );

  _nTotTankUnits          = tankDefGroup.members;
  _nTankRequiredToAttack  = minDefDroids[nAI_Pers][MINDEF_TANKS]+MIN_ATTACKING_TANKS+nAttackingUnitsToAdd;
  _nTankUnitsToBeMoved    = _nTotTankUnits - minDefDroids[nAI_Pers][MINDEF_TANKS];//MIN_DEFENDING_TANKS;

  _nTotCybUnits              = cyborgDefGroup.members;
  _nCybUnitsRequiredToAttack = minDefDroids[nAI_Pers][MINDEF_CYBORGS]+MIN_ATT_CYBORGS+nCybAttUnitsToAdd;
  _nCybUnitsToBeMoved        = _nTotCybUnits - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
  

  if ( cyborgDefGroup.members > minDefDroids[nAI_Pers][MINDEF_CYBORGS] ){
    _nCybUnitsToBeMoved = cyborgDefGroup.members - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
  } else {
    _nCybUnitsToBeMoved = 0;
  }
  _bUseCybUnitsToo = false;
  
  //use both cyborg and tank droids to attack?? -1
  if ( nMapPower <= LOW_POWER_MAP ){
    _bUseCybUnitsToo  = true;
    _bUseTkUnitsToo  = true;
  }
  if ( gameTime > (10*TIME_MINUTE + tTotalAttack) or ( (gameTime - tLastTankAttack > tTimeForceAttack) and (gameTime - tLastCyborgAttack > tTimeForceAttack) ) ){
    _bUseCybUnitsToo  = true;
    _bUseTkUnitsToo  = true;
    //_nTankRequiredToAttack = _nTankRequiredToAttack + 5;//otherwise will always attack with 7!!
  }
  if ( AIPersonality == AI_TURTLE ){
    _bUseCybUnitsToo  = true;
    _bUseTkUnitsToo  = true;
    //_nTankRequiredToAttack = _nTankRequiredToAttack + 5;//otherwise will always attack with 7!!
  }

  //calculate tot units required
  if ( _bUseCybUnitsToo ){
    _nTotTankUnits  = _nTotTankUnits + _nCybUnitsToBeMoved;
  }
  if ( _bUseTkUnitsToo ){
    _nTotCybUnits  = _nTotCybUnits + _nTankUnitsToBeMoved;
  }

  // ============ FINAL ATTACK ==================
  
  //if final attack check if need to send more troops
  if ( bFinalAttack_1vs1 and gameTime - tLastFinalAttack > 3000 ){
      if ( _nMyUnitsTot > _nEnUnitsTot*4 ){
        if (helpGroup.members>0)      {groupAddGroup(tankGroup, helpGroup);}
        if (tankDefGroup.members>0)   {groupAddGroup(tankGroup, tankDefGroup);}
        if (cyborgDefGroup.members>0) {groupAddGroup(tankGroup, cyborgDefGroup);}
        if (cyborgAttGroup.members>0) {groupAddGroup(tankGroup, cyborgAttGroup);}
      }
  }
  if ( (bTankAttIsOn or bCybAttIsOn) and nEnemyPlayers == 1 and gameTime - tLastTankAttack > 3000 ){
      if ( _nMyUnitsTot > _nEnUnitsTot*4 ){
        if (helpGroup.members>0)      {groupAddGroup(tankGroup, helpGroup);}
        if (tankDefGroup.members>0)   {groupAddGroup(tankGroup, tankDefGroup);}
        if (cyborgDefGroup.members>0) {groupAddGroup(tankGroup, cyborgDefGroup);}
        if (cyborgAttGroup.members>0) {groupAddGroup(tankGroup, cyborgAttGroup);}
      }
  }
  //printDebug1("Activate attack; myTot("& _nMyUnitsTot &") req("& _nTankRequiredToAttack &") my Pow-HP-PowIndx("& _nMyUnitsPower &")("& _nMyUnitsHP &")("& _nMyPowerIndex &") enemy Pow-HP-PowIndx("& _nEnUnitsTot &")("& _nEnUnitsPower &")("& _nEnUnitsHP &")("& _nEnPowerIndex &") ");
  if ( !bTankAttIsOn and !bCybAttIsOn and nEnemyPlayers == 1 and (gameTime - tLastFinalAttack) > 10*TIME_MINUTE and gameTime > 20*TIME_MINUTE)
  {
  
    bFinalAttack_1vs1 = false;
    //droid superiority
    if ( _nMyUnitsTot > 15 ){
      if ( _nMyUnitsTot   > _nEnUnitsTot*3 ){ bFinalAttack_1vs1 = true;  }
      if ( _nMyUnitsPower > _nEnUnitsPower*3 ){ bFinalAttack_1vs1 = true; }
      if ( _nMyUnitsHP    > _nEnUnitsHP*3 ){ bFinalAttack_1vs1 = true; }
    }
    //enemy with lower power
    if ( _nMyPowerIndex > _nEnPowerIndex*2.0 ){
      if ( _nMyUnitsTot > 15 ){
        if ( _nMyUnitsTot   > _nEnUnitsTot*2 ){ bFinalAttack_1vs1 = true;  }
        if ( _nMyUnitsPower > _nEnUnitsPower*2 ){ bFinalAttack_1vs1 = true; }
        if ( _nMyUnitsHP    > _nEnUnitsHP*2 ){ bFinalAttack_1vs1 = true; }
      }
    }
  
    if (bFinalAttack_1vs1){
      if (helpGroup.members>0)      {groupAddGroup(tankGroup, helpGroup);}
      if (tankDefGroup.members>0)   {groupAddGroup(tankGroup, tankDefGroup);}
      if (cyborgDefGroup.members>0) {groupAddGroup(tankGroup, cyborgDefGroup);}
      if (cyborgAttGroup.members>0) {groupAddGroup(tankGroup, cyborgAttGroup);}
      tLastFinalAttack = gameTime;
      tLastTankAttack  = gameTime;
      bTankAttIsOn     = true;
      nFinalAttacks++;
     //printDebug1("activateAttack; Final Attack ___Activated___, attacking with droids("& tankGroup.members &") tLastFinalAttack was("& tLastFinalAttack &") gameTime("& gameTime &") nFinalAttacks was("& nFinalAttacks &") ");
      setEventTrigger(TankAttack,TankAttackTr);
      exit;
    }
  
  }
  
  //set to false when tankAttack stops
  if ( bFinalAttack_1vs1 ){ exit; }
    
  _player=0;
  nTotEnemyDroids     = 0;
  nTotFriendlyDroids  = 0;
  while( _player < MAX_PLAYERS ){
    if ( isPlayerStillLive(_player) and !friendlyPlayer(_player) ){
      nTotEnemyDroids = nTotEnemyDroids + (aStat[OC_CYBORGS][_player] + aStat[OC_TANKS][_player]);
    } 
    if ( isPlayerStillLive(_player) and friendlyPlayer(_player) ){
      nTotFriendlyDroids = nTotFriendlyDroids + (aStat[OC_CYBORGS][_player] + aStat[OC_TANKS][_player]);
    } 
    _player++;
  }

  if (!bTankAttIsOn and !bCybAttIsOn){ 
    
    // ============ VIRTUAL VICTORY CHECK ==================
    //printDebug1("activateAttack; Virtual Victory Check, _nMyUnits("& _nMyUnitsTot &") > Enemy x 4("& nTotEnemyDroids*4 &") and _nMyUnitsTot("& _nMyUnitsTot &")>10");
    if ( nTotFriendlyDroids > nTotEnemyDroids*4  and _nMyUnitsTot > 8 ){
      if ( AIPersonality != AI_CYBORG ) {
        if (helpGroup.members>0)     { groupAddGroup(tankGroup, helpGroup);}
        if (tankDefGroup.members>0)  { groupAddGroup(tankGroup, tankDefGroup);}
        if (cyborgDefGroup.members>0){ groupAddGroup(tankGroup, cyborgDefGroup);}
        if (cyborgAttGroup.members>0){ groupAddGroup(tankGroup, cyborgAttGroup);}
        tLastTankAttack       = gameTime;
        bTankAttIsOn          = true;
        setEventTrigger(TankAttack,TankAttackTr);
       //printDebug1("activateAttack; Virtual Victory ___Activated___, attacking with droids ("& tankGroup.members &") TotEnemyDroids*4("& nTotEnemyDroids*4 &") < nTotFriendlyDroids("& nTotFriendlyDroids &"); MyTotUnits("& _nMyUnitsTot &") and available droids > 8 ");
      } else {
        if (helpGroup.members>0)     { groupAddGroup(cyborgAttGroup, helpGroup);}
        if (tankDefGroup.members>0)  { groupAddGroup(cyborgAttGroup, tankDefGroup);}
        if (cyborgDefGroup.members>0){ groupAddGroup(cyborgAttGroup, cyborgDefGroup);}
        if (tankGroup.members>0){ groupAddGroup(cyborgAttGroup, tankGroup);}
        bCybAttIsOn           = true;
        tLastCyborgAttack     = gameTime;
       //printDebug1("activateAttack; Virtual Victory Check ___Activated___, attacking with droids ("& cyborgAttGroup.members &") TotEnemyDroids*4("& nTotEnemyDroids*4 &") < nTotFriendlyDroids("& nTotFriendlyDroids &"); MyTotUnits("& _nMyUnitsTot &") and available droids > 8 ");
        setEventTrigger(CyborgAttack,CyborgAttackTr);
      }
      //alternate attack targets between base and derrick
      if (bAttackHumanDerrick) {bAttackHumanDerrick = false;} else {bAttackHumanDerrick = true;}
      exit;
    }
  }



  //if not team leader wait a bit for team leader to decide when to attack
  /*
  if ( !IsTeamLeader() and nPlayersInGame > 4 ){
    if ( gameTime - tLastTankAttack < tTimeForceAttack*2 and (_nTotTankUnits+_nTotCybUnits<50) )
    { exit; }
    if ( gameTime - tLastCyborgAttack < tTimeForceAttack*2 and (_nTotTankUnits+_nTotCybUnits<50) )
    { exit; }
  }
  */ 


  if ( AIstrength < 4 or gameTime > tStartBaseAttacks*TIME_MINUTE or (_nTotTankUnits+_nTotCybUnits) > 35 )
  {
    // ================== TANK ATTACK =============================
    if ( AIPersonality != AI_CYBORG and !bTankAttIsOn ){
          
      //printDebug1("activateAttack; Att in Force Check ("& nTotEnemyDroids &")<5 and ("& _nMyUnitsTot &")>12");
      //attack in force if enemy has few troops, he cannot counter attack anyway...
      if ( nTotEnemyDroids < 5 and _nMyUnitsTot > 15){
        if (helpGroup.members>0)     { groupAddGroup(tankGroup, helpGroup);}
        if (tankDefGroup.members>0)  { groupAddGroup(tankGroup, tankDefGroup);}
        if (cyborgDefGroup.members>0){ groupAddGroup(tankGroup, cyborgDefGroup);}
        if (cyborgAttGroup.members>0){ groupAddGroup(tankGroup, cyborgAttGroup);}
        tLastTankAttack       = gameTime;
        bTankAttIsOn          = true;
       //printDebug1("activateAttack; Attack in Force ___Activated___, attacking with droids ("& tankGroup.members &") TotEnemyDroids("& nTotEnemyDroids &") < 5 and MyTotUnits("& _nMyUnitsTot &") > 12 ");
        setEventTrigger(TankAttack,TankAttackTr);
        exit;
      } 
              
      //printDebug1("Activate attack; Tank Attack Check _bUseCybUnitsToo("& _bUseCybUnitsToo &")("& _nCybUnitsToBeMoved &") _nTotTankUnits("& _nTotTankUnits &") >= _nTankRequiredToAttack("& _nTankRequiredToAttack &")");
      if ( _nTotTankUnits >= _nTankRequiredToAttack )
      {
       //check time to avoid all tanks are re-assigned back to tankgroup after a withdraw
       //do not attack if we have not enough units
        if ( _bUseCybUnitsToo ){
          moveUnitsBetweenGRPs(tankGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false);
        }
        moveUnitsBetweenGRPs(tankGroup, tankDefGroup, _nTankUnitsToBeMoved, true);
        tLastTankAttack = gameTime;
        bTankAttIsOn    = true;
        //dbg("Activate attack: Tank Attack Activated ("& tankGroup.members &")",player);
       //printDebug1("ActivateAttack; Tank Attack ___Activated___, att droids("& tankGroup.members &") _nTotTankUnits("& _nTotTankUnits &") _nUnitsRequired("& _nTankRequiredToAttack &") _bUseCybUn("& _bUseCybUnitsToo &") ToBeMoved Tk-Cy-toAdd("& _nTankUnitsToBeMoved &")("& _nCybUnitsToBeMoved &")("& nAttackingUnitsToAdd &")");
        if (bAttackHumanDerrick) {bAttackHumanDerrick = false;} else {bAttackHumanDerrick = true;}
        setEventTrigger(TankAttack,TankAttackTr);
        exit;
      }
    
    }
  
    //==================== CYBORG ATTACK =====================================
    //cyborgs
    if (!bCybAttIsOn and gameTime > VALID_TIME_CYBATTACK){  
      if ( _nTotCybUnits >= _nCybUnitsRequiredToAttack ){
        moveUnitsBetweenGRPs( cyborgAttGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false );
        bCybAttIsOn  = true;
        tLastCyborgAttack = gameTime;
        if ( _bUseTkUnitsToo ){
          moveUnitsBetweenGRPs( cyborgAttGroup, tankDefGroup, _nTankUnitsToBeMoved, false);
        }
        if (bAttackHumanDerrick) {bAttackHumanDerrick = false;} else {bAttackHumanDerrick = true;}
       //printDebug1("ActivateAttack; Cyborg Attack ___Activated___, attacking with Cyborgs ("& cyborgAttGroup.members &") ");
        setEventTrigger(CyborgAttack,CyborgAttackTr);
        exit;
      }
    }
  }
  
  //==================== HUMAN DERRICKS =====================================
  //attack human derrick with few defences if no targets in defend range
  if ( AIPersonality == AI_CYBORG ){
    //printDebug1("Activate attack; Human Derricks Check, bAttackHumanDerrick("& bAttackHumanDerrick &") bAttackingHumanDerrick("& bAttackingHumanDerrick &") condition("& cyborgDefGroup.members &")>("& (5 + minDefDroids[nAI_Pers][MINDEF_CYBORGS]) &") ");
    
    if ( !bCybAttIsOn and !bAttackHumanDerrick ){
      _cybRequired  = 5 + minDefDroids[nAI_Pers][MINDEF_CYBORGS];
      if ( attackCybObj == NULLOBJECT and cyborgDefGroup.members >= _cybRequired){
        attackCybObj = objHumanDerrick(false, 1, 8);//(bool bVTOLTarget, int _numDef, int _distInTiles
        if ( attackCybObj != NULLOBJECT ){

          moveUnitsBetweenGRPs(cyborgAttGroup, cyborgDefGroup, 5, false);
          bCybAttIsOn            = true;
          tLastCyborgAttack      = gameTime;
          bAttackingHumanDerrick = true;//alternate attacks
          nAttHumanPlayer++;
         //printDebug1("ActivateAttack; Attacking human derricks with droids("& cyborgAttGroup.members &") ");

          //order or advise ally to attack
          if ( IsTeamLeader() ){
            //send order
            dropBeaconToAllies("go!"  ,attackCybObj.x, attackCybObj.y, 0, false);
          } else {
            //send advise too
            dropBeaconToAllies("go!"  ,attackCybObj.x, attackCybObj.y, 0, false);
            sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackCybObj.player) &" with "& cyborgAttGroup.members &" droids", true );
          }

          setEventTrigger(CyborgAttack,CyborgAttackTr);
          exit;
        } 
      }
    }
  
  } else { //Other personalities
    
    _cybRequired  = 3 + minDefDroids[nAI_Pers][MINDEF_CYBORGS];
    _tankRequired = 2 + minDefDroids[nAI_Pers][MINDEF_TANKS];

   //printDebug1("Activate attack; Human Derricks Check, bAttackHumanDerrick("& bAttackHumanDerrick &") bAttackingHumanDerrick("& bAttackingHumanDerrick &") condition("& cyborgDefGroup.members &")>("& _cybRequired &") and ("& tankDefGroup.members &")>("& _tankRequired &") ");
  
    if ( !bTankAttIsOn and !bAttackHumanDerrick ){
       if ( tankDefGroup.members >= _tankRequired and  cyborgDefGroup.members >= _cybRequired){
        attackTankObj = objHumanDerrick(false, 1, 8);
        if ( attackTankObj != NULLOBJECT ){
          moveUnitsBetweenGRPs(tankGroup, cyborgDefGroup, 3, false);
          moveUnitsBetweenGRPs(tankGroup, tankDefGroup, 2, true);
          bTankAttIsOn           = true;
          tLastTankAttack        = gameTime;
          bAttackingHumanDerrick = true;//alternate attacks
          nAttHumanPlayer++;
         //printDebug1("ActivateAttack; Attacking human derricks ___Activated___  droids("& tankGroup.members &") ");

          //order or advise ally to attack
          if ( IsTeamLeader() ){
            //send order
            dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
          } else {
            //send advise too
            dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
            sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackTankObj.player) &" with "& tankGroup.members &" droids", true );
          }

          setEventTrigger(TankAttack,TankAttackTr);
          exit;
        } 
      }
    }
  
  }
  
  //==================== ENEMY DERRICKS =====================================
  if ( !bTankAttIsOn ){
    if ( _nTotTankUnits >= _nTankRequiredToAttack )
    {
      attackTankObj = closestEnemyDerrick(false,-1);//(_mustBeHuman , -1);
      if ( attackTankObj != NULLOBJECT ){
        if ( _bUseCybUnitsToo ){
          moveUnitsBetweenGRPs(tankGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false);
        }
        moveUnitsBetweenGRPs(tankGroup, tankDefGroup, _nTankUnitsToBeMoved, true);
        tLastTankAttack = gameTime;
        bTankAttIsOn    = true;
       //printDebug1("ActivateAttack; TK attack ___Activated___, attack ENEMY DERRICK, tk("& tankGroup.members &") _nTotTankUnits("& _nTotTankUnits &") _nUnitsRequired("& _nTankRequiredToAttack &") _bUseCybUn("& _bUseCybUnitsToo &") ToBeMoved Tk-Cy-toAdd("& _nTankUnitsToBeMoved &")("& _nCybUnitsToBeMoved &")("& nAttackingUnitsToAdd &")");

        //order or advise ally to attack
        if ( IsTeamLeader() ){
          //send order
          dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
        } else {
          //send advise too
          dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
          sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackTankObj.player) &" with "& tankGroup.members &" droids", true );
        }

        setEventTrigger(TankAttack,TankAttackTr);
        exit;
      }
    }
  }
  if (!bCybAttIsOn){  
    if ( _nTotCybUnits >= _nCybUnitsRequiredToAttack ){
      attackCybObj = closestEnemyDerrick(false,-1);//(_mustBeHuman , -1);
      if ( attackCybObj != NULLOBJECT ){
        if ( _bUseTkUnitsToo ){
          moveUnitsBetweenGRPs( cyborgAttGroup, tankDefGroup, _nTankUnitsToBeMoved, false);
        }
        moveUnitsBetweenGRPs( cyborgAttGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false );
        tLastCyborgAttack = gameTime;
        bCybAttIsOn       = true;
       //printDebug1("ActivateAttack; Cyb attack ___Activated___, attack ENEMY DRRICK, cyb("& cyborgAttGroup.members &") _nTotCybUnits("& _nTotCybUnits &") _nUnitsRequired("& _nTankRequiredToAttack &") _bUseCybUn("& _bUseCybUnitsToo &") ToBeMoved Tk-Cy-toAdd("& _nTankUnitsToBeMoved &")("& _nCybUnitsToBeMoved &")("& nAttackingUnitsToAdd &") ");

        //order or advise ally to attack
        if ( IsTeamLeader() ){
          //send order
          dropBeaconToAllies("go!"  ,attackCybObj.x, attackCybObj.y, 0, false);
        } else {
          //send advise too
          dropBeaconToAllies("go!"  ,attackCybObj.x, attackCybObj.y, 0, false);
          sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackCybObj.player) &" with "& cyborgAttGroup.members &" droids", true );
        }

        setEventTrigger(CyborgAttack,CyborgAttackTr);
        exit;
      }
    }
  }

  
  
}
//===========================================================================
event TankAttack(inactive)
{
	
  local int _distFromObj;
  
  //dbg("TankAttack: _____________("& tankGroup.members &")",player);
  //do a preliminary check
  if ( (tankGroup.members <= MIN_SURVIVOR_TANKS and !bAttackingHumanDerrick) or tankGroup.members==0 ){
     if (tankGroup.members>0){
      groupAddGroup(tankDefGroup , tankGroup);
     }
     deactivateTankAttack();
     exit;//this is necessary otherwise the event proceeeds!        
  }
 
   
  //Gathering troops!!!
  if ( gameTime - tGatheringTank > 150 ){
    tGatheringTank = gameTime;
    if ( bTankAlreadyGathered or bAttackTeamAttacked ){
      orderGroupLoc(tankGroup, DORDER_MOVE, tankGroup.x, tankGroup.y);
    } else {
      orderGroupLoc(tankGroup, DORDER_MOVE, tankGroup.x, tankGroup.y);
    }
    exit;
  }
  if ( gameTime - tGatheringTank < 29 ){ 
    exit; 
  }

  //get target for the first attack, further targets are chosen below   
  if ( attackTankObj == NULLOBJECT and !bTankAlreadyGathered ){     
    attackTankObj = getTargetObj();
    if ( attackTankObj != NULLOBJECT ){
      if ( isHumanPlayer(attackTankObj.player) ){
        nAttHumanPlayer++;
       //printDebug1("TankAttack; attacking human player '"& getPlayerName(attackTankObj.player) &"' with ("& tankGroup.members &")");
      } else {
        nAttAIPlayer++;
       //printDebug1("TankAttack; attacking AI player '"& getPlayerName(attackTankObj.player) &"' with ("& tankGroup.members &")");
      } 

      //order or advise ally to attack
      if ( IsTeamLeader() ){
        //send order
        dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
      } else {
        //send advise too
        dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
        sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackTankObj.player) &" with "& tankGroup.members &" droids", true );
      }
    
    }    
  }
  
  if ( attackTankObj == NULLOBJECT ){
   if ( bTankAlreadyGathered ){
       //get a new target in area
      attackTankObj = objDroidTargetInRange(tankAttackX,tankAttackY,TILE*25,false);
      if (attackTankObj == NULLOBJECT){
        attackTankObj = objStrTargetInRange(tankAttackX,tankAttackY,TILE*25);
      }
      //attack enemy base
      if (attackTankObj == NULLOBJECT){
        if ( targetPlayerTank > -1 ){
          attackTankObj = objStrTargetInRange(aPl[targetPlayerTank][X_COORD],aPl[targetPlayerTank][X_COORD],TILE*25);
        }
      }
  
      if (attackTankObj != NULLOBJECT){
        //collect info
        targetPlayerTank  = attackTankObj.player; 
        targetPlayerVTOL  = targetPlayerTank;
        tankAttackX       = attackTankObj.x;
        tankAttackY       = attackTankObj.y;          
        droidMicroManager(tankGroup, 12*TILE, tankAttackX, tankAttackY );
      } else {
        groupAddGroup(tankDefGroup , tankGroup);
        deactivateTankAttack();
      }
    }
    exit;
  
  } else { // ____ attackTankObj != NULLOBJECT ______
  
    //collect all obj info, later on this object could be dead...
    targetPlayerTank  = attackTankObj.player; 
    targetPlayerVTOL  = targetPlayerTank;
    tankAttackX       = attackTankObj.x;
    tankAttackY       = attackTankObj.y;
    
    //determine gathering positions, 12 tiles away from it
    //send tanks to gathering positions
    if ( !lTankSentToGatheringPoint ){
      if (nTankGatheringX <= 0 and nTankGatheringY <= 0){        
        setTankGatheringPoint(baseX,baseY,attackTankObj.x,attackTankObj.y);      
      }
      //centre of the map.
      if (nTankGatheringX <= 0 or nTankGatheringY <= 0) {
        nTankGatheringX = (mapWidth*TILE)/2;
        nTankGatheringY = (mapHeight*TILE)/2;
      }
  
      orderGroupLoc(tankGroup,DORDER_MOVE,nTankGatheringX,nTankGatheringY);
      lTankSentToGatheringPoint = true;
      tTanksSentToGathering     = gameTime;
    }
            
    //check if tank group has arrived at gathring point, need to check the distance too!!!        
    if ( !bTankAlreadyGathered ){
      if ( (float)idleGroup(tankGroup) > (float)tankGroup.members*0.8 or distBetweenTwoPoints(tankGroup.x, tankGroup.y, nTankGatheringX, nTankGatheringY) < 4 * TILE or gameTime - tTanksSentToGathering > 2400 ) 
      {             
                
        bTankAlreadyGathered      = true;
        nTankGatheringX           = -1; 
        nTankGatheringY           = -1;
        tTanksSentToGathering     = 0;                                      
        orderGroupScoutCMD(tankGroup,tankAttackX,tankAttackY);
  
      } else { 
            
        //just "rememeber" tanks where to go...
        if ( gameTime - tTanksReSentToGathering > 70 ){
          if (bAttackTeamAttacked){
            //orderGroupScoutCMD(tankGroup,nTankGatheringX,nTankGatheringY);
            droidMicroManager(tankGroup, 12*TILE, nTankGatheringX, nTankGatheringY );
          }else{
            orderGroupLoc(tankGroup,DORDER_MOVE,nTankGatheringX,nTankGatheringY);
          }
          tTanksReSentToGathering  = gameTime;
          if ( tTanksSentToGathering < 0){tTanksSentToGathering = gameTime;}
        }      
      }        
    
    } else {//bTankAlreadyGathered == TRUE
    
      if ( gameTime - tTankAttackAction > 29 ){
        
        count = distBetweenTwoPoints(tankGroup.x,tankGroup.y,tankAttackX,tankAttackY);
        droidMicroManager(tankGroup, 12*TILE, tankAttackX, tankAttackY );
        tTankAttackAction = gameTime;
        
      }
    }
  }
}
//===========================================================================
event CyborgAttack(inactive)//Original event ID: xx (of 106) 
{
  local int _distFromObj,_x,_y;
  
  //dbg("CyborgAttack: ______________("& cyborgAttGroup.members &")",player);

  //do a preliminary check
  if ( (cyborgAttGroup.members <= MIN_SURVIVOR_CYBORGS and !bAttackingHumanDerrick) or cyborgAttGroup.members==0){
      if (cyborgAttGroup.members > 0){
      groupAddGroup(cyborgDefGroup , cyborgAttGroup);
     }
     deactivateCybAttack();
     exit;      
  }

  if ( gameTime - tGatheringCyb > 150 ){
    tGatheringCyb = gameTime;
    if ( bCybAlreadyGathered or bAttackTeamAttacked ){
      orderGroupLoc(cyborgAttGroup, DORDER_MOVE, cyborgAttGroup.x, cyborgAttGroup.y);
    } else {
      orderGroupLoc(cyborgAttGroup, DORDER_MOVE, cyborgAttGroup.x, cyborgAttGroup.y);
    }
    exit;
  }
  if ( gameTime - tGatheringCyb < 29 ){ 
    exit; 
  }


  //get target   
  //displayMsg("CyborgAttack: ________________ START CYBORG ATTACK ___________________");
    
  if ( attackCybObj == NULLOBJECT ){
    
    if ( bCybAlreadyGathered ){
      //get a new target in area
      attackCybObj = objDroidTargetInRange(cybAttackX,cybAttackY,TILE*25,false);
      if (attackCybObj == NULLOBJECT){
        attackCybObj = objStrTargetInRange(cybAttackX,cybAttackY,TILE*25);
      }
      if (attackCybObj != NULLOBJECT){
        //collect info
        targetPlayerCyb   = attackCybObj.player; 
        targetPlayerVTOL  = targetPlayerCyb;
        cybAttackX   = attackCybObj.x;
        cybAttackY   = attackCybObj.y;
        tCybAttackAction = gameTime;
        droidMicroManager(cyborgAttGroup, 12*TILE, cybAttackX, cybAttackY );
        
      } else {
        //displayMsg("CyborgAttack: ________________ CYBORG ATTACK DEACTIVATED - ALL TARGETS IN RANGE HAVE BEEN DESTROYED___________________");
        if (cyborgAttGroup.members>0){
          groupAddGroup(cyborgDefGroup , cyborgAttGroup);
        }
        deactivateCybAttack();
      }
    
    } else { // NOT bCybAlreadyGathered
      
      attackCybObj = getTargetObj();
      if ( attackCybObj != NULLOBJECT ){

        if ( isHumanPlayer(attackCybObj.player) ){
          nAttHumanPlayer++;
         //printDebug1("CyborgAttack; attacking Human player '"& getPlayerName(attackCybObj.player) &"' with "& cyborgAttGroup.members &" droids ");
        } else {
          nAttAIPlayer++;
         //printDebug1("CyborgAttack; attacking AI player '"& getPlayerName(attackCybObj.player) &"' with "& cyborgAttGroup.members &" droids");
        } 
      
        //order or advise ally to attack
        if ( IsTeamLeader() ){
          //send order
          dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
        } else {
          //send advise
          dropBeaconToAllies("go!"  ,attackTankObj.x, attackTankObj.y, 0, false);
          sendMsgToAllAllies("Player "& getPlayerName(player) & " attacking "& getPlayerName(attackTankObj.player) &" with "& tankGroup.members &" droids" , true);
        }

      }
      exit;
    }
  
  } else { //attackCybObj != NULLOBJECT

    //collect all obj info, later on this object could be dead...
    targetPlayerCyb   = attackCybObj.player; 
    targetPlayerVTOL  = targetPlayerCyb;
    cybAttackX        = attackCybObj.x ; 
    cybAttackY        = attackCybObj.y ;
    
    //determine gathering positions, 12 tiles away from it
    //send cyborgs to gathering positions
    if ( !lCybSentToGatheringPoint ){
    
      if (nCybGatheringX <= 0 and nCybGatheringX <= 0){
        
        count = random(3);
        
        if ( count == 0 ){
          if ( attackCybObj.x > baseX ){
            _x = baseX +  (attackCybObj.x-baseX)/2;
          } else {
            _x = baseX -  (baseX-attackCybObj.x)/2;
          }
          if ( attackCybObj.y > baseY ){
            _y = baseY +  (attackCybObj.y-baseY)/2;
          } else {
            _y = baseY -  (baseY-attackCybObj.y)/2;
          }
          nCybGatheringX = getCoordRelated(_x, _y, baseX, baseY, 1, 1*TILE);
          nCybGatheringY = getCoordRelated(_x, _y, baseX, baseY, 2, 1*TILE);
        }
       if ( count == 1 ){    //centre of the map
          _x = (mapWidth*TILE)/2;
          _y = (mapHeight*TILE)/2;
          nCybGatheringX = getCoordRelated(_x, _y, baseX, baseY, 1, 1*TILE);
          nCybGatheringY = getCoordRelated(_x, _y, baseX, baseY, 2, 1*TILE);
        }
        if ( count == 2 ){   //standard
          _distFromObj = 13*TILE + (((mapWidth*TILE+mapHeight*TILE)/2) / 30 );
          _x = attackCybObj.x;
          _y = attackCybObj.y;
          nCybGatheringX = getCoordRelated(_x, _y, baseX, baseY, 1, _distFromObj);
          nCybGatheringY = getCoordRelated(_x, _y, baseX, baseY, 2, _distFromObj);
        }
      
      }
      //centre of the map.
      if (nCybGatheringX <= 0 or nCybGatheringY <= 0) {
        nCybGatheringX = (mapWidth*TILE)/2;
        nCybGatheringY = (mapHeight*TILE)/2;
      }
    
        orderGroupLoc(cyborgAttGroup,DORDER_MOVE,nCybGatheringX,nCybGatheringY);
        lCybSentToGatheringPoint = true;
        tCybSentToGathering     = gameTime;
    }
    
    //check if Cyborgs group has arrived at gathring point, need to check the distance too!!!
    if ( !bCybAlreadyGathered ) {             
    
      if ( (float)idleGroup(cyborgAttGroup) > (float)cyborgAttGroup.members*0.8 or distBetweenTwoPoints(cyborgAttGroup.x, cyborgAttGroup.y, nCybGatheringX, nCybGatheringY) < 4 * TILE or gameTime - tCybSentToGathering > 2400) {             
         bCybAlreadyGathered       = true;  
        nCybGatheringX            = -1; 
        nCybGatheringY            = -1;
        tCybSentToGathering       = 0;
        orderGroupScoutCMD(cyborgAttGroup,cybAttackX,cybAttackY);
      } else { 
        
        //just "rememeber" cyborgs where to go...
        if ( gameTime - tCybReSentToGathering > 70 ){
          if (bAttackTeamAttacked){
            //orderGroupScoutCMD(cyborgAttGroup,nCybGatheringX,nCybGatheringY);
            droidMicroManager(cyborgAttGroup, 12*TILE, nCybGatheringX, nCybGatheringY );
          }else{
            orderGroupLoc(cyborgAttGroup,DORDER_MOVE,nCybGatheringX,nCybGatheringY);
          }
          tCybReSentToGathering = gameTime;
          if ( tCybSentToGathering < 0 ){ tCybSentToGathering = gameTime; }
        }
      }
  
    } else {//if ( bCybAlreadyGathered )
        if ( gameTime - tCybAttackAction > 29 ){
          tCybAttackAction = gameTime;
          droidMicroManager(cyborgAttGroup, 12*TILE, cybAttackX, cybAttackY );
        }
    
    }
  } ////attackCybObj != NULLOBJECT
}



//================================================================
// CALL_ATTACKED, player, ref myBaseObject, ref enemyBaseObject
event AIattacked(AIattackedTr)    //event 20
{
	local DROID _myDroid,_enDroid,_droid;
	local STRUCTURE _myStruct,_enStruct;
	local GROUP _myGroup;
  local WEAPON _enWeapon;
  local bool _bProceed,_bAttackedByVTOL;
	local int _nDistFromBase, _nDistFromEnemy, _nAA, _enX, _enY, _myX, _myY,_enPlayer;
	
  _bProceed = true;

  if ( gameTime - alertTime < 60 ){ exit; }
  //dbg("AIattacked: called ("& bAttackedByVTOL &")",player);
  
  _bAttackedByVTOL = false;
  _nDistFromEnemy = -1;
  _nDistFromBase  = -1;
  _myX = -1;
  _myY = -1;
  _enX = -1;
  _enY = -1;
  if(enemyBaseObject != NULLOBJECT){
  
  
    //warzone bug check (WZ release 3.2)
    if ( friendlyPlayer(enemyBaseObject.player) or enemyBaseObject.player == player){
      exit;
    }
    _enWeapon = enemyBaseObject.weapon;
    _enX      = enemyBaseObject.x;
    _enY      = enemyBaseObject.y;
    _enPlayer =  enemyBaseObject.player;
    if (enemyBaseObject.type == OBJ_DROID){
      _enDroid = objToDroid(enemyBaseObject);
      if ( isVtol(_enDroid) ) {
        //dbg("AIattacked: attacked by VTOL!!!",player);
        _bAttackedByVTOL = true;
        bAttackedByVTOL  = true;
        exit;
      } else {
        _bAttackedByVTOL = false;
      }
    } else {
      _enStruct = objToStructure(enemyBaseObject);
    }
  }

  if(myBaseObject != NULLOBJECT ){
    if ( myBaseObject.player != player){
      exit;
    }
    _myX = myBaseObject.x;
    _myY = myBaseObject.y;
    if( myBaseObject.type == OBJ_DROID ){
      _myDroid = objToDroid(myBaseObject);
      _myGroup = _myDroid.group;
    } else {
      _myStruct = objToStructure(myBaseObject);
    }
    _nDistFromBase  = distBetweenTwoPoints(baseX, baseY, _myX , _myY);
  }
  if(enemyBaseObject != NULLOBJECT and myBaseObject != NULLOBJECT){
    _nDistFromEnemy = distBetweenTwoPoints( _myX , _myY , _enX ,_enY );
  }

  if( _nDistFromBase < 0 ){
    if( _enX >0  and _enY > 0 ){
      _nDistFromBase  = distBetweenTwoPoints(baseX, baseY, _enX , _enY);
    }
  }
  if ( _nDistFromBase < 0 ){ exit; }
  
	

  //recall to base if buildGrp, buildDefGrp or cybConstGrp
  if( _myGroup == harvesterGroup or _myGroup == buildGrp or _myGroup == buildDefGrp or _myGroup == cybConstGrp){
    if ( _nDistFromBase > nBaseRange ){
      if ( _myDroid != NULLOBJECT ){
        orderDroid( _myDroid, DORDER_RTB);
      }  
    }
  }
  
  //displayMsg("AIattacked:  dist myOBJ from base/def Range ("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist my obj/en obj ("& _nDistFromEnemy/TILE &")");
  if (_nDistFromBase > nDefendRange){
    if( _myDroid != NULLOBJECT ){
      if( _myGroup == tankGroup or _myGroup == cyborgAttGroup or _myGroup == helpGroup){
  		  if ( !_bAttackedByVTOL ) {
          bAttackTeamAttacked = true;//activates SCOUT order instead of MOVE order
        }
      }
    }
  } 
    
  //dbg("AIattacked: 1 _nDist("& _nDistFromBase/TILE &") def("& nDefendRange/TILE &") alertTime("& alertTime &") gameTime("& gameTime &") diff("& gameTime - alertTime &")",player);
  if ( _nDistFromBase > nDefendRange and _nDistFromBase > 22*TILE ){ exit; }

  //check if attacked by mortars!!! but only if a struct was attacked
  if ( _myStruct != NULLOBJECT ){
  if ( _enWeapon == MortarWeap or _enWeapon == MortarIncWeap or _enWeapon == BombardWeap or _enWeapon == PepperpotWeap )
  {
    
    bAttackedByMortars = true;//activate research
    _nAA = getAA_OnTheWay(baseX, baseY,_enX, _enY, AA_THREAT_RANGE);
    if ( _nAA*4 < vtolGr.members )
    {
      if ( enemyBaseObject != NULLOBJECT ){
        defTargetVTOL         = enemyBaseObject;
        targetPlayerVTOL      = _enPlayer;
        bVTOLTargetIsDerrick  = false;
        tTargetTime           = gameTime;
      }
    }
    if ( gameTime - tLongRangeTime > 40 ){
      tLongRangeTime = gameTime;  
      nKineticX = _myX;
      nKineticY = _myY;
      _droid = closestDroidCanBuild(buildDefGrp,nKineticX,nKineticY);
      if ( _droid != NULLOBJECT ){
        defFromLongRangeWeap( _droid );
      }
    } 
  
  } else {
  
    if ( _nDistFromEnemy >= 25*TILE and _nDistFromEnemy < 90*TILE ){ 
     
      bAttackedByLongRangeWeap = true;//activate research
      //set VTOL target
      _nAA = getAA_OnTheWay(baseX, baseY, _enX, _enY, AA_THREAT_RANGE);
      if ( _nAA*4 < vtolGr.members )
      {
        if ( enemyBaseObject != NULLOBJECT ){
          defTargetVTOL         = enemyBaseObject;
          targetPlayerVTOL      = _enPlayer;
          bVTOLTargetIsDerrick  = false;
          tTargetTime           = gameTime;
        }
      
      }
      
      //move the attacked unit away!!
      if( _myDroid != NULLOBJECT and _myGroup != NULLOBJECT ){
        //try to move the droid teams away
        if(_myGroup == tankDefGroup or _myGroup == cyborgDefGroup)
        {
          orderGroup(cyborgDefGroup, DORDER_RTB);
          orderGroup(tankDefGroup, DORDER_RTB);
          gatherDefCybX  = baseX;
          gatherDefCybY  = baseY;
          gatherDefTankX = baseX;
          gatherDefTankY = baseY;
        }
      }
      
      if ( gameTime - tLongRangeTime > 40 ){
        tLongRangeTime = gameTime;  
        nKineticX = _myX;
        nKineticY = _myY;
        _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
        if ( _droid != NULLOBJECT ){
          defFromLongRangeWeap(_droid);
        }
      }
  
      //it can be that even if the _nDistFromEnemy is big, it is still in defend range
      // if not stop event
      if ( distBetweenTwoPoints( baseX , baseY , _enX ,_enY ) > nDefendRange ){
        _bProceed = false;
      }

    } else {
    
      //do not set troops to attack it
      if ( _nDistFromEnemy > 90*TILE ){
        _bProceed = false;
      }
    
    }
  }
  }
  
  
  if(_bProceed and gameTime - alertTime > 50 and !_bAttackedByVTOL){
      
    if ( _enDroid != NULLOBJECT ){ attackedByDroid(_enDroid);	 } 
    if ( _enStruct != NULLOBJECT){ attackedByStruct(_enStruct); }

              
    if (gameTime - alertTime > 300){
      gatherDefTankX = getCoordRelated(_myX, _myY, baseX, baseY, 1, 8*TILE);
      gatherDefTankY = getCoordRelated(_myX, _myY, baseX, baseY, 2, 8*TILE);
      gatherDefCybX  = getCoordRelated(_myX, _myY, baseX, baseY, 1, 12*TILE);
      gatherDefCybY  = getCoordRelated(_myX, _myY, baseX, baseY, 2, 12*TILE);
    }

    alertTime      = gameTime;
	  if ( _enX > 0 and _enY > 0 ){
  	  alertIsOn      = true;
      alertX         = _enX;
  	  alertY         = _enY;
	  } else {
  	  if ( _myX > 0 and _myY > 0 ){
    	  alertIsOn      = true;
        alertX         = _myX;
    	  alertY         = _myY;
    	}
    }
    targetPlayerVTOL = _enPlayer;
    if( alertLevel == RED_ALERT and gameTime > 10*TIME_MINUTE ){
      if ( alertX >= 0 and alertY >= 0 ){
        dropBeaconToAllies("help" , alertX, alertY, 0, true);
        dropBeaconToAllies("help" , alertX, alertY, 0, false);
        //sendMsgToAllAllies("help", false);
      }
    }
       
    //remember coord of attacked obj: build defences
    if ( _myX > 0 and _myY > 0 ){
    if ( gameTime - nLastDefSpotUpdate > 3*TIME_MINUTE and _nDistFromEnemy < 22*TILE) {
      defSpotX = _myX;
  		defSpotY = _myY;
			if ( defSpotX < TILE*4 ) { defSpotX = TILE*4; }
      if ( defSpotY < TILE*4 ) { defSpotY = TILE*4; }
			nLastDefSpotUpdate = gameTime;
		}
		}
		
     
  } //if(_bProceed and gameTime - alertTime > 50){
}
//--------------------------------------------------------------
event manageDefTank( inactive ) 
{

	local int _x,_y,_x1,_y1, _nDist;

  eventCheckTime[6] = gameTime;

  //dbg("def: tkdef("& tankDefGroup.members &") cybDef("& cyborgDefGroup.members &")",player);

  if( tankDefGroup.members == 0 ){ exit; }

  if ( gatherDefTankX >= 0 and gatherDefTankY >= 0 ){
    count2 = distBetweenTwoPoints(gatherDefTankX,gatherDefTankY,baseX,baseY);
    //bring def units back at home
    if ( count2 > nDefendRange ){
      gatherDefTankX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, 8*TILE);
      gatherDefTankY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, 8*TILE);
    }
  } else {
    gatherDefTankX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, 8*TILE);
    gatherDefTankY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, 8*TILE);
  } 
  //check is not -1;
  if ( gatherDefTankX == -1 ){ gatherDefTankX = baseX; gatherDefTankY = baseY; }
  if ( gatherDefTankY == -1 ){ gatherDefTankX = baseX; gatherDefTankY = baseY; }
  
  //If bighelp just sent MOVE all droids to the base
	if ( gameTime - tBigHelpRequest < 1*TIME_MINUTE ){
	  if ( gameTime - tDefTankAction > 25 ){
      if ( distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y,baseX,baseY) > nBaseRange )
      {
        orderGroupLoc(tankDefGroup, DORDER_MOVE, baseX, baseY);
      }
      tDefTankAction = gameTime;
    }
	  exit;
  }
  
  
  
  //if an ALERT is on send to ALERT coord
  if ( alertIsOn ){
    
    if ( tankDefGroup.members >= MIN_DEFUNIT_DEFEND ){
      if ( alertX > 0  and alertY > 0 ){
        droidMicroManager(tankDefGroup, 12*TILE, alertX, alertY );
      } else {
        orderGroup(tankDefGroup, DORDER_RTB);
      }
      tDefTankAction = gameTime;
    }
  
  } else { //alert is not ON
      
    //reset alert coord
    if (cybAlertX > 0){cybAlertX = -1;cybAlertY = -1;}

    //get a target or gather coord
    if ( distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y,baseX,baseY) < nDefendRange)
    {

      if ( objTargetTankDefGRP == NULLOBJECT ){
        objTargetTankDefGRP = objDroidTargetInRange(baseX,baseY,nDefendRange,false);
      }
      if ( objTargetTankDefGRP == NULLOBJECT ){
        objTargetTankDefGRP = objStrTargetInRange(baseX,baseY,nDefendRange);
      }
      
      //target found!
      if ( objTargetTankDefGRP != NULLOBJECT and tankDefGroup.members >= MIN_DEFUNIT_ATTACK )
      {        
        if ( gameTime - tDefTankAction > 29 ){        
          droidMicroManager(tankDefGroup, 12*TILE, objTargetTankDefGRP.x,objTargetTankDefGRP.y );
          //orderGroupScoutCMD(tankDefGroup,objTargetTankDefGRP.x,objTargetTankDefGRP.y);
          tDefTankAction = gameTime;
        }
      
      } else {//no enemy in range, return to gathering point          
        
        if ( distBetweenTwoPoints(tankDefGroup.x,tankDefGroup.y,gatherDefTankX,gatherDefTankY) > 3*TILE and gameTime - tDefTankAction > 60){
          orderGroupScoutCMD(tankDefGroup,gatherDefTankX,gatherDefTankY);
          tDefTankAction = gameTime;
        }            
      
      }        
    
    } else {//return togathering point
      
      objTargetTankDefGRP = NULLOBJECT;
      if ( distBetweenTwoPoints(tankDefGroup.x,tankDefGroup.y,gatherDefTankX,gatherDefTankY) > 3*TILE and gameTime - tDefTankAction > 60)
      {
        orderGroupScoutCMD(tankDefGroup,gatherDefTankX,gatherDefTankY);
        tDefTankAction = gameTime;
      }        
    
    }
    
  
  }//alertIsOn
}

//======================================================
event manageDefCyborgs (inactive)//event 18!!!!
{

	local int _nUnitsToBeMoved,_nTotUnits,_nUnitsRequiredToAttack;
	local int _x,_y,_x1,_y1,_nDist;
	
  eventCheckTime[5] = gameTime;
     
  if( cyborgDefGroup.members == 0 ){ exit; }

  if ( gatherDefCybX >= 0 and gatherDefCybY >= 0 ){
    count2 = distBetweenTwoPoints(gatherDefCybX,gatherDefCybY,baseX,baseY);
    if ( count2 > nDefendRange ){
      gatherDefCybX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, 8*TILE);
      gatherDefCybY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, 8*TILE);
    }
  } else {
      gatherDefCybX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, 8*TILE);
      gatherDefCybY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, 8*TILE);
  }
  if ( gatherDefCybX == -1 ){ gatherDefCybX = baseX; gatherDefCybY = baseY; }
  if ( gatherDefCybY == -1 ){ gatherDefCybX = baseX; gatherDefCybY = baseY; }

  //If bighelp just sent MOVE all droids to the base
	if ( gameTime - tBigHelpRequest < 1*TIME_MINUTE ){
	  if ( gameTime - tDefCybAction > 25 ){
  	  if ( distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y,baseX,baseY) > nBaseRange )
      {
        orderGroupLoc(cyborgDefGroup, DORDER_MOVE, baseX, baseY);
      }
      tDefCybAction = gameTime;
    }
	  exit;
  }

  if ( alertIsOn )
  { 

    //set alert coord if not done already
    if (cybAlertX < 0 or (cybAlertX != alertX) ){
      if(alertX > 0){
  	    cybAlertX = alertX;
  	    cybAlertY = alertY;
  	  }
  	}
  
    //go to alert coord
    //displayMsg("manageDefCyborgs: cyborgs ("& cyborgDefGroup.members &") CALLED ("& alertIsOn &") _nDist("& _nDist/TILE &")");
    //if ( gameTime - tDefCybAction > 29 and (cyborgDefGroup.members >= MIN_DEFCYB_DEFEND)){
    if ( cyborgDefGroup.members >= MIN_DEFCYB_DEFEND ){
      if ( alertX > 0  and alertY > 0 ){
        droidMicroManager(cyborgDefGroup, 12*TILE, alertX, alertY );
      } else {
        orderGroup(cyborgDefGroup, DORDER_RTB);
      }
       tDefCybAction = gameTime;
    } 
     
  } else {//def alert not active

    if (cyborgDefGroup.members >= MIN_DEFUNIT_ATTACK  ){
      
      //reset alert coord
      if (cybAlertX > 0){cybAlertX = -1;cybAlertY = -1;}
       
      //enemy droid or struct in Cyborg Range?
      _nDist = distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, baseX, baseY);
      if ( _nDist < nDefendRange ){
        
        //enemies in nDefendRange?
        if ( objTargetCybDefGRP == NULLOBJECT ){
          objTargetCybDefGRP = objStrTargetInRange(baseX,baseY,nDefendRange);
        }
        if ( objTargetCybDefGRP == NULLOBJECT ){
          objTargetCybDefGRP = objDroidTargetInRange(baseX,baseY,nDefendRange,false);
        }
        //if no targets go back to gathering points
        if ( objTargetCybDefGRP == NULLOBJECT ){
           if ( distBetweenTwoPoints(cyborgDefGroup.x,cyborgDefGroup.y,gatherDefCybX,gatherDefCybY) > 3*TILE and gameTime - tDefCybAction > 60){
            orderGroupScoutCMD(cyborgDefGroup,gatherDefCybX,gatherDefCybY);
            tDefCybAction = gameTime;
          }
        } else {
          //Attack enemy in defend range!!!
          if ( gameTime - tDefCybAction > 29 ){ 
            _nDist  = distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, objTargetCybDefGRP.x, objTargetCybDefGRP.y);       
            if ( _nDist > 2*TILE ){
              droidMicroManager(cyborgDefGroup, 12*TILE, objTargetCybDefGRP.x, objTargetCybDefGRP.y );
              tDefCybAction = gameTime;
            }
          }
        
        }
     
      } else {   //count > nDefendRange, send units back!!           

          _nDist = distBetweenTwoPoints(cyborgDefGroup.x,cyborgDefGroup.y,gatherDefCybX,gatherDefCybY);
          if ( _nDist > 3*TILE and gameTime - tDefCybAction > 60){
            orderGroupScoutCMD(cyborgDefGroup,gatherDefCybX,gatherDefCybY);
            tDefCybAction = gameTime;
          }
        
      }    

    } else {//cyborgDefGroup.members < MIN_DEFUNIT_ATTACK
    
      _nDist = distBetweenTwoPoints(cyborgDefGroup.x,cyborgDefGroup.y,gatherDefCybX,gatherDefCybY);
      if ( _nDist > 3*TILE and gameTime - tDefCybAction > 60){
        orderGroupScoutCMD(cyborgDefGroup,gatherDefCybX,gatherDefCybY);
        tDefCybAction = gameTime;
      }

    }
  } //alertIsOn    
}
//===================================================================
//manages idle buildGrp,harvGrp,buildDefGrp and CybEng Grp
//does not use any money, only help and repairTaks
event manageIdleTrucks(inactive)
{
 
   local bool _bHarvesting;
   local int _n1,_n2;
   
   eventCheckTime[7] = gameTime;
   //dbg("manageIdleTrucks: ________________ START 1__________________",player);
   if ( gameTime < 300 ) { exit; }

   boolResult  = true;
   boolResult2 = true;
   boolResult3 = true;

  //helpbuild of derricks, but only after lMinBaseStructBuilt is ok
  if ( lMinBaseStructBuilt ){
    initEnumStruct(false,derrick,player,player);
    structure = enumStruct();
    while (structure != NULLOBJECT){
      if(!structureComplete(structure)){
        if ( distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) > nBaseRange )
        {
          _n1 = numDroidsBuilding(buildGrp, structure.x, structure.y );
          _n2 = numDroidsBuilding(cybConstGrp, structure.x, structure.y);
        }
        if ( _n1+_n2 < 2  ){
          if ( !threatInRange(player,structure.x, structure.y, THREAT_RANGE_TILES_SHORT*128, false) )
          {
            _idleTruck = closestIdleDroid(cybConstGrp,baseX, baseY);
            if (_idleTruck == NULLOBJECT){  
              _idleTruck = closestIdleDroid(buildGrp,baseX, baseY);
            }
            if (_idleTruck != NULLOBJECT){  
              if (droidCanReach(_idleTruck, structure.x, structure.y) ){
       				 orderDroidObj(_idleTruck,DORDER_HELPBUILD,structure);
       				}
     				}  
          }
        }
      }
      structure = enumStruct();
    }

     //helpbuild of repair Facility 
    initEnumStruct(false,repairFacility,player,player);
    structure = enumStruct();
    while (structure != NULLOBJECT){
      if(!structureComplete(structure)){
        if ( !threatInRange(player,structure.x, structure.y, THREAT_RANGE_TILES_SHORT*128, false) )
        {
          _idleTruck = closestIdleDroid(cybConstGrp,baseX, baseY);
          if (_idleTruck == NULLOBJECT){  
            _idleTruck = closestIdleDroid(buildGrp,baseX, baseY);
          }
          if (_idleTruck != NULLOBJECT){  
            if (droidCanReach(_idleTruck, structure.x, structure.y) ){
     				 orderDroidObj(_idleTruck,DORDER_HELPBUILD,structure);
     				}
          }
        } 
      }
      structure = enumStruct();
    }
  
  } //if ( lMinBaseStructBuilt ){

   
  //idle cybEngineers
  if( cybConstGrp.members>0 ){
    _bHarvesting = false;
    if ( gameTime - tHarvestNearOilRes > 1*TIME_MINUTE ){
      _bHarvesting = harvestNearOilRes();
    } 
    if ( !_bHarvesting ) {
      if ( !repairStructs(CYBENG_GRP) ){
        boolResult3 = repairDefStructs(CYBENG_GRP);
      }
    }   
  }

  //idle build Grp members 
  if( buildGrp.members>0 and lMinBaseStructBuilt ){
    if ( !repairStructs(BUILD_GRP) ){
     boolResult2 = repairDefStructs(BUILD_GRP);
    }      
  }
   
   _idleTruck = closestIdleDroid(buildGrp,baseX, baseY);
   if (_idleTruck != NULLOBJECT){
      helpBuild( _idleTruck );
   }
   _idleTruck = closestIdleDroid(cybConstGrp,baseX, baseY);
   if (_idleTruck != NULLOBJECT){
      helpBuild( _idleTruck );
   }
   
   //send all idle back to the base!!!
   sendIdleBackToTheBase(BUILD_GRP);
   sendIdleBackToTheBase(CYBENG_GRP);

}
//================================================ 
event manageRepairTeam(inactive)
{
    
  eventCheckTime[28] = gameTime;

  if (repairGroup.members < 0){exit;}
        
  boolResult = true;    

  droid2 = idleRepairDroid(baseX,baseY);
  if ( droid2 != NULLOBJECT )
  {
    droid = nearestDroidToBeRepaired(toBeRepairedTankGroup, droid2.x, droid2.y);
    if ( droid != NULLOBJECT){
      if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
        orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
        boolResult = false;
        }
    }
  }
  
  
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(toBeRepairedCyborgGroup, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }
  
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(buildGrp, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
          boolResult = false;
        }
      }
    }
  }
   
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(harvesterGroup, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }
  
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(buildDefGrp, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }
  
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(cybConstGrp, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }
  
  if (boolResult){
    droid2 = idleRepairDroid(baseX,baseY);//this picks up
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(repairGroup, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if( droid.id != droid2.id ){
          if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nBaseRange ) {
           orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
           boolResult = false;
          }
        }
      }
    }
  }
  
  //modify -> force return to base even if not idle
  initIterateGroup(repairGroup);
  droid = iterateGroup(repairGroup);
  while(droid != NULLOBJECT)
  {
    if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) > nBaseRange+5*TILE ) {
      orderDroid(droid, DORDER_RTB);
    }
    droid = iterateGroup(repairGroup);
  }
  
  //As last chance let`s try to completely repair defend idle droids
  if (boolResult and !alertIsOn){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(tankDefGroup, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nDefendRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }
  if (boolResult and !alertIsOn){
    droid2 = idleRepairDroid(baseX,baseY);
    if ( droid2 != NULLOBJECT )
    {
      droid = nearestDroidToBeRepaired(cyborgDefGroup, droid2.x, droid2.y);
      if ( droid != NULLOBJECT){
        if  ( distBetweenTwoPoints( droid.x, droid.y, baseX, baseY) < nDefendRange ) {
         orderDroidObj(droid2, DORDER_DROIDREPAIR, droid);
         boolResult = false;
        }
      }
    }
  }

}

// =====================================================================
event updateBaseDetails(inactive) 
{
  local int _nTotFact,_nFact1Module,_nFact2Module;
  eventCheckTime[8] = gameTime;

  updateBaseRange();
  updateBaseCoord();
	updateBeacons();
  
  //get all players base coordinates
  updatePlCoord();
  
  //get all players stats
  updatePlayersStats();

  //check factories upgrade
  initEnumStruct(false,factory,player,player);
  structure= enumStruct();
  while(structure != NULLOBJECT)
  {
    _nTotFact++;
  	if( structureComplete(structure) ){
  		if( skGetFactoryCapacity(structure) > 0 ){
  		  _nFact1Module++;
  		}
  		if( skGetFactoryCapacity(structure) > 1 ){
  		  _nFact2Module++;
  		}
  	}
  	structure= enumStruct();
  }
  if ( _nFact1Module == _nTotFact ){ bFactUpgraded1Module = true;  }
  if ( _nFact2Module == _nTotFact ){ bFactUpgraded2Modules = true;  }

  //check heavy body and track prop
  if ( !bDyDoHasHeavyBody ){
  if ( researchFinished(trackPropulsion, player) or researchFinished(phytonBody, player) or researchFinished(mantisBody, player) or researchFinished(vengeanceBody, player) or researchFinished(wyvernBody, player))
  {
    bDyDoHasHeavyBody = true;
  }
  }

	//units to attack with tanks
  if ( tChangeTimeTankToAdd == 0 ){ tChangeTimeTankToAdd = tLastTankAttack; }
  if ( gameTime - tChangeTimeTankToAdd > TIME_CHANGE_TANKSTOADD ){
    nAttackingUnitsToAdd  = random(MAX_ATTACK_TANKS_ADD);
    nCybAttUnitsToAdd     = random(MAX_ATTACK_CYBORG_ADD);
    tChangeTimeTankToAdd = gameTime;
  }

  
	//store the oliRes to get at the beginning
  if( nTotOilInAtStart < nFreeOilRes ){
    nTotOilInAtStart = nFreeOilRes;
  }
    
  updateDefendRange();
  //estimate the range for the gateways and the defend range
  if ( nDefendRange > 0 ){
    gatewaysRangeTiles  = nDefendRange/TILE;
  } else {
    if ( max(mapWidth,mapHeight) <= 92 ){
      gatewaysRangeTiles  = 22;
    } else if ( max(mapWidth,mapHeight) > 92 and max(mapWidth,mapHeight) <= 105 ){
      gatewaysRangeTiles  = 28;
    } else if ( max(mapWidth,mapHeight) > 105 and max(mapWidth,mapHeight) <= 128 ){
      gatewaysRangeTiles  = 36;
    } else {
      gatewaysRangeTiles  = 40;
    }
  }

  //checking if I have min numb of derricks;
  if ( nPlayersInGame > 1 and nTotOilInAtStart > 0 ){
    if ( nMyDerricks-nDerricksAtStart < nTotOilInAtStart/nPlayersInGame ){
      bNeedDerrick = true;
    } else {
      bNeedDerrick = false;
    }
  }

	//build defense queue
	count = 0;
	pickDefQueueDepth = 0;
	while(count < numDefStructs )
	{
		if(isStructureAvailable(defStructs[count],player)){
			pickDefQueue[pickDefQueueDepth] = defStructs[count];
			pickDefQueueDepth = pickDefQueueDepth + 1;
		}
		count = count + 1;
	}

	//build wall defense queue
	count = 0;
	pickWallDefQueueDepth = 0;
	while( count < numWallWeaps )
	{
		if( isStructureAvailable(wallWeaps[count],player) ){
			pickWallDefQueue[pickWallDefQueueDepth] = wallWeaps[count];
			pickWallDefQueueDepth = pickWallDefQueueDepth + 1;
		}
		count = count + 1;
	}

	//Fortresses queue
  count = 0;
	pickFortQueueDepth = 0;
	while(count < numFortressDef)
	{
		if(isStructureAvailable(fortressDef[count],player) ){
			pickFortQueue[pickFortQueueDepth] = fortressDef[count];
			pickFortQueueDepth = pickFortQueueDepth + 1;
		}
		count = count + 1;
	}

  //update structs queue
	count = 0;
	pickStrQueueDepth = 0;
	while(count < numStructs)
	{
		if(isStructureAvailable(structs[count],player) )
		{
			pickStrQueue[pickStrQueueDepth] = structs[count];
			pickStrQueueDepth = pickStrQueueDepth + 1;
		}
		count = count + 1;
	}


}

//-----------------------------------------------------------------
event buildRepFirst(inactive)
{

  eventCheckTime[9] = gameTime;
	
  if( lStopBuildRepFacility )	{exit;}
  
  //check on quantity and avoid multiple contruction at time, build max repFac - 1 to keep one
  // repFac to support attack team
	boolResult = false;
	if ( isStructureAvailable(repairFacility, player) )
  {
    //returns _nWhichCooord(x or y) such that they are _nDist distance away from _x1/_y1 direction _x2,_y2
    buildX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, nBaseRange/4 );
    buildY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, nBaseRange/4 );

		boolResult = pickStructLocation(repairFacility, ref buildX, ref buildY,player);
		if(boolResult){
			droid = closestDroidCanBuild(buildGrp,buildX,buildY);
			if(droid != NULLOBJECT)
			{
				
        if ( droidCanReach(droid, buildX, buildY) ){
          orderDroidStatsLoc(droid, DORDER_BUILD,repairFacility, buildX,buildY);
					nLastTimeBuiltRepFac = gameTime;
        } else {
				 
          count = random(3);
          if ( count == 0 ){
            buildX = baseX;
					  buildY = baseY;
          } else if ( count == 1 ){
            buildX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, nBaseRange/2 );
            buildY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, nBaseRange/2 );
          } else if ( count == 2 ){
            buildX = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 1, (nBaseRange/3)*2 );
            buildY = getCoordRelated(baseX, baseY, mapWidth*TILE/2, mapHeight*TILE/2, 2, (nBaseRange/3)*2 );
          } 
  				
          boolResult = pickStructLocation(repairFacility, ref buildX, ref buildY,player);
  				if(boolResult){
  					droid = closestDroidCanBuild(buildGrp,buildX,buildY);
  					if(droid != NULLOBJECT)
  					{
  						if ( droidCanReach(droid, buildX, buildY) ){
                orderDroidStatsLoc(droid, DORDER_BUILD,repairFacility, buildX,buildY);
    						nLastTimeBuiltRepFac = gameTime;
    					}
    				}
    			}

        }
			}
		}
	}
	  		
}


//====================================ADVANCED HARVESTER SCRIPT==========================
event harvesterOperate(inactive)
{
  eventCheckTime[10] = gameTime;
  
  if ( !bOilResLeft ){ exit; }

  //stop moving to oilRes if a derrick is already built in that position or if a threat is present
  stopDroidHarvesting();

  _oilRes     = NULLOBJECT;
  
  //reset if necessary oilResTargetId, oilResTargetX, oilResTargetY
  checkDerrickIsBuilt(player);
  
  //nearest oilRes to base, try to pick up the nearest to the base as it is 
  //the easier to defend.
  droid = closestIdleDroid(harvesterGroup,baseX, baseY);
  if( droid != NULLOBJECT )
  {
    _oilRes = closestOilRes(droid, droid.x, droid.y);//uses droidCanReach  
  } 
  //get the number of Derricks built
  if ( _oilRes != NULLOBJECT )
  {
    //displayMsg("harvesterOperate: oilRes found");
    if ( nMyDerricks < numMaxDerricks  ) 
    {
      //to avoid another droid target this oliRes
     if( gameTime < TIME_HARVESTING_PHASE ){
      
        _nOilRes = getOilResTargetFree();
        if ( _nOilRes > -1 and droidCanReach(droid, _oilRes.x, _oilRes.y) ){
          oilResTargetId[_nOilRes]  = _oilRes.id; 
    		  oilResTargetX[_nOilRes]   = _oilRes.x;
    		  oilResTargetY[_nOilRes]   = _oilRes.y;
          orderDroidStatsLoc( droid, DORDER_BUILD, derrick, _oilRes.x, _oilRes.y);
        } 
      
      } else {//============= HARVEST WITHOUT CHECKING oliRes TARGET 
      
        if ( droidCanReach(droid, _oilRes.x, _oilRes.y) )
        { 
          orderDroidStatsLoc( droid, DORDER_BUILD, derrick, _oilRes.x, _oilRes.y);
        } 
      }
    }
  } 
}
  

//======================================================================
event truckGroupSlider(inactive)
{
    
  local DROID _droid;//,_droidIdle;
  //local FEATURE _oilRes;
    
  eventCheckTime[11] = gameTime;
  
  
  
  //at this time the harvesting phase should be finished
  if ( gameTime > TIME_HARVESTING_PHASE ){
    
    //harvester are not required, move them to buildGRP and buildDefGRP
    if ( !bOilResLeft ){
       
      initIterateGroup(harvesterGroup);
      _droid = iterateGroup(harvesterGroup);
  		while(_droid != NULLOBJECT)
  		{
        if ( buildGrp.members > buildDefGrp.members ){
  		   groupAddDroid(buildDefGrp, _droid );
        } else {
   			 groupAddDroid(buildGrp, _droid );
        }
        _droid = iterateGroup(harvesterGroup);
  		}
      
    } else {
    
      if ( harvesterGroup.members ==  0 ){
        if ( buildGrp.members > buildDefGrp.members ){
        
          _droid = closestIdleDroid(buildGrp,baseX,baseY);
          if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildGrp,baseX,baseY); }
          if (_droid == NULLOBJECT){ _droid = getADroid(buildGrp); }
      		if (_droid != NULLOBJECT){
    		   groupAddDroid(harvesterGroup, _droid );
          }
        
        } else {
        
          if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildDefGrp,baseX, baseY); }
          if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY); }
          if (_droid == NULLOBJECT){ _droid = getADroid(buildDefGrp); }
      		if (_droid != NULLOBJECT){
    		    groupAddDroid(harvesterGroup, _droid );
          }
        }
      }
    }
    
  } else {//initial phase, keep at least 2 harvester trucks, 2 buildGrp and 1 defGrp
    
    if ( bOilResLeft ){
      
      if ( harvesterGroup.members < 2 ){
        if ( buildDefGrp.members >= 1 ){
           if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildDefGrp,baseX,baseY); }
           if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY); }
           if (_droid == NULLOBJECT){ _droid = getADroid(buildDefGrp); }
       		 if (_droid != NULLOBJECT){
    		     groupAddDroid(harvesterGroup, _droid );
    		   }
        }
      }
      if ( harvesterGroup.members < 2 ){
        if ( buildGrp.members > 2 ){
           if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildGrp,baseX,baseY); }
           if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildGrp,baseX,baseY); }
           if (_droid == NULLOBJECT){ _droid = getADroid(buildGrp); }
       		 if (_droid != NULLOBJECT){
    		     groupAddDroid(harvesterGroup, _droid );
    		   }
        }
      }
    
    } else {
    
      if ( harvesterGroup.members > 0 ){
        initIterateGroup(harvesterGroup);
        _droid = iterateGroup(harvesterGroup);
    		while(_droid != NULLOBJECT)
    		{
          if ( buildGrp.members > buildDefGrp.members ){
    		    groupAddDroid(buildDefGrp, _droid );
          } else {
     			  groupAddDroid(buildGrp, _droid );
          }
          _droid = iterateGroup(harvesterGroup);
    		}
      }
    }
  
  }//gametime > TIME_HARVESTING_PHASE

  //ensure a bit of balance between buildGrp and buildDef GRP
  // but only after 30 secs because I want two trucks in buildGrps a the very start
  if ( gameTime > 2*TIME_MINUTE ){
    
    if ( !lMinBaseStructBuilt ){
      
      if ( buildDefGrp.members > buildGrp.members ){
        if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildDefGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = getADroid(buildDefGrp); }
    		if (_droid != NULLOBJECT){
    	   groupAddDroid(buildGrp, _droid );
        }
      }
    
      if ( buildGrp.members > buildDefGrp.members+1 ){
        if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = getADroid(buildGrp); }
    		if (_droid != NULLOBJECT){
    	   groupAddDroid(buildDefGrp, _droid );
        }
      }
    
    } else {//need more def trucks
      
      if ( buildGrp.members > buildDefGrp.members ){
        if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = getADroid(buildGrp); }
    		if (_droid != NULLOBJECT){
    	   groupAddDroid(buildDefGrp, _droid );
        }
      }
    
      if ( buildDefGrp.members > buildGrp.members+1 ){
        if (_droid == NULLOBJECT){ _droid = closestIdleDroid(buildDefGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY); }
        if (_droid == NULLOBJECT){ _droid = getADroid(buildDefGrp); }
    		if (_droid != NULLOBJECT){
    	   groupAddDroid(buildGrp, _droid );
        }
      }
    
    }
  }
  
  //displayMsg("truckGroupSlider 2: b("& buildGrp.members &") d("& buildDefGrp.members  &") h("& harvesterGroup.members  &") "); 
       
}

// ==========================================================================
event upgradeStructures(inactive)
{
  eventCheckTime[16] = gameTime;

  droid = closestDroidCanBuild(buildGrp,baseX,baseY);
	if ( nMapPower > VERY_LOW_POWER_MAP){
  	if( droid == NULLOBJECT ){
  	 droid = closestIdleDroid(buildDefGrp,baseX, baseY);
    }
  }
	if(droid != NULLOBJECT)
	{
    
    boolResult = true;    
    if(!lStopPowGenUpgrade)
    { 
      initEnumStruct(false,powGen,player,player);
  		structure= enumStruct();
  		while(structure != NULLOBJECT and boolResult)
  		{
  			if( structureComplete(structure) and isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)) )
  			{
  				orderDroidStatsLoc(droid,DORDER_BUILD,powModule, structure.x,structure.y);
  				boolResult = false;
  			}
  			structure= enumStruct();
  		}
		}

    //researches
    if(!lStopResLabUpgrade and boolResult)
    { 
			initEnumStruct(false,resLab,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT and boolResult)
			{
				if( structureComplete(structure) and isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)) )
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,resModule, structure.x,structure.y);
					boolResult = false;
				}
				structure= enumStruct();
			}
    }//power check


	  //if "R-Vehicle-Body05" is not completed we do not perform the upgrade
    if ( !lStopFactUpgrade and boolResult )
    {
      initEnumStruct(false,factory,player,player);
			structure= enumStruct();
		  while(structure != NULLOBJECT and boolResult)
			{
				if( structureComplete(structure) and isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 1 ) )
				{
         orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);
				 boolResult = false;
				}
				structure= enumStruct();
			}
		  
      if ( !lStopFactUpgrade2 and boolResult )
      {
        initEnumStruct(false,factory,player,player);
  			structure= enumStruct();
  			while(structure != NULLOBJECT and boolResult)
  			{
  				if( structureComplete(structure) and isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ) )
  				{
  					orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);
  					boolResult = false;
  				}
  				structure= enumStruct();
  			}
			}
			  
      initEnumStruct(false,vtolFactory,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT and boolResult)
			{
				if( structureComplete(structure) and isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ) )
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);
					boolResult = false;
				}
				structure= enumStruct();
			}

    }//if ( !lStopFactUpgrade and boolResult )
		  
	} 
}

//===========================================================================
event droidBuilt(droidBuiltTr) //  (CALL_NEWDROID,player, ref droid,ref structure);
{
  if(droid != NULLOBJECT){                
    if ( droid.player != player ){ exit; }
    assignDroidToGrp(droid);
  }
}

// ================== UNITS RESORTING SCRIPT ==========================
event reSortUnits(inactive)
{
	
  local DROID _droid;

  groupAddAreaNoGroup(xGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
	initIterateGroup(xGroup);
	_droid = iterateGroup(xGroup);
	while(_droid != NULLOBJECT)
	{
    assignDroidToGrp(_droid);
    _droid = iterateGroup(xGroup);
  }  
  
  groupAddAreaNoGroup(xGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
  if ( xGroup.members > 0 ){ 
    printDebug1("#### reSortUnits; resort has left ("& xGroup.members &") units in no groups "); 
  } else { 
    printDebug1("reSortUnits; was successful ("& xGroup.members &")"); 
  }
  setEventTrigger(reSortUnits,inactive);
  
}

// =============================================================================
event SelectTankTemplate(inactive)
{

	local int _nWeaponType, _nRnd, _nRnd2,_nBestHvyBody,_nBestMedBody,_nBestLghBody;
  local bool _bProceed,_bbuildBB;
  
  eventCheckTime[17] = gameTime;

  if ( getDroidCount(player) >= MAX_DROIDS ){ exit; }
  if ( nWorkingFact == nFactories ){ exit; }
    
  _bProceed = true; _bbuildBB = false;
  
	//build trucks
  if ( gameTime > TIME_HARVESTING_PHASE and (numTemplatesInProduction(constructor2,player) > 0 or numTemplatesInProduction(constructor,player) > 0) ){
    lStopBuildTankProd = true;
  }
  if (!lStopBuildTankProd ){
    initEnumStruct(false,factory,player,player);
		structure = enumStruct();
    while(structure != NULLOBJECT and _bProceed)
		{     
 			if(structureComplete(structure) and structureIdle(structure)){
        if ( skCanBuildTemplate(player,structure, constructor2) ){
          buildDroid(constructor2, structure, player, 1); // can harvest on islands!
        } else {
          buildDroid(constructor, structure, player, 1); // build tank wheeled constructor
        }
        lastTruckBuilt = gameTime;     
  	    _bProceed = false;
	    }	                      
      structure = enumStruct();
    }    
  }
  
  //repair Truck 
  _bProceed = true;
  if ( !lForceUnitsProduciton and repairGroup.members+numTemplatesInProduction(repairTank,player)+numTemplatesInProduction(repairTank,player)+numTemplatesInProduction(cybMech,player) < MAX_REPAIR_UNITS ){
  if ( getStructure(repairFacility,player) == NULLOBJECT ){
  if ( gameTime > TIME_HARVESTING_PHASE ){
    initEnumStruct(false,factory,player,player);
  	structure = enumStruct();
    while(structure != NULLOBJECT and _bProceed)
  	{     
  		if(structureComplete(structure) and structureIdle(structure)){
				if( skCanBuildTemplate(player,structure, repairTank) ){
		  		_bProceed = false;
				  buildDroid(repairTank, structure, player, 1); // build tank repair
				  lastTimeRepairBuilt = gameTime;//avoid multipe builds in high power
				}
      }
      structure = enumStruct();
    }
  }
  }
  }
  
  //do not build any other type of tanks for cyborgAI
  if ( AIPersonality == AI_CYBORG ){ exit; }
	

  //build tanks
  if (lStopTankProduction) {exit;}
  	
  nWeapSelection++;
  if (nWeapSelection > 1) { nWeapSelection = 0; }

  initEnumStruct(false,factory,player,player);
	structure = enumStruct();
  _bProceed = false;
  while(structure != NULLOBJECT and !_bProceed)
	{

    //displayMsg("SelectTankTemplate: structure.id("& structure.id &") _bProceed("& _bProceed &")________");
		if(structureComplete(structure) and structureIdle(structure))
		{
		
      //Is BB required?
      if( bPlayWithBB and skCanBuildTemplate( player , structure , CobraHoverBB) ){
        if ( nTotTanks + nTotCyborgs > 10 ){
          if ( gameTime - tLastBBbuilt > 10*TIME_MINUTE ){
            buildDroid( CobraHoverBB , structure, player, 1);
            tLastBBbuilt = gameTime;
          }
        }
      }
      
      //Flamers and Rockets
      if (  nResTmplPath == RESTMPL_1 ){
      
        if ( nWeapSelection == 0 ){
          _nWeaponType = WEAPON_AT;//AntiTank
        }
        if ( nWeapSelection == 1 ){
          _nWeaponType = WEAPON_AP;//AntiPersonnel
        }
      
      } else {
        
        
        //MG and Cannons
        if (  nResTmplPath == RESTMPL_2 ){
          
          if (  nWeapSelection == 0 ){
            _nWeaponType = WEAPON_AP;//AntiPersonnel
          }
          if (  nWeapSelection == 1  ){
            _nWeaponType = WEAPON_AR;//AllRounder
          }
        
        } else {
        
          //standard research
          _nRnd  = random(100);//weapon type (WEAPON_AR/AT/AP)
          if ( _nRnd < 30 ){
            _nWeaponType = WEAPON_AR;//AllRounder
          }
          if ( _nRnd >= 30 and _nRnd < 65 ){
            _nWeaponType = WEAPON_AT;//AntiTank
          }
          if ( _nRnd >= 65 and _nRnd < 100 ){
            _nWeaponType = WEAPON_AP;//AntiPersonnel
          }
        }
      }

      //check if in 1vs1 games the human players has mainly cyborgs or tanks
      //printDebug1("SelectTankTemplate: nEnemyPlayers("& nEnemyPlayers &") nAPTankBuilt("& nAPTankBuilt &") cyb("& aStat[OC_CYBORGS][nLastEnemyPlayer] &") tk("& aStat[OC_TANKS][nLastEnemyPlayer] &")");
      if ( nEnemyPlayers == 1 ){
        if ( aStat[OC_CYBORGS][nLastEnemyPlayer] + aStat[OC_TANKS][nLastEnemyPlayer] > 5 )
        {
          if ( aStat[OC_CYBORGS][nLastEnemyPlayer] > aStat[OC_TANKS][nLastEnemyPlayer]*3 )
          {
            if ( nAPTankBuilt < 3){
              //printDebug1("SelectTankTemplate: force building of AntiPersonnel weapon nAPTankBuilt("& nAPTankBuilt &") ");
              _nWeaponType = WEAPON_AP;//build AntiPersonnel weapon
              nAPTankBuilt++;
              //if no tanks at all (Cyborg AI??) build even more anti cyborgs
              if ( aStat[OC_TANKS][nLastEnemyPlayer] == 0 ){
                nAPTankBuilt = 0;
              }
            } else {//build default weapon
               //printDebug1("SelectTankTemplate: building default template nAPTankBuilt("& nAPTankBuilt &") ");
               nAPTankBuilt = 0;
            }
          }
          if ( aStat[OC_TANKS][nLastEnemyPlayer] > aStat[OC_CYBORGS][nLastEnemyPlayer]*3 )
          {
            if (  nResTmplPath == RESTMPL_2 ){ //Gunners, Cannons
              //printDebug1("SelectTankTemplate: force building of All Rounder weapon");
              _nWeaponType = WEAPON_AR;//build All Rounder, DyDo does not research AT weapons
            } else { //Flamers, Rockets or ALL weapons
              //printDebug1("SelectTankTemplate: force building of Anti Tank weapon");
              _nWeaponType = WEAPON_AT;//build AntiTank weapon
            }
          }
        }
      }

      if ( nResTmplPath == RESTMPL_1 ){
        _nBestHvyBody  = checkBestBody1(BODY_HEAVY,_nWeaponType,structure);//heavy 
        _nBestMedBody  = checkBestBody1(BODY_MEDIUM,_nWeaponType,structure);//medium 
        _nBestLghBody  = checkBestBody1(BODY_LIGHT,_nWeaponType,structure);//light
      } else {
        if ( nResTmplPath == RESTMPL_2 ){
          _nBestHvyBody  = checkBestBody2(BODY_HEAVY,_nWeaponType,structure);//heavy 
          _nBestMedBody  = checkBestBody2(BODY_MEDIUM,_nWeaponType,structure);//medium 
          _nBestLghBody  = checkBestBody2(BODY_LIGHT,_nWeaponType,structure);//light
        } else {
          _nBestHvyBody  = checkBestBody(BODY_HEAVY,_nWeaponType,structure);//heavy 
          _nBestMedBody  = checkBestBody(BODY_MEDIUM,_nWeaponType,structure);//medium 
          _nBestLghBody  = checkBestBody(BODY_LIGHT,_nWeaponType,structure);//light
        }
      } 
     
 
      if ( _nBestHvyBody == 0 and _nBestMedBody == 0 and _nBestLghBody == 0){
        //dbg("#### SelectTankTemplate; cannot build anything with nWeapSel("& nWeapSelection &") _nWeap("& _nWeaponType &")(0=AR,1=AT,2=AP); bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")",player); 
        printDebug1("#### SelectTankTemplate; cannot build anything with nWeapSel("& nWeapSelection &") _nWeap("& _nWeaponType &")(0=AR,1=AT,2=AP); bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")"); 
        exit;
      }

      _nRnd2 = random(100);//body type      
 
      if ( bDyDoHasHeavyBody ){  //this avoides that DyDo builds light tanks even if heavy bodies are available
        
        if ( _nBestHvyBody > 0 ){
          //If Heavy and Medium are availabe
          if ( _nBestMedBody > 0 ){
            if ( _nRnd2 < 70 ){ //build Heavy Tank
              if ( nResTmplPath == RESTMPL_1 ){
                _bProceed = buildHeavyTank1(_nWeaponType,structure);
              } else {
                if ( nResTmplPath == RESTMPL_2 ){
                  _bProceed = buildHeavyTank2(_nWeaponType,structure);
                } else {
                  _bProceed = buildHeavyTank(_nWeaponType,structure);
                }
              }
            } else {//build Medium Tank
              if ( nResTmplPath == RESTMPL_1 ){
                _bProceed = buildMediumTank1(_nWeaponType,structure);
              } else {
                if ( nResTmplPath == RESTMPL_2 ){
                  _bProceed = buildMediumTank2(_nWeaponType,structure);
                } else {
                  _bProceed = buildMediumTank(_nWeaponType,structure);
                }
              }
            }
          } else { //build Heavy Tank
            if ( nResTmplPath == RESTMPL_1 ){
             _bProceed = buildHeavyTank1(_nWeaponType,structure);
            } else {
              if ( nResTmplPath == RESTMPL_2 ){
                _bProceed = buildHeavyTank2(_nWeaponType,structure);
              } else {
                _bProceed = buildHeavyTank(_nWeaponType,structure);
              }
            }
          }
        } else { //No heavy Body available, build medium body
          if ( _nBestMedBody > 0 ){
            if ( nResTmplPath == RESTMPL_1 ){
              _bProceed = buildMediumTank1(_nWeaponType,structure);
            } else {
              if ( nResTmplPath == RESTMPL_2 ){
                _bProceed = buildMediumTank2(_nWeaponType,structure);
              } else {
                _bProceed = buildMediumTank(_nWeaponType,structure);
              }
            }
          } else {
            printDebug1("#### SelectTankTemplate; not able to build any HEAVY or MEDIUM tank tmpl with weapon=("& _nWeaponType &")(0=AR,1=AT,2=AP) try to build light tank");
          }
        }

      } else { //medium and light body only

        //Medium and Light are availabe
        if (_nBestMedBody > 0 ){
          if (_nBestLghBody > 0 ){
            if ( _nRnd2 < 70 ){
              if ( nResTmplPath == RESTMPL_1 ){
                _bProceed = buildMediumTank1(_nWeaponType,structure);
              } else {
                if ( nResTmplPath == RESTMPL_2 ){
                  _bProceed = buildMediumTank2(_nWeaponType,structure);
                } else {
                  _bProceed = buildMediumTank(_nWeaponType,structure);
                }
              }
            } else {
              if ( nResTmplPath == RESTMPL_1 ){
               _bProceed = buildLightTank1(_nWeaponType,structure);
              } else {
                if ( nResTmplPath == RESTMPL_2 ){
                  _bProceed = buildLightTank2(_nWeaponType,structure);
                } else {
                  _bProceed = buildLightTank(_nWeaponType,structure);
                }
              }
            }
          } else {  //only medium bodies available
            if ( nResTmplPath == RESTMPL_1 ){
              _bProceed = buildMediumTank1(_nWeaponType,structure);
            } else {
              if ( nResTmplPath == RESTMPL_2 ){
               _bProceed = buildMediumTank2(_nWeaponType,structure);
              } else {
               _bProceed = buildMediumTank(_nWeaponType,structure);
              }
            }
          }
        }
      
      } //end else ( //medium and light body only)

      //Only Light is availabe or was not able to build any medium/heavy template
      if ( !_bProceed ){
          if ( nResTmplPath == RESTMPL_1 ){
            _bProceed = buildLightTank1(_nWeaponType,structure);
          } else {
            if ( nResTmplPath == RESTMPL_2 ){
              _bProceed = buildLightTank2(_nWeaponType,structure);
            } else {
              _bProceed = buildLightTank(_nWeaponType,structure);
            }
          }
      }
      if ( !_bProceed ){
        printDebug1("#### SelectTankTemplate; not able to build any tank with weapon=("& _nWeaponType &")(0=AR,1=AT,2=AP)");              
      } 
      

    }//endif(structureComplete(structure) and structureIdle(structure))

	  structure = enumStruct();
  }//end while
  
  
}


//=========================================================================
event SelectCyborgTemplate(inactive)
{
		
  local TEMPLATE cybTmpl[17];
  local int _nRnd, _pos;
  local bool _bBuildAR_cyborg, _bBuildAT_cyborg, _bBuildAP_cyborg, _bBuildKK_cyborg;
  
  eventCheckTime[18] = gameTime;
  //displayMsg("*** SelectCyborgTemplate: ___________ CALLED lStopCybProduction("& lStopCybProduction &") droids tot("& getDroidCount(player) &"/"& MAX_DROIDS &")___________");
  
  _pos = -1;
  _bBuildAR_cyborg = false;//AllRounder
  _bBuildAT_cyborg = false; //AntiTank
  _bBuildAP_cyborg = false; //AntiPersonnel
  _bBuildKK_cyborg = false; //Kinetic (Grenadier-NeedleGunner)
  
  if( getDroidCount(player) >= MAX_DROIDS ){ exit; }
  
  //force production of attacking cyborgs if earlyAttack event is active;
  if ( nEarlyAttack >= nDroidsEarlyAtt){
    bEarlyAttack = false;
  }
  if (bEarlyAttack){
    lStopCybProduction = false;
    lStopCybEngProd    = true;
  }  
  
  //repair cyborgs 
  if ( AIPersonality == AI_CYBORG ){
  if ( getStructure(repairFacility,player) == NULLOBJECT ){
    if ( repairGroup.members+numTemplatesInProduction(cybMech,player) < MAX_REPAIR_UNITS ){
      initEnumStruct(false,cybFactory,player,player);
    	structure = enumStruct();
      boolResult = true;
      while(structure != NULLOBJECT and boolResult)
    	{     
    		if(structureComplete(structure) and structureIdle(structure)){
  				if( skCanBuildTemplate(player,structure, cybMech) ){
  		  		boolResult = false;
  				  buildDroid(cybMech, structure, player, 1); // build cyb repair
  				}
        }
        structure = enumStruct();
      }
    }
  }
  }

  if( lStopCybProduction and lStopCybEngProd ){ exit; }

  nWeapCybSelection++;
  if (nWeapCybSelection > 2) { nWeapCybSelection = 0; }
  
  //we prioritize a bit cybGren to ensure some arty is build
  if ( nWeapCybSelection == 0 and random(100) < 30 ) { 
    nWeapCybSelection = 2;//cybGren
  }  
  
	initEnumStruct(false,cybFactory,player,player);
	structure = enumStruct();
	boolResult = true;
	while(structure != NULLOBJECT and boolResult)
	{
		if( structureComplete(structure) and structureIdle(structure) ){
				         
      boolResult  = true;
			
      // build cyborg constructor
      if( !lStopCybEngProd ){
			  boolResult       = false;
			  lastCybEngBuilt  = gameTime;
				buildDroid(cybcondroid, structure, player, 1); 
				//displayMsg("*** SelectCyborgTemplate: Building Constructor Droid power("& playerPower(player) &")");
			}

      //build cyborg Mechanic
      /*
      if ( nCybMechanic < 3 and (gameTime - tLastCybMech > 2*TIME_MINUTE) ){
        tLastCybMech = gameTime;
        nCybMechanic++;
				buildDroid(cybMech, structure, player, 1); 
      }
      */
      
      if( boolResult ){
        
        count = 0;
        while ( _pos == -1 and count < 20 )
        {
          
          if ( nResTmplPath == RESTMPL_1 ){
            if ( nWeapCybSelection == 0 ){
                _bBuildAT_cyborg = true; //AntiTank 33%
                nTotCybAT++;                
            } else if ( nWeapCybSelection == 1 ){
                _bBuildAP_cyborg = true; //AntiPersonnel 33%
                nTotCybAP++;                
            } else if ( nWeapCybSelection == 2 ){
                _bBuildKK_cyborg = true; //Kinetic 33%
                nTotCybKK++;                
            }
          
          } else {
          
            if ( nResTmplPath == RESTMPL_2 ){
              if ( nWeapCybSelection == 0 ){
                  _bBuildAR_cyborg = true; //Allrounder 40%
                  nTotCybAR++;                
              } else if ( nWeapCybSelection == 1 ){
                  _bBuildAP_cyborg = true; //AntiPersonnel 40%
                  nTotCybAP++;                
              } else if ( nWeapCybSelection == 2 ){
                  _bBuildKK_cyborg = true; //Kinetic 20%
                  nTotCybKK++;                
              }
            
            } else {
              
              _nRnd = random(100);
              if ( _nRnd < 30 ){
                  _bBuildAR_cyborg = true;//Allrounder
                  nTotCybAR++;                
              } else if ( _nRnd >= 30 and _nRnd < 55 ){
                  _bBuildAT_cyborg = true; //AntiTank
                  nTotCybAT++;                
              } else if ( _nRnd >= 55 and _nRnd < 80 ){
                  _bBuildAP_cyborg = true; //AntiPersonnel
                  nTotCybAP++;                
              } else {
                  _bBuildKK_cyborg = true; //Kinetic
                  nTotCybKK++;                
              }
            }
            
          }
          
          //check if in 1vs1 games the human players has mainly cyborgs or tanks
          //printDebug1("SelectCybTemplate: nEnemyPlayers("& nEnemyPlayers &") cyb("& aStat[OC_CYBORGS][nLastEnemyPlayer] &") tk("& aStat[OC_TANKS][nLastEnemyPlayer] &")");
          if ( nEnemyPlayers == 1 ){
            if ( aStat[OC_CYBORGS][nLastEnemyPlayer] + aStat[OC_TANKS][nLastEnemyPlayer] > 8 ){
              if ( aStat[OC_CYBORGS][nLastEnemyPlayer] > aStat[OC_TANKS][nLastEnemyPlayer]*3 )
              {
                if ( nAPCyborgBuilt < 3 ){
                  //printDebug1("SelectCybTemplate: force building of AntiPersonnel weapon nAPCyborgBuilt("& nAPCyborgBuilt &") ");
                  _bBuildAR_cyborg = false;//AllRounder
                  _bBuildAT_cyborg = false; //AntiTank
                  _bBuildAP_cyborg = true; //AntiPersonnel
                  _bBuildKK_cyborg = false; //Kinetic (Grenadier-NeedleGunner)
                  nAPCyborgBuilt++;
                } else { //let default settings
                  nAPCyborgBuilt = 0;
                }
              }
              //if not AT can be built, then AR will be built, see a bit below...
              if ( aStat[OC_TANKS][nLastEnemyPlayer] > aStat[OC_CYBORGS][nLastEnemyPlayer]*3 )
              {
                 if ( nResTmplPath != RESTMPL_1 ){ //Flamers, Rockets or ALL weapons
                     //printDebug1("SelectCybTemplate: force building of AntiTank weapon");
                    _bBuildAT_cyborg = true; //AntiTank
                    _bBuildAR_cyborg = false; //AllRounder
                 } else {//Gunners, Cannons or ALL WEAPONS
                    //printDebug1("SelectCybTemplate: force building of Grenadier weapon");
                    _bBuildAT_cyborg = false; //AntiTank
                    _bBuildAR_cyborg = true; //AllRounder
                 }
                _bBuildKK_cyborg = false;  //Kinetic (Grenadier-NeedleGunner)
                _bBuildAP_cyborg = false; //AntiPersonnel
              }
            }
          }
          
          //Build best Anti-Tank Template            
          if ( _bBuildAT_cyborg ){
            if( skCanBuildTemplate(player,structure, superCyb[9]) ){ _pos = 9; }//Lancer
            if( skCanBuildTemplate(player,structure, superCyb[7]) ){ _pos = 7; }//Scourge
            if ( random(10) < 5 ){
              if( skCanBuildTemplate(player,structure, superCyb[3]) ){ _pos = 3; }//Super Tank-Killer Cyborg 
            } else {
              if( skCanBuildTemplate(player,structure, superCyb[0]) ){ 
                _pos = 0;//Super Scourge Cyborg 
              } else {
                //backup
                if( skCanBuildTemplate(player,structure, superCyb[3]) ){ 
                  _pos = 3; //Super Tank-Killer Cyborg
                }  
              }
            }
          }
          
          //Build best All-Rounder Template also if not AT template found 
          if ( _bBuildAR_cyborg or (_bBuildAT_cyborg and _pos == -1)) {
            if( skCanBuildTemplate(player,structure, superCyb[6]) ){ _pos = 6; }
            if( skCanBuildTemplate(player,structure, superCyb[5]) ){ _pos = 5; }
            if( skCanBuildTemplate(player,structure, superCyb[4]) ){ _pos = 4; }
            if( skCanBuildTemplate(player,structure, superCyb[1]) ){ _pos = 1; }
          }
          
          //Build best Anti-Personnel Template also if not AT/AR template found            
          if ( nResTmplPath == RESTMPL_1 ){
            if ( _bBuildAP_cyborg or _pos == -1 ){
              if ( random(100) < 65 ){//100% Flamers-Lasers
                if( skCanBuildTemplate(player,structure, superCyb[15]) ){ _pos = 15; }
                if( skCanBuildTemplate(player,structure, superCyb[12]) ){ _pos = 12; }
                if( skCanBuildTemplate(player,structure, superCyb[10]) ){ _pos = 10; }
                if( skCanBuildTemplate(player,structure, superCyb[2] ) ){ _pos = 2; }
              }
            }
          } else { 
            if ( nResTmplPath == RESTMPL_2 ){
              if ( _bBuildAP_cyborg or _pos == -1 ){
                if ( random(100) < 65 ){//100% gunners - Lasers
                  if( skCanBuildTemplate(player,structure, superCyb[16]) ) { _pos = 16; }
                  if( skCanBuildTemplate(player,structure, superCyb[14]) ) { _pos = 14; }
                  if( skCanBuildTemplate(player,structure, superCyb[11]) ) { _pos = 11; }
                  if( skCanBuildTemplate(player,structure, superCyb[10] ) ){ _pos = 10; }
                  if( skCanBuildTemplate(player,structure, superCyb[2] ) ) { _pos = 2; }
                }
              }
            } else { //standard research path!!
              if ( _bBuildAP_cyborg or _pos == -1 ){
                if ( random(100) < 65 ){//65% Flamers-Lasers
                  if( skCanBuildTemplate(player,structure, superCyb[15]) ){ _pos = 15; }
                  if( skCanBuildTemplate(player,structure, superCyb[12]) ){ _pos = 12; }
                  if( skCanBuildTemplate(player,structure, superCyb[10]) ){ _pos = 10; }
                  if( skCanBuildTemplate(player,structure, superCyb[2] ) ){ _pos = 2; }
                } else { //35% Gunners
                  if( skCanBuildTemplate(player,structure, superCyb[16]) ){ _pos = 16; }
                  if( skCanBuildTemplate(player,structure, superCyb[14]) ){ _pos = 14; }
                  if( skCanBuildTemplate(player,structure, superCyb[11]) ){ _pos = 11; }
                }
              }
            }
          }

          //Build best Kinetic Template also if not AT/AR/AP template found           
          if ( _bBuildKK_cyborg or _pos == -1 ){
            if( skCanBuildTemplate(player,structure, superCyb[13]) ){ _pos = 13; }
            if( skCanBuildTemplate(player,structure, superCyb[8] ) ){ _pos = 8; }
          }
          count++;
        } //endwhile

        if ( _pos == -1 ){
         //printDebug1("#### SelectCyborgTemplate; cannot build any template ["& _pos &"] ");
          nTotCybErr++;
          exit;          
        }
        if( skCanBuildTemplate(player,structure, superCyb[_pos]) )
				{
					//displayMsg("*** SelectCyborgTemplate: Building cyborg template ["& count &"]["& _pos &"] - best tmpl is ["& _nBestTmpl &"] - tot templates found ("& nCybTemplates &") ");
				  if (bEarlyAttack){ nEarlyAttack++; }
          buildDroid(superCyb[_pos],structure,player,1); //build droid
	  		  boolResult = false;
				} else {   
          printDebug1("#### SelectCyborgTemplate; (error on building template ["& _pos &"] ");          
        }
				
	    }		//end check on tankGroupMembers	
		
		}
   structure = enumStruct();
  }
	
}

// ---------------------------------------------------------
event buildRepFacSuppAttack(inactive)
{
  local int _totFacilities;
  eventCheckTime[19] = gameTime;

   exit; //need to think if this is ok
  
}
//=======================================================================
// do research
event doResearch(inactive)//doResearchTr
{
  local int _nLoopResearch;
  
  eventCheckTime[20] = gameTime;

  if ( gameTime < 10*TIME_MINUTE ){
    _nLoopResearch = 1; //33% cheap researches
  } else {
    _nLoopResearch = 2; //25% cheap researches
  }
  
  initEnumStruct(false,resLab,player,player);
	structure= enumStruct();
	count = 0;
	boolResult2 = true;
	while(structure != NULLOBJECT and boolResult2)
	{
  	
    if( structureIdle(structure) and structureComplete(structure) ){

      //Check if CybFactory needs to be researched or not!! this is the case in games with NO BASES!!
      if ( !researchFinished(cyborgFactory,player) ){
        boolResult = pursueResearch(structure,player,cyborgFactory);
        if (boolResult) {
         //printDebug1("doResearch; forcing research of Cyborg Factory");
          boolResult2 = false; tLastResearch = gameTime;
        }//execute only once
      } 
      
      //Check if MG Tower needs to be researched or not!! this is the case in games with NO BASES!!
      if ( !researchFinished(MGTower,player) and boolResult2 ){
        boolResult = pursueResearch(structure,player,MGTower);
        if (boolResult) {
         //printDebug1("doResearch; forcing research of Machine Gun Tower");
          boolResult2 = false; tLastResearch = gameTime;
        }//execute only once
      } 
      
      //Check if MHalf_Track needs to be researched or not!! this is the case in games with NO BASES!!
      if ( !researchFinished(HalftrackProp,player) and boolResult2 ){
        boolResult = pursueResearch(structure,player,HalftrackProp);
        if (boolResult) {
         //printDebug1("doResearch; forcing research of Half Track propulsion");
          boolResult2 = false; tLastResearch = gameTime;
        }//execute only once
      } 
      
      //check for AA - Hurricane!
      if ( bAttackedByVTOL and boolResult2  ){ 
        if ( !researchFinished(HurricaneAASite,player) ){
          boolResult = pursueResearch(structure,player,HurricaneAASite);
          if (boolResult) {
           //printDebug1("doResearch; forcing research of Hurricane AA Site");
            boolResult2 = false; tLastResearch = gameTime;
          }//execute only once
        } 
      }
      
      //check for AA - Whirlwind!
      if ( (bAttackedByVTOL or nT_Game >= T2_GAME) and boolResult2 and researchFinished(HurricaneAASite,player) ){ 
        if ( !researchFinished(WhirlwindAASite,player) ){
          boolResult = pursueResearch(structure,player,WhirlwindAASite);
          if (boolResult) {
           //printDebug1("doResearch; forcing research of Whirlwind AA Site");
            boolResult2 = false; tLastResearch = gameTime;
          }//execute only once
        } 
      }
      
      //Ripple Rockets & T2 games
      if ( nT_Game >= T2_GAME and gameTime > 4*TIME_MINUTE ){
        if ( mapSize() < MAP_SMALL or bEnemyIsNear ){ 
          if ( !isStructureAvailable(defRippleRockets,player) ){
            boolResult = pursueResearch(structure,player,defRippleRes);
            if (boolResult) {
             //printDebug1("doResearch; forcing research of RippleRockets AA Site");
              boolResult2 = false; tLastResearch = gameTime;
            }//execute only once
          }
        } 
      }

      //need rearmin pad for VTOL troops?
      if ( nVTOLFactories > 0 and boolResult2 ){
        if ( !isStructureAvailable(vtolPad,player) ){
          boolResult = pursueResearch(structure,player,VTOLPadRes);
          if (boolResult) {
           //printDebug1("doResearch; forced research OF VTOLPad");
            boolResult2 = false; tLastResearch = gameTime;
          }//execute only once
        } 
      }
      
      if ( !lStopResearch and boolResult2 ){
      
        //1v1 game, human player has more power and derricks are ok
      	if (bForceResPowUp){
      	  if (!researchFinished(powUpgrades3,player)){
            boolResult = pursueResearch(structure,player,powUpgrades3);
            if (boolResult) {
              boolResult2 = false; tLastResearch = gameTime;
      	     //printDebug1("doResearch; OK forcing research of POWER UPGRADES 'powUpgrades3' ");
            } 
          } else {
      		  if (!researchFinished(powUpgrades6,player)){
              boolResult = pursueResearch(structure,player,powUpgrades6);
              if (boolResult) {
                boolResult2 = false; tLastResearch = gameTime;
      	       //printDebug1("doResearch; OK forcing research of POWER UPGRADES 'powUpgrades6' ");
              } 
            }
          }
        }
        
        //Need a C(B tower) and bombard pit
        if (boolResult2 and bAttackedByMortars){
      	  //if (!researchFinished(resCBSense,player)){
            //boolResult = pursueResearch(structure,player,resCBSense);
            //if (boolResult) {
              //boolResult2 = false; tLastResearch = gameTime;
      	      //printDebug1("doResearch; attacked by long range weapon weap forcing research of CB TOWER");
            //} 
          //} else {
      		  if (!researchFinished(bombardPit,player)){
              boolResult = pursueResearch(structure,player,bombardPit);
              if (boolResult) {
                boolResult2 = false; tLastResearch = gameTime;
      	       //printDebug1("doResearch; attacked by long range weapon weap forcing research of BOMBARD");
              } 
            } else {
              //Autoloader
      		    if (!researchFinished(MortarFastLoad3,player)){
                if ( random(100) < 25 or (gameTime > 20*TIME_MINUTE and nT_Game >= T2_GAME) ){
                  boolResult = pursueResearch(structure,player,MortarFastLoad3);
                  if (boolResult) {
                    boolResult2 = false; tLastResearch = gameTime;
          	       //printDebug1("doResearch; forcing research of MortarFastLoad3 +143%");
                  } 
                }
              }
            }
          //}
        }
        
        //Need a CB tower and RippleRockets ?
        if (boolResult2 and bAttackedByLongRangeWeap){
      	  //if (!researchFinished(resCBSense,player)){
            //boolResult = pursueResearch(structure,player,resCBSense);
            //if (boolResult) {
              //boolResult2 = false; tLastResearch = gameTime;
      	      //printDebug1("doResearch; attacked by very long range weap forcing research of OF CB TOWER");
            //}
          //} else {
      		  if (!isStructureAvailable(defRippleRockets,player)){
              boolResult = pursueResearch(structure,player,defRippleRes);
              if (boolResult) {
                boolResult2 = false; tLastResearch = gameTime;
      		     //printDebug1("doResearch; attacked by very long range weap OK forcing research of RippleRockets");
              } 
            }
          //}
        }
      
        //Need Scorpion for VTOL templates?
        if (boolResult2 and !researchFinished(scorpionBody,player) and isStructureAvailable(vtolFactory , player)){
          boolResult = pursueResearch(structure,player,scorpionBody);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research to Scorpion body as VTOL struct is available");
          } 
        }
        
        //Need Scorpion for VTOL templates?
        if (boolResult2 and !researchFinished(lancerATweap,player) and isStructureAvailable(vtolFactory , player)){
          boolResult = pursueResearch(structure,player,lancerATweap);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research to Lancer AT weapon as VTOL struct is available");
          } 
        }
      
      
        //Can research Lassat?? ------------------------------------
        if ( boolResult2 and !researchFinished(Res_Lassat,player) and numResearchLeft(player, Res_Lassat) < 1 ){
         boolResult = pursueResearch(structure,player,Res_Lassat);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research of Lassat");
          } 
        }
      
        //Can research Fortresses?? ------------------------------
        if ( boolResult2 and !researchFinished(Res_SuperCannon,player) and numResearchLeft(player, Res_SuperCannon) < 2 ){
         boolResult = pursueResearch(structure,player,Res_SuperCannon);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research of Fortress: Res_SuperCannon");
          } 
        }
        if ( boolResult2 and !researchFinished(Res_SuperRocket,player) and numResearchLeft(player, Res_SuperRocket) < 2 ){
         boolResult = pursueResearch(structure,player,Res_SuperRocket);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research of Fortress: Res_SuperRocket");
          } 
        }
        if ( boolResult2 and !researchFinished(Res_SuperMissile,player) and numResearchLeft(player, Res_SuperMissile) < 2 ){
         boolResult = pursueResearch(structure,player,Res_SuperMissile);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research of Fortress: Res_SuperMissile");
          } 
        }
        if ( boolResult2 and !researchFinished(Res_MassDriver,player) and numResearchLeft(player, Res_MassDriver) < 2 ){
         boolResult = pursueResearch(structure,player,Res_MassDriver);
          if (boolResult) {
            boolResult2 = false; tLastResearch = gameTime;
           //printDebug1("doResearch; forcing research of Fortress: Res_MassDriver");
          } 
        }
        
        
        if ( boolResult2 ){
          if ( nResearchCounter <= _nLoopResearch or lStopCheapResearch ){
            // =========== perform standard researches ==============
            if ( !do_Research(structure) ){
             //printDebug1("doResearch; no standard research to pursue found, doing a random research nResCount("& nResearchCounter &")");
              skDoResearch(structure,player,1);
              tLastResearch = gameTime;
              boolResult2   = false;//execute only once
            }
          }
        }

      } //if ( !lStopResearch and boolResult2 ){
	  }//if struct not idle
    structure= enumStruct();
  } //endwhile
  

  // =========== perform cheap researches ==============
  if ( nResearchCounter > _nLoopResearch and !lStopResearch )
  {
  	count = 0;
    initEnumStruct(false,resLab,player,player);
  	structure= enumStruct();
  	while(structure != NULLOBJECT )
  	{
    	if( structureIdle(structure) and structureComplete(structure) )
    	{
  			count = do_CheapResearch(structure, 0 );
      }
  	  structure= enumStruct();
  	} 
    //No cheap Researches found, reset loop to allow research of standard techs
    if (count < 0 ){
      nResearchCounter = 0;
    }   
  }
  
  
}

//----------------------------------------------------------------
event difficultyModifier(inactive) 
{
  if ( EnableSliders == TRUE and !isHumanPlayer(player) )//this setting can be changed in the vlo file
  {
  	skDifficultyModifier(player);
  }
  else
  {
	  setEventTrigger(difficultyModifier,	inactive);
  }
}

//-----------------------------------------------------------------------------
event manageHelpTeam(inactive)
{
	
  local int _dist;
   
  eventCheckTime[29] = gameTime;
  
  //dbg("help: ("& helpGroup.members &") ("& gameTime - tGatheringHelp &")>150 ",player);
  if ( nAllyBeingHelped == -1 ){
    deactivateHelp();
    exit;
  }
       
  if ( helpGroup.members == 0 ){
    msg("Player '"& getPlayerName(player) &"' has no helping units left, stop helping player '"& getPlayerName(nAllyBeingHelped) &"'" , player, nAllyBeingHelped);
    deactivateHelp();
    exit;
  } 

  //Gathering troops!!!
  if ( gameTime - tGatheringHelp > 150 ){
    tGatheringHelp = gameTime;
    orderGroupLoc(helpGroup, DORDER_MOVE, helpGroup.x, helpGroup.y);
  } 
  if ( gameTime - tGatheringHelp < 29 ){ exit; } 

  if (haveBeacon(nAllyBeingHelped) or nHelpX > -1){

    
    if ( nHelpX == -1 or nHelpY == -1 ){
      nHelpX  = beaconX[nAllyBeingHelped];
      nHelpY  = beaconY[nAllyBeingHelped];
    }
    
    _dist = distBetweenTwoPoints(helpGroup.x, helpGroup.y,nHelpX, nHelpY);
    
    if ( _dist > TILE*12){  //move to beacon 
      
      //move to beacon
      if ( gameTime - tHelpAction > 40){
        orderGroupMoveCMD(helpGroup, nHelpX, nHelpY);
        //dbg("manageHelpTeam: player # ("& player &") - moving to beacon ("& nHelpX/TILE &"-"& nHelpY/TILE &")", player);
        tHelpAction = gameTime;
      }
    
    
    } else {  //scout to beacon    _dist < TILE*12
      
      if ( gameTime - tHelpAction > 29 and objTargetHelpTeam != NULLOBJECT ){
        //dbg("manageHelpTeam: near to beacon, droid micro manager ",player);
        droidMicroManager(helpGroup, 12*TILE, objTargetHelpTeam.x, objTargetHelpTeam.y);
        tHelpAction = gameTime;
      }
      //reset help coord, this will force searching of target next time event is called
      if ( _dist < TILE*3 and numEnemyWeapObjInRange(player, nHelpX, nHelpY, TILE*5, false, false) == 0){
        nHelpX  = -1;
        nHelpY  = -1;
      }
      
    }
  
  
  } else { //else -> do not have beacon and help coord

  
    //beacon expired, no enemy in short range...get a target
    if ( objTargetHelpTeam == NULLOBJECT ){
      //dbg("manageHelpTeam: no target",player);

      if ( objTargetHelpTeam == NULLOBJECT ){
        objTargetHelpTeam = objDroidTargetInRange(helpGroup.x,helpGroup.y,15*TILE,false);
      }
      if ( objTargetHelpTeam == NULLOBJECT ){
        objTargetHelpTeam = objStrTargetInRange(helpGroup.x,helpGroup.y,25*TILE);
      }
      
      
      if ( objTargetHelpTeam != NULLOBJECT ){

        _dist = distBetweenTwoPoints(helpGroup.x, helpGroup.y,objTargetHelpTeam.x, objTargetHelpTeam.y);
        
        if ( _dist > TILE*12){  //move to target 
          if ( gameTime - tHelpAction > 100){
            orderGroupMoveCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y);
            //dbg("manageHelpTeam: move to target",player);
            msg("manageHelpTeam: player ("& player &") - moving to new target", player, nAllyBeingHelped);
            tHelpAction = gameTime;
          }
        } else {      //scout to target
          if ( gameTime - tHelpAction > 29){
            droidMicroManager(helpGroup, 12*TILE, objTargetHelpTeam.x, objTargetHelpTeam.y);
            //orderGroupScoutCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y);
            //dbg("manageHelpTeam: droidMicroManager",player);
            tHelpAction = gameTime;
          }
        }
      
      } else {
        //deactivate help, no more enemies in Range
        msg("manageHelpTeam: No enemies in range, no beacon...let`s come back to the base", player, nAllyBeingHelped);
        deactivateHelp();
      }
    
    } else { //have a target!!!
    
      if ( gameTime - tHelpAction > 29){
        droidMicroManager(helpGroup, 12*TILE, objTargetHelpTeam.x, objTargetHelpTeam.y);
        //orderGroupScoutCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y);
        tHelpAction = gameTime;
      }
    
    }
  }
}
  
//----------------------------------------------------------------
// check if all units are assigned to a group !!!
event unitAssignationCheck( inactive )
{
  eventCheckTime[21] = gameTime;
  count  =  toBeRepairedCyborgGroup.members + cybConstGrp.members +  cyborgAttGroup.members +  cyborgDefGroup.members +   toBeRepairedTankGroup.members +   tankDefGroup.members +   tankGroup.members +    vtolGr.members +   vtolAttGr.members +   repairGroup.members +    buildDefGrp.members +   buildGrp.members + harvesterGroup.members + helpGroup.members;
  count1 =  numDroidsInArea(player, 0, 0, (mapWidth*128), (mapHeight*128));
  if( count != count1 )
	{
		dbg("dbg->unitAssignationCheck: activating reSortUnits assigned("& count &") tot("& count1 &") ",player);
		printDebug1("unitAssignationCheck; activating reSortUnits assigned("& count &") tot("& count1 &") ");
    setEventTrigger(reSortUnits,reSortUnitsTr);
	}
}
//----------------------------------------------------------------
//Identify best taget to attack when attacked by enemies
event manageDefVTOL(inactive)
{
  local DROID _droid,_aEnDroid[60];
  local int _aTarget[3],_dist,_dist2,_loop;
  local int _aa,_n,_i,_nPos,_nNumEnDroids,_nBestHit,_nCheck;

  _n=0; _i=0; _nNumEnDroids=0;
  _aTarget[0] = -1;
  _aTarget[1] = -1;
  _aTarget[2] = -1;
  
  if ( (!alertIsOn or alertX < 0 or alertY < 0) and defTargetVTOL == NULLOBJECT and nHelpX <= 0 and nHelpY <= 0){ 
    defTargetVTOL    = NULLOBJECT;
    targetPlayerVTOL = -1;
    exit; 
  }
  if ( vtolGr.members == 0 ){ exit; }
  
  //check if a target has been forced elsewhere in the script
  //  defTargetVTOL can be mortar or VTOL !
  if (defTargetVTOL != NULLOBJECT ){
    

    //NEXUS CHECK
    if ( defTargetVTOL.player == player or friendlyPlayer(defTargetVTOL.player) ){ 
      printDebug1("#### manageDefVTOL; attacking myself or a friendly player?? -> pl#("& defTargetVTOL.player &")");
      defTargetVTOL = NULLOBJECT; 
      targetPlayerVTOL = -1;
      exit; 
    } 
    
   _aa = getAA_OnTheWay(baseX, baseY, defTargetVTOL.x, defTargetVTOL.y, AA_THREAT_RANGE);

    if (defTargetVTOL.type == OBJ_DROID){ 
      //probably a VTOL check it is still in defend range
      _droid = objToDroid(defTargetVTOL);
      _dist = distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY); 
      if ( _dist > nDefendRange or _aa*4 > vtolGr.members ){
         defTargetVTOL    = NULLOBJECT;
      }
    } else { //target is struct -> long range weap struct  
      if ( _aa*4 > vtolGr.members or vtolGr.members < MIN_VTOLS_ATTACK){
         defTargetVTOL    = NULLOBJECT;
      }
    }
    
    //attack target
    if (defTargetVTOL != NULLOBJECT ){
      vtolAttack( defTargetVTOL );
      tVtolAction = gameTime;
      exit; 
    }

  } else {// __________Attack enemies in Alert Area!!!!______________  

    //just to be sure...
    boolResult = true;
    if ( targetPlayerVTOL < 0  ){ boolResult = false; }
    
    if ( boolResult ){
      if ( friendlyPlayer(targetPlayerVTOL) ){ 
        printDebug1("#### manageDefVTOL; targetPlayerVTOL is friendly pl#("& targetPlayerVTOL  &")");
        exit;
      }
      
      //update array enemy droids in alert area
      InitEnumDroids(targetPlayerVTOL,player);
      _droid = EnumDroid();
      _n=0;
      while(_droid != NULLOBJECT and _n < 60)
      {
        
        if ( _droid.player == player or friendlyPlayer(_droid.player) ){ 
          printDebug1("#### manageDefVTOL; InitEnumDroids is wrong _droid,player("& _droid.player  &")");
        }
        _dist  = distBetweenTwoPoints(_droid.x,_droid.y, alertX, alertY);
        _dist2 = distBetweenTwoPoints(_droid.x,_droid.y, baseX, baseY);
        if (_dist < 13*TILE or _dist2 < nBaseRange){
          _aEnDroid[_n] = _droid;
          _n++;
          _nNumEnDroids++;
        }
        _droid = EnumDroid();
      }
      
      boolResult = true;
      if ( _nNumEnDroids == 0 ){
       //dbg("#### manageDefVTOL: _nNumEnDroids == 0, no targets found, targetPlayerVTOL("& targetPlayerVTOL &")",player);
       //printDebug1("manageDefVTOL: _nNumEnDroids == 0, no targets found, targetPlayerVTOL("& targetPlayerVTOL &")");
        boolResult = false;
      }
      
      if ( boolResult ){
        //get best three targets
        _loop = 0;
        _nPos = -1;
        while (_loop < 3 and _loop < _nNumEnDroids){
          
          _n=0;
          _nBestHit = 0;
          
          //loop through enemy droids
          while ( _n < _nNumEnDroids){     
            
            boolResult = true;
            if ( _n == _aTarget[0] ){ boolResult = false; }
            if ( _n == _aTarget[1] ){ boolResult = false; }
            if ( _n == _aTarget[2] ){ boolResult = false; }
            
            //Command should be first targets, then droids with high hitpoints
            if ( boolResult ){
              _droid = _aEnDroid[_n]; 
              if ( _droid != NULLOBJECT) {
                if ( _droid.droidType == DROID_COMMAND ){
                 //dbg("manageDefVTOL:  COMMANDER FOUND ("& _droid.id &")",player);
                  oTargetVTOLDef[_loop]  = _droid;
                  _nBestHit           = 9999999999; //force to command
                  _aTarget[_loop]     = _n;
                  _nPos               = _n;
                } else {
                  if ( _droid.hitPoints > _nBestHit ) {
                    oTargetVTOLDef[_loop]  = _droid;
                    _nBestHit           = _droid.hitPoints;
                    _aTarget[_loop]     = _n;
                    _nPos               = _n;
                  }
                }
              }
            }
            
            _n++;
          }//end while
          
          //clear this array pos to avoid to be chosen twice or more
          if ( _nPos >= 0 ){
            _aEnDroid[_nPos] = NULLOBJECT;
          }
          _loop++;
        }
      
        
        boolResult = true;
        if ( _loop == 0 ){
         //dbg("#### manageDefVTOL: _loop == 0, no best target found",player);
          printDebug1("#### manageDefVTOL: _loop == 0, no best target found");
          boolResult = false;
        }
      
        //Attack the targets, assign at least 3 droids to each target
      	if ( boolResult ){
          _i=0;
        	_n=0;
        	_nCheck = 0;
          initIterateGroup(vtolGr);
        	_droid = iterateGroup(vtolGr);
        	while(_droid != NULLOBJECT)
        	{
        	  if ( _n == 3 ){ _i++; _n=0;}//change the target
        	  if ( _i == 3 ){ _i=0;}
            if ( oTargetVTOLDef[_i] != NULLOBJECT ){
                 
              if ( oTargetVTOLDef[_i].player != player and !friendlyPlayer(oTargetVTOLDef[_i].player) ){
                orderDroidObj( _droid, DORDER_ATTACK, oTargetVTOLDef[_i] );
                _nCheck++;//debug purposes only 
                _n++;
              } else {
                printDebug1("#### manageDefVTOL; wanted to attack my own units or an ally??? target("& oTargetVTOLDef[_i].player &")_i("& _i &")");
                oTargetVTOLDef[_i] = NULLOBJECT;
              }
            }	 
            _droid = iterateGroup(vtolGr);
          }
          
        }//boolResult
      }//boolResult
    }//boolResult
  }

/*
    tLastHelp        = gameTime;
	nHelpX           = beaconX[_ally];
	nHelpY           = beaconY[_ally];
  nAllyBeingHelped =  _ally;
*/
  // Add Help Ally
  //dbg("manageDefVTOL: help x-y("& nHelpX &"-"& nHelpY &") nAllyBeingHelped("& nAllyBeingHelped &")",player);
  if ( nHelpX > 0 and nHelpY > 0){
  
   _aa = getAA_OnTheWay(baseX, baseY, nHelpX, nHelpY, AA_THREAT_RANGE);
   if (_aa*4 > vtolGr.members )
   {
    //dbg("#### manageDefVTOL; cannot help, too many AA on the way to help point("& _aa  &")",player);
    printDebug1("#### manageDefVTOL; InitEnumDroids is wrong _droid,player("& _droid.player  &")");
    exit;
   }

   //this is required only to get the enemy player
    _n=0; _i=0;
    targetPlayerVTOL = -1;
    while ( _n < MAX_PLAYERS and baseobj == NULLOBJECT){
      if ( _n != player and !friendlyPlayer(_n) and isPlayerStillLive(_n) )
      {

        InitEnumDroids(_n,nAllyBeingHelped);
        _droid = EnumDroid();
        while(_droid != NULLOBJECT and _i < 60 and targetPlayerVTOL == -1)
        {
          _dist  = distBetweenTwoPoints(_droid.x,_droid.y, nHelpX, nHelpY);
          if ( _dist <= 10*TILE){
            targetPlayerVTOL = _droid.player;
          }
          _droid = EnumDroid();
        }
      
      }
      _n++;
    }
    if ( targetPlayerVTOL == -1 ){
      //dbg("#### manageDefVTOL; cannot help, no targets found ("& _n &")("& _i &") ("&  nHelpX+8*TILE &")("& nHelpY+8*TILE &") ("& count2 &")("& count3 &")",player);
      printDebug1("#### manageDefVTOL; cannot help, no targets found");
      exit;
    }

   
   //update array enemy droids in help area
    InitEnumDroids(targetPlayerVTOL,player);
    _droid = EnumDroid();
    _n=0;
    while(_droid != NULLOBJECT and _n < 60)
    {
      
      _dist  = distBetweenTwoPoints(_droid.x,_droid.y, nHelpX, nHelpY);
      if (_dist < 13*TILE){
        //dbg("manageDefVTOL:  _aEnDroid["& _n &"] id("& _droid.id &") ",player);
        _n++;
        _aEnDroid[_n] = _droid;
        _nNumEnDroids++;
      }
      _droid = EnumDroid();
    }
    
    if ( _nNumEnDroids == 0 ){
      //dbg("#### manageDefVTOL: _nNumEnDroids == 0, no targets found, targetPlayerVTOL("& targetPlayerVTOL &")",player);
     //printDebug1("manageDefVTOL: _nNumEnDroids == 0, no targets found, targetPlayerVTOL("& targetPlayerVTOL &")");
      exit;
    }
    
    //get best three targets
    _loop = 0;
    _nPos = -1;
    while (_loop < 3 and _loop < _nNumEnDroids){
      
      _n=0;
      _nBestHit = 0;
      
      //loop through enemy droids
      while ( _n < _nNumEnDroids){     
        
        boolResult = true;
        if ( _n == _aTarget[0] ){ boolResult = false; }
        if ( _n == _aTarget[1] ){ boolResult = false; }
        if ( _n == _aTarget[2] ){ boolResult = false; }
        
       //Command should be first targets, then droids with high hitpoints
        if ( boolResult ){
          _droid = _aEnDroid[_n]; 
          if ( _droid != NULLOBJECT) {
            if ( _droid.droidType == DROID_COMMAND ){
               oTargetVTOLDef[_loop]  = _droid;
              _nBestHit           = 9999999999; //force to command
              _aTarget[_loop]     = _n;
              _nPos               = _n;
            } else {
              if ( _droid.hitPoints > _nBestHit ) {
                 oTargetVTOLDef[_loop]  = _droid;
                _nBestHit           = _droid.hitPoints;
                _aTarget[_loop]     = _n;
                _nPos               = _n;
              }
            }
          }
        }
        
        _n++;
      }//end while
      
      //clear this array pos to avoid to be chosen twice or more
       if ( _nPos >= 0 ){ _aEnDroid[_nPos] = NULLOBJECT; }
      _loop++;
    }
  
    if ( _loop == 0 ){
      //dbg("#### manageDefVTOL: _loop == 0, no best target found",player);
      printDebug1("#### manageDefVTOL: _loop == 0, no best target found");
      exit;
    }
  
    //Attack the targets, assign at least 3 droids to each target
  	_i=0;
  	_n=0;
  	_nCheck = 0;
    initIterateGroup(vtolGr);
  	_droid = iterateGroup(vtolGr);
  	while(_droid != NULLOBJECT)
  	{
  	  if ( _n == 3 ){ _i++; _n=0;}//change the target
  	  if ( _i == 3 ){ _i=0;}
      if ( oTargetVTOLDef[_i] != NULLOBJECT ){
           
        if ( oTargetVTOLDef[_i].player != player and !friendlyPlayer(oTargetVTOLDef[_i].player) ){
          orderDroidObj( _droid, DORDER_ATTACK, oTargetVTOLDef[_i] );
          _nCheck++;//debug purposes only 
          _n++;
        } else {
          //dbg("#### VTOLDefend; wanted to attack my own units or an ally??? target("& oTargetVTOLDef[_i].player &")_i("& _i &")",player);
          printDebug1("#### VTOLDefend; wanted to attack my own units or an ally??? target("& oTargetVTOLDef[_i].player &")_i("& _i &")");
          oTargetVTOLDef[_i] = NULLOBJECT;
        }
      }	 
      _droid = iterateGroup(vtolGr);
    }
  
  }//end help
  
  
}
//----------------------------------------------------------------
event reassignPlayers(reassignPlayersTr)
{
	if( playerLeft == player ){
		console(getPlayerName(player) & " is now assigned to DyDo AI as human player has left");
    bRunning = true;
		activateAI();
	}
}


//----------------------------------------------------------------
//Check if any threat is in range of Trucks/cybEng order location.
//The order RTB is given only if the droid distance from order location is
// greater than 4 TILES. This because AI left the droid complete the
// building even with threat in range. The droid is called back anyway if
// it is attacked (see event AIattacked). 
event threatCheck(threatCheckTr)
{
  local int _dist,_dist2;

  eventCheckTime[30] = gameTime;

  //buildGrp
  initIterateGroup(buildGrp);
	droid = iterateGroup(buildGrp);
	while(droid != NULLOBJECT)
	{
	  _dist2 = distBetweenTwoPoints(baseX,baseY,droid.x,droid.y);
	  _dist  = distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y);
    if ( _dist2 > nBaseRange and _dist > 4*TILE and threatInRange(player,droid.orderx,droid.ordery, THREAT_RANGE_TILES*128, false) )
    {
      //dbg("dbg->threatCheck: THREAT found! stop building truck ("& droid.id &") order at ("& droid.orderx/TILE &"-"& droid.ordery/TILE &") distance from orderLoc ("& _dist/TILE &") dist from base/nBaseRange("& _dist2 &"/"& nBaseRange &")",player);
      orderDroid( droid, DORDER_RTB );
  	}
		droid = iterateGroup(buildGrp);
  }
  
  //buildDefGrp
  initIterateGroup(buildDefGrp);
	droid = iterateGroup(buildDefGrp);
	while(droid != NULLOBJECT)
	{
	  _dist2 = distBetweenTwoPoints(baseX,baseY,droid.x,droid.y);
	  _dist  = distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y);
    if ( _dist2 > nBaseRange and _dist > 4*TILE and threatInRange(player,droid.orderx,droid.ordery, THREAT_RANGE_TILES*128, false) )
    {
      //dbg("dbg->threatCheck: THREAT found! stop buildDef truck ("& droid.id &") order at ("& droid.orderx/TILE &"-"& droid.ordery/TILE &") distance from orderLoc ("& _dist/TILE &") dist from base/nBaseRange("& _dist2 &"/"& nBaseRange &")",player);
      orderDroid( droid, DORDER_RTB );
  	}
		droid = iterateGroup(buildDefGrp);
  }

  //cyborgConstruct
  initIterateGroup(cybConstGrp);
	droid = iterateGroup(cybConstGrp);
	while(droid != NULLOBJECT)
	{
	  _dist2 = distBetweenTwoPoints(baseX,baseY,droid.x,droid.y);
	  _dist  = distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y);
    if ( _dist2 > nBaseRange and _dist > 4*TILE and threatInRange(player,droid.orderx,droid.ordery, THREAT_RANGE_TILES*128, false) )
    {
      //dbg("dbg->threatCheck: THREAT found! stop truck ("& droid.id &") order at ("& droid.orderx/TILE &"-"& droid.ordery/TILE &") distance from orderLoc ("& _dist/TILE &") dist from base/nBaseRange("& _dist2 &"/"& nBaseRange &")",player);
      orderDroid( droid, DORDER_RTB );
  	}
		droid = iterateGroup(cybConstGrp);
  }

}
//----------------------------------------------------------------
// process new visibility reports
//	(CALL_DROID_SEEN, player, ref enemyBaseObject, ref myBaseObject);
event newObjectReport(newObjectReportTr)
{
	local DROID _droid;
  if( !friendlyPlayer(enemyBaseObject.player) ){
  	if( isHumanPlayer(enemyBaseObject.player) ){
      //dbg("newObjectReport: human player obj seen" , player);
	    if  ( enemyBaseObject.type == OBJ_DROID ){
        //dbg("newObjectReport: it is droid" , player);
  	    _droid = objToDroid(enemyBaseObject);
  	    if  ( _droid.droidType == DROID_COMMAND ){
  	     //printDebug1("newObjectReport: human player ("& getPlayerName(_droid.player) &") uses commander!");
  	      //dbg("newObjectReport: human player ("& getPlayerName(_droid.player) &") uses commander!" , player);
  	      if ( !bHumPlUsesCommanders ){
            setEventTrigger(storeEnemyCommanders,storeEnemyCommandersTr);
          }
  	      bHumPlUsesCommanders = true;
        }
      }
    }
  }
}
//----------------------------------------------------------------
event storeEnemyCommanders(inactive)
{
  local int _player,_bestDist,_dist;
  local DROID _droid;
  
  _player = 0;
  _bestDist = 9999999;
  
  while( _player < MAX_PLAYERS ){
    
    if ( isPlayerStillLive(_player) and isHumanPlayer(_player) and !friendlyPlayer(_player) )
    {
      
      _droid = getNearestEnemyCmd(_player);
      
      if ( _droid != NULLOBJECT ){
        _dist = distBetweenTwoPoints(_droid.x ,_droid.y ,baseX ,baseY);
        if ( _dist < _bestDist ){
          dNearestEnemyCmd  = _droid;
          _bestDist         = _dist; 
        }
      }
      
    }
    _player++;
  }
  
  if ( dNearestEnemyCmd == NULLOBJECT ){
   //dbg("storeEnemyCommanders: commander NOT found ",player );  
    bHumPlUsesCommanders = false;
    setEventTrigger(storeEnemyCommanders,inactive);
    exit;    
  } 
 //dbg("storeEnemyCommanders: commander found ("& dNearestEnemyCmd.id &") dist("& _bestDist/TILE &")/("& nDefendRange/TILE &")",player );  

}
//----------------------------------------------------------------
event manageDefTrucks(inactive)
{
  local DROID _droid;
  local bool _bProceed;
  
  _bProceed = true;
  
  //dbg("manageDefTrucks: dist ("& distBetweenTwoPoints(baseX,baseY,aPl[nNearestEnemy][X_COORD],aPl[nNearestEnemy][Y_COORD])/TILE &") bEnemyIsNear("&  bEnemyIsNear &")nProdSelect("& nProdSelect &") ",player);
  //dbg("manageDefTrucks: ("& buildDefGrp.members &") MinBaseBuilt("& lMinBaseStructBuilt &")  nDefPhase("& nDefPhase &") lStDef("& lStopBuildDef &") lStGat("& lStopBuildDefGateway &") lStDer("& lStopBuildDefDerricks &") ("& nT_Game &")==("& T2_GAME &")",player);
  if( buildDefGrp.members == 0 ){ exit; }

  //--------------- T2 games at game start ----------------------
  if ( nT_Game == T2_GAME and gameTime < TIME_HARVESTING_PHASE){
    
    _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);

    if ( _droid != NULLOBJECT ){
      
      // ----- build AA def ------
      buildAAdef(_droid);
      
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( nEarlyMortars < 3 and bEnemyIsNear and _droid != NULLOBJECT ){
        // ------ build Artillery -----
//dbg("manageDefTrucks; buildArtillery -1 ("&  nEarlyMortars &")",player);
        buildArtillery(_droid);
      }
    
    }
  }

  //--------------- defend by VTOLs ----------------------
  _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
  if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; buildAAdef",player);
    buildAAdef(_droid);
  }
  
  //--------------- defend base ----------------------
  if ( !lStopBuildDef ) {
    if ( nDefPhase == 0 ){      
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; defendBase",player);
        defendBase(_droid);
        nDefPhase++;
      }
    }
  } else {
    nDefPhase++;
  }
  
  //--------------- defend gateways ----------------------  
  if ( !lStopBuildDefGateway and nRealGatewaysFound > 0 and pickWallDefQueueDepth > 0) {
    if ( nDefPhase == 1 ){      
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; buildGatewayDef",player);
        buildGatewayDef(_droid);
        nDefPhase++;
      }
    }
  } else {
    nDefPhase++;
  }
  //--------------- defend derricks ----------------------
  if ( !lStopBuildDefDerricks ) {
    if ( nDefPhase == 2 ){      
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; defendDerrick",player);
        defendDerrick(_droid);
        nDefPhase++;
      }
    }
  } else {
    nDefPhase++;
  }
  
  //--------------- long range weapon ----------------------
  if ( !lStopBuildDef ) {
    if ( nDefPhase == 3 ){      

      //-------- Build Ripple Rockets --------
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; buildRippleRockets",player);
        buildRippleRockets(_droid);
        nDefPhase++;
      }

      //----- build Artillery -------
      _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
      if ( _droid != NULLOBJECT ){
//dbg("manageDefTrucks; buildArtillery - 2",player);
        buildArtillery(_droid);
        nDefPhase++;
      }
    
    }
  } else {
    nDefPhase++;
  }

  

  
  if ( nDefPhase >= 4 ){ nDefPhase = 0; }      

  
  //--------------- idle Trucks Repair ----------------------
  if (!repairDefStructs(BUILDDEF_GRP)){
    boolResult = repairStructs(BUILDDEF_GRP);      
  }

  //--------------- idle Trucks Help Build ----------------------
  // help build is made on the manageIdleTrucks event
  _droid = closestDroidCanBuild(buildDefGrp,baseX,baseY);
  if ( _droid != NULLOBJECT ){
    helpBuild( _droid );
  }

  sendIdleBackToTheBase(BUILDDEF_GRP);  

}
/*
==============================================================================
Functions Section 
==============================================================================
*/
//----------------------------------------------------
function void activateAI()
{
    local string strMessage;
    //activate all events!!
    setEventTrigger(droidBuilt, droidBuiltTr);
    setEventTrigger(AIattacked, AIattackedTr);
    setEventTrigger(vtolDefend, vtolDefendTr);
    //setEventTrigger(consoleEv, inactive);
    setEventTrigger(multiMsgEv, multiMsgTr);
    setEventTrigger(beaconEv, beaconTr);
    setEventTrigger(reassignPlayers, reassignPlayersTr);

    setEventTrigger(manageDefTrucks, manageDefTrucksTr);
    setEventTrigger(evDebug, evDebugTr);
    setEventTrigger(AIbrain, AIbrainTr);
    setEventTrigger(buildBase, buildBaseTr);
    setEventTrigger(buildRepFacSuppAttack, buildRepFacSuppAttackTr);
    setEventTrigger(buildRepFirst, buildRepFirstTr);
    setEventTrigger(difficultyModifier, difficultyModifierTr);
    setEventTrigger(doResearch, doResearchTr);
    setEventTrigger(manageDefCyborgs, manageDefCyborgsTr);
    setEventTrigger(manageDefTank, manageDefTankTr);
    setEventTrigger(activateAttack, activateAttackTr);
    setEventTrigger(manageIdleTrucks, manageIdleTrucksTr);
    setEventTrigger(manageRepairTeam, manageRepairTeamTr);
    setEventTrigger(SelectCyborgTemplate, SelectCyborgTemplateTr);
    setEventTrigger(SelectTankTemplate, SelectTankTemplateTr);
    setEventTrigger(sendBackDamagedUnits, sendBackDamagedUnitsTr);
    setEventTrigger(truckGroupSlider, truckGroupSliderTr);
    setEventTrigger(unitAssignationCheck, unitAssignationCheckTr);
    setEventTrigger(unitRepairSwitch, unitRepairSwitchTr);
    setEventTrigger(updateBaseDetails, updateBaseDetailsTr);
    setEventTrigger(upgradeStructures, upgradeStructuresTr);
    setEventTrigger(useLassat, useLassatTr);
    setEventTrigger(vtolEnabler, vtolEnablerTr);
    setEventTrigger(multiMsgEv, multiMsgTr);
    setEventTrigger(beaconEv, beaconTr);
    setEventTrigger(shutDownAI, shutDownAITr);
    setEventTrigger(evPrintDebug, evPrintDebugTr);
    setEventTrigger(harvesterOperate,harvesterOperateTr);
    setEventTrigger(AIcheck,AIcheckTr);
    setEventTrigger(threatCheck,threatCheckTr);
    setEventTrigger(newObjectReport,newObjectReportTr);
    
    //setEventTrigger(earlyAttack,earlyAttackTr);
    //setEventTrigger(manageDefVTOL,manageDefVTOLTr);    
    tFinishOilHack = gameTime;

    

}
//----------------------------------------------------------------
function void shutDownThisAI()
{
   	bRunning = false;
    setEventTrigger(activateAttack, inactive);
    setEventTrigger(AIbrain, inactive);
    setEventTrigger(AIcheck, inactive);
    setEventTrigger(beaconEv, inactive);
    setEventTrigger(buildBase, inactive);
    setEventTrigger(buildRepFacSuppAttack, inactive);
    setEventTrigger(buildRepFirst, inactive);
    setEventTrigger(buildVtols, inactive);
    setEventTrigger(CyborgAttack, inactive);
    setEventTrigger(difficultyModifier, inactive);
    setEventTrigger(doResearch, inactive);
    setEventTrigger(evDebug, inactive);
    setEventTrigger(evPrintDebug, inactive);
    setEventTrigger(harvesterOperate, inactive);
    setEventTrigger(manageDefCyborgs, inactive);
    setEventTrigger(manageDefTank, inactive);
    setEventTrigger(manageDefTrucks, inactive);
    setEventTrigger(manageAttVTOL, inactive);
    setEventTrigger(manageHelpTeam, inactive);
    setEventTrigger(manageIdleTrucks, inactive);
    setEventTrigger(manageRepairTeam, inactive);
    setEventTrigger(reSortUnits, inactive);
    setEventTrigger(SelectCyborgTemplate, inactive);
    setEventTrigger(SelectTankTemplate, inactive);
    setEventTrigger(sendBackDamagedUnits, inactive);
    setEventTrigger(showAImessage, inactive);
    setEventTrigger(shutDownAI, inactive);
    setEventTrigger(TankAttack, inactive);
    setEventTrigger(truckGroupSlider, inactive);
    setEventTrigger(unitAssignationCheck, inactive);
    setEventTrigger(unitRepairSwitch, inactive);
    setEventTrigger(updateBaseDetails, inactive);
    setEventTrigger(upgradeStructures, inactive);
    setEventTrigger(useLassat, inactive);
    setEventTrigger(vtolEnabler, inactive);
    setEventTrigger(vtolStructs, inactive);
    setEventTrigger(threatCheck,inactive);
    setEventTrigger(manageDefVTOL,manageDefVTOLTr);    
    setEventTrigger(droidBuilt, inactive);
    setEventTrigger(AIattacked, inactive);
    setEventTrigger(vtolDefend, inactive);
    //setEventTrigger(consoleEv, inactive);
    setEventTrigger(multiMsgEv, inactive);
    setEventTrigger(beaconEv, inactive);
    setEventTrigger(reassignPlayers, inactive);
    setEventTrigger(VTOLhunter,inactive);
    setEventTrigger(earlyAttack,inactive);
    setEventTrigger(newObjectReport,inactive);
    setEventTrigger(storeEnemyCommanders,inactive);

}
//----------------------------------------------------------------
function void setTankGatheringPoint(int _fromX,int _fromY,int _targetX,int _targetY)
{
  local int _n,_nX,_nY,_nX0,_nY0,_distFromObj;
  _distFromObj  = 13*TILE + (((mapWidth*TILE+mapHeight*TILE)/2) / 30 );
  
  //need a droid for droidCanReach
  droid = getADroid(buildGrp);
  if ( droid == NULLOBJECT ){
    droid = getADroid(buildDefGrp);
    if ( droid != NULLOBJECT ){
      if ( droid.propulsion == HoverProp ){
        droid = NULLOBJECT;
      }
    }
  } else {
    if ( droid.propulsion == HoverProp ){
      droid = NULLOBJECT;
    }
    droid = getADroid(buildDefGrp);
    if ( droid != NULLOBJECT ){
      if ( droid.propulsion == HoverProp ){
        droid = NULLOBJECT;
      }
    }
  }
  if ( droid == NULLOBJECT ){
    droid = getADroid(cybConstGrp);
  }
  if ( droid == NULLOBJECT ){
    nTankGatheringX = baseX;
    nTankGatheringY = baseY;
    return;
  }
  
  boolResult = true;
  count = 0;
  while ( boolResult and count < 10 )
  {
    _n = random(3);
    if ( _n == 0 and attackTankObj != NULLOBJECT){  //between bases
      if ( attackTankObj.x > _fromX ){
        _nX = _fromX +  (attackTankObj.x-_fromX)/2;
      } else {
        _nX = _fromX -  (_fromX-attackTankObj.x)/2;
      }
      if ( attackTankObj.y > _fromY ){
        _nY = _fromY +  (attackTankObj.y-_fromY)/2;
      } else {
        _nY = _fromY -  (_fromY-attackTankObj.y)/2;
      }
      nTankGatheringX = getCoordRelated(_nX, _nY, _fromX, _fromY, 1, 1*TILE);
      nTankGatheringY = getCoordRelated(_nX, _nY, _fromX, _fromY, 2, 1*TILE);
    }
    if ( _n == 1 ){    //centre of the map
      _nX = (mapWidth*TILE)/2;
      _nY = (mapHeight*TILE)/2;
      nTankGatheringX = getCoordRelated(_nX, _nY, _fromX, _fromY, 1, 1*TILE);
      nTankGatheringY = getCoordRelated(_nX, _nY, _fromX, _fromY, 2, 1*TILE);
    }
    if ( _n == 2 and attackTankObj != NULLOBJECT ){    //standard
      nTankGatheringX = getCoordRelated(attackTankObj.x, attackTankObj.y, _fromX, _fromY, 1, _distFromObj);
      nTankGatheringY = getCoordRelated(attackTankObj.x, attackTankObj.y, _fromX, _fromY, 2, _distFromObj);
    }
    if ( droidCanReach(droid, nTankGatheringX, nTankGatheringY) ){
      boolResult = false;
    }
    count++;
  }


  return;
}
//----------------------------------------------------------------
function int mapSize()//mapSize() < MAP_SMALL
{ 
  local int _nDim;
  _nDim = (mapWidth+mapHeight)/2;  
  if ( _nDim <= 120 ){ return MAP_SMALL; }
  if ( _nDim <= 160 ){ return MAP_MEDIUM; }
  return MAP_BIG;  
}
//----------------------------------------------------------------
//  loop through all units belonging to _group and assign them best target
//  - 1 attack droid in unit range checking for best target based on its weapon
//  - 2 attack def struct in group range
//  - 3 attack droid in _x & _y range checking for best target based on its weapon
//  - 4 if not targets found scout (50%) and move (50%) to _x & _y coordinates
//
function void droidMicroManager(GROUP _group, int _range, int _x, int _y)
{
  local DROID _droid,_enDroid;
  local STRUCTURE _structTarget;
  local BASEOBJ _oTarget;
  local int _enWeapons,_count,_eascapeRange;
  local bool _bAntiStruct;
  
  _bAntiStruct = false;
  
  //search for struct in group (! not his) range
  _structTarget = getEnemyDefStruct(_group,_range);

  //check if any droid target in group short range 
  _oTarget = objDroidTargetInRange(_group.x, _group.y, _range, false);
  

  //if not droid in short group range then attack def structs if any
  if ( _oTarget == NULLOBJECT and _structTarget != NULLOBJECT ) {
    orderGroupObj(_group, DORDER_ATTACK, _structTarget);
    return;
  }

  //use anti struct droids for structure and rest for droids
  if ( _oTarget == NULLOBJECT and _structTarget != NULLOBJECT ) {

    _bAntiStruct = true; //avoid to process twice these droids.

  	initIterateGroup(_group);
  	_droid = iterateGroup(_group);
  	_count=0;
    while(_droid != NULLOBJECT and _count < MAX_WHILE_LOOPS)
    {
      
      if ( isAntiStruct(_droid) ){

        //check first if any enemy is too near, like enemy flamers
        _eascapeRange = 4*TILE; //
        if ( isLongRange(_droid) )    { _eascapeRange = 6*TILE;  }//8-10
        if ( isVeryLongRange(_droid) ){ _eascapeRange = 8*TILE; }//11 and upwards
        _enWeapons = numEnemyWeapObjInRange(player, _droid.x, _droid.y, _eascapeRange, false, true);
        if ( _enWeapons > 0 ){
           orderDroidLoc(_droid, DORDER_MOVE, baseX, baseY);
        } else {
           orderDroidObj(_droid, DORDER_ATTACK, _structTarget);
        }
      
      }
      
      _droid = iterateGroup(_group);
      _count++;
    }
  
  }

  //loop through the droids
	initIterateGroup(_group);
	_droid = iterateGroup(_group);
	_count=0;
  while(_droid != NULLOBJECT and _count < MAX_WHILE_LOOPS)
  {
   

    boolResult = true;
    _enDroid   = NULLOBJECT; //this is important otherwise event crashes!!
    //search for droid target in group range

    //do not process antiStruct as it is attacking an enemy struct.
    if ( _bAntiStruct and isAntiStruct(_droid) ){
      boolResult = false;
    }
    
    if ( boolResult ){

      //adopt the reange where to search for enemies, default is passed as parameter (usually 12*TILE)
      if ( isVeryLongRange(_droid) ){ _range = 15*TILE; }//11 and upwards

      //keep away from enemy flamers / droids
      if (!isFlamer(_droid)){

        _eascapeRange = 4*TILE; //
        if ( isLongRange(_droid) )    { _eascapeRange = 6*TILE;  }//8-10
        if ( isVeryLongRange(_droid) ){ _eascapeRange = 8*TILE; }//11 and upwards

        _enWeapons = numEnemyWeapObjInRange(player, _droid.x, _droid.y, _eascapeRange, false, true);

        if ( _enWeapons > 0 ){
          orderDroidLoc(_droid, DORDER_MOVE, baseX, baseY);
          boolResult = false;
        }
      }
      
      //attack commanders first 
      _enDroid = getEnemyDroid( _group.x, _group.y, 18*TILE, DROIDTYPE_COMM);
    }
    
    //Flamer - Laser    
    if ( _enDroid == NULLOBJECT and boolResult) {
      if ( isFlamer(_droid) ){
        _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_HOVER);
        if ( _enDroid == NULLOBJECT ) {
          _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_CYBORG);
        }
        if ( _enDroid == NULLOBJECT ) {
          _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_TANK);
        }
      } else {
        //AP
        if ( isAntiPersonnel(_droid) ){
          _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_CYBORG);
          if ( _enDroid == NULLOBJECT ) {
            _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_TANK);
          }
        } else {    
          //AT
          if ( isAntiTank(_droid) ){
            _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_TANK);
            if ( _enDroid == NULLOBJECT and _structTarget == NULLOBJECT ){
              _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_CYBORG);
            }
          } else {
            //All rounder: search a droid taget if structure target is NULLOBJECT
            if (_structTarget == NULLOBJECT ) {
              _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_TANK);
              if ( _enDroid == NULLOBJECT and _structTarget == NULLOBJECT ){
                _enDroid = getEnemyDroid( _group.x, _group.y, _range, DROIDTYPE_CYBORG);
              }
             
              
            }      
          }
        } 
      }
    } 
    
    //search for enemy def struct     
    if ( _enDroid == NULLOBJECT and boolResult ) {
      if (_structTarget != NULLOBJECT and _droid != NULLOBJECT ) {
        orderDroidObj(_droid, DORDER_ATTACK, _structTarget);
        boolResult = false;
      }
    }

    //attack or scout!!   
    if ( boolResult ){
      if ( _enDroid != NULLOBJECT and _droid != NULLOBJECT ) {
          orderDroidObj(_droid, DORDER_ATTACK,_enDroid);
      } else {
        if ( _droid != NULLOBJECT ){
          orderDroidLoc(_droid, DORDER_SCOUT, _x, _y);
        }
      }
    }
    
    _droid = iterateGroup(_group);
    _count++;
  }
  
  //change the action
  if ( bScoutOrder ){
    bScoutOrder = false;
  } else {
    bScoutOrder = true;
  }
  
 
}
//-----------------------------------------------------------------------------
function DROID getEnemyDroid(int _x,int _y,int _dist,int _droidType)
{
  local int _player, _lowestHealth,  _bestDist, _droidDist;
  local DROID _droid, _tmpDroid, _bestDroid ;
  
  _player = 0;
  _droid  = NULLOBJECT;
  _bestDroid  = NULLOBJECT;
  _lowestHealth = 100;
  _bestDist = 999999; //bestDist
  
  while ( _player < MAX_PLAYERS ){ 
    
    if ( isPlayerStillLive(_player) and !friendlyPlayer(_player) ){
      
      InitEnumDroids(_player,player);//only visible droids are processed
      _droid = EnumDroid();
      
      while(_droid != NULLOBJECT){
        _tmpDroid  = NULLOBJECT;
   			if ( distBetweenTwoPoints(_droid.x ,_droid.y ,_x ,_y) < _dist){
          
          if ( _droidType == DROIDTYPE_COMM ){
            if( _droid.droidType == DROID_COMMAND ){
              _tmpDroid = _droid;
            }
          }
          if ( _droidType == DROIDTYPE_HOVER ){
            if( _droid.propulsion == HoverProp ){
              _tmpDroid = _droid;
            }
          }
          if ( _droidType == DROIDTYPE_TANK ){
            if(_droid.droidType == DROID_WEAPON and _droid.propulsion != cyborgPropulsion){
              _tmpDroid = _droid;
            }
          }
          if ( _droidType == DROIDTYPE_CYBORG ){
            if(_droid.propulsion == cyborgPropulsion and _droid.droidType != DROID_CYBORG_CONSTRUCT){
              _tmpDroid = _droid;
            }
          }
        
          //attack the nearest enemy
          if ( _tmpDroid != NULLOBJECT ){
            _droidDist = distBetweenTwoPoints(_tmpDroid.x ,_tmpDroid.y ,_x ,_y);
            if ( _droidDist < _bestDist  ){
              _bestDroid  = _tmpDroid;
              _bestDist   = _droidDist;
            }
          }
          
          /*
          I have removed this because droids with long range weapons tended to attack
          enemy droids which were too far away and they mostly got the order to
          move back to the base becasue of enemies near to them.
          //pick up most damage one if near enough
          if ( _tmpDroid != NULLOBJECT ){
            if ( _tmpDroid.health < _lowestHealth and  ){
              _bestDroid    = _tmpDroid;
              _lowestHealth = _tmpDroid.health;
            }
          }
          */
          
        }//dist
        
        _droid = EnumDroid();      
      }//while
    }
    _player++;
  
  }//end while 

  return _bestDroid;//NULLOBJECT
}
//-----------------------------------------------------------------------------
function bool isFlamer(DROID _droid)
{

  //tanks
  if ( _droid.weapon == cybFlamer or _droid.weapon == cybThermite or _droid.weapon == Flamer or _droid.weapon == PlasmFlamer or _droid.weapon == Inferno  ){
    return true;
  }
   
  return false;
}
//-----------------------------------------------------------------------------
//
function bool isAntiStruct(DROID _droid)
{
  if ( _droid.weapon == RocketBB or _droid.weapon == cybGren ){
    return true;
  }
  
  return false;
}
//-----------------------------------------------------------------------------
// range 8-10
function bool isLongRange(DROID _droid)
{

  //Super cyborgs              10
  if (  _droid.weapon == cybTankKiller ){
    return true;
  }

  //Tanks - 1                 10               
  if ( _droid.weapon == PlasmaCannon ){
    return true;
  }
  
  //Tanks - 2               10                           8                             8.5                         8.5                          9                           10    
  if ( _droid.weapon == RocketBB or _droid.weapon == RocketPod or _droid.weapon == HVCannon or _droid.weapon == RocketMRL or _droid.weapon == Lancer or _droid.weapon == TankKiller ){
   return true;
  }
  
  return false;
}
//-----------------------------------------------------------------------------
// Ming range >= 11
function bool isVeryLongRange(DROID _droid)
{

  //cyborgs not super       11                             12                              12                           14      
  if ( _droid.weapon == cybNeedle or _droid.weapon == cybFlashLight or _droid.weapon == cybGren or _droid.weapon == cybScourge  ){
    return true;
  }
  //Super cyborgs              14                                   14                                10
  if ( _droid.weapon == cybSuperScourge or _droid.weapon == cybSuperPulsLas or _droid.weapon == cybTankKiller ){
    return true;
  }

  //Tanks - 1              12                             14                            16          
  if ( _droid.weapon == FlashLight or _droid.weapon == PulseLaser or _droid.weapon == HeavyLaser ){
    return true;
  }
  
  //Tanks - 2      14  
  if ( _droid.weapon == ScourgeMissle ){
   return true;
  }
  
  //Very long                 86                                120
  if (  _droid.weapon == RippleRockets or _droid.weapon == ArchangelMissile){
   return true;
  }
  return false;
}
//-----------------------------------------------------------------------------
function bool isAntiPersonnel(DROID _droid)
{

  //tanks & cyborgs
  if ( _droid.weapon == EMPCannon or _droid.weapon == AGun or _droid.weapon == MGun or _droid.weapon == TwinMGun or _droid.weapon == HMGun or _droid.weapon == TwinAGun){
    return true;
  }
  
  //Lasers   
  if ( _droid.weapon == FlashLight or _droid.weapon == PulseLaser or _droid.weapon == HeavyLaser ){
     return true;                  
  }
  
  //cyborgs
  if ( _droid.weapon == cybGren ){
    return true;
  }

  return false;
}
//-----------------------------------------------------------------------------
function bool isAntiTank(DROID _droid)
{
  
  //tanks
  if ( _droid.weapon == RocketBB or _droid.weapon == RocketPod or _droid.weapon == RocketMRL or _droid.weapon == Lancer or _droid.weapon == TankKiller or _droid.weapon == RippleRockets or _droid.weapon == ScourgeMissle or _droid.weapon == ArchangelMissile){
   return true;                  
  }
  
  //cyborgs
  if ( _droid.weapon == cybLancer or _droid.weapon == cybScourge or _droid.weapon == cybSuperScourge or _droid.weapon == cybTankKiller){
    return true;
  } 
  
  return false;
}
//-----------------------------------------------------------------------------
function void buildRearmPads()
{

	if(!isStructureAvailable(vtolPad,player)){
  	//displayMsg("*** buildRearmPads: vtolPad not available ");
		return;
	}

	buildX = baseX;							
	buildY = baseY;

	if(pickStructLocation(vtolPad, ref buildX, ref buildY, player))
	{
		droid = closestDroidCanBuild(buildGrp, buildX , buildY );
    if ( buildGrp.members < 2 ){
      if (droid == NULLOBJECT){  
        droid = closestIdleDroid(cybConstGrp, buildX , buildY );
      }
    }
		if(droid != NULLOBJECT)
		{
  		if ( droidCanReach(droid, buildX, buildY) ){
        //displayMsg("*** buildRearmPads: droid to build vtolPad");
			 orderDroidStatsLoc(droid, DORDER_BUILD,vtolPad, buildX,buildY);
			}
		} //else { displayMsg("buildRearmPads: no idle buildDroid found"); }
	} //else { displayMsg("#### buildRearmPads: cannot pick up a location to build vtolPad"); }
}
//-----------------------------------------------------------------------------
/*
	vtols[0]	TEMPLATE	"V-Bug-Lancer"		         //Bug - Lancer
	vtols[1]	TEMPLATE	"V-Bug-HPV"		             //Bug - HyperVelCann
	vtols[2]	TEMPLATE	"H-Scorp-VTOL-Lancer"      //Scorpion - Lancer
	vtols[3]	TEMPLATE	"V-Scor-HPV"               //Scorpion - HyperVelCann
	vtols[4]	TEMPLATE	"V-Mantis-Lancer"          //Mantis - Lancer
	vtols[5]	TEMPLATE	"V-Mantis-HPV"             //Mantis - HPV
	vtols[6]	TEMPLATE	"SK-Retal-VTOL-Scourge"    //Retaliation - Scourge Missle (AT)
	vtols[7]	TEMPLATE	"SK-Retre-VTOL-Scourge"    //Retribution - Scourge 

	vtols[8]	TEMPLATE	"SK-Mantis-VTOL-PBB"       //**Mantis - Phosphor Bomb Bay
	vtols[9]	TEMPLATE	"SK-Mantis-VTOL-HBB"       //**Mantis - Heap Bomb Bay
	vtols[10]	TEMPLATE	"SK-Retre-VTOL-HBB"        //**Retribution - Heap Bomb Bay
	vtols[11]	TEMPLATE	"SK-Retre-VTOL-Thermite"   //**Retribution - Thermite Bomb Bay 
*/
function void vtolFactoryBuildVtol(STRUCTURE _factory)
{
	local	int		_nRnd, _t,_nLoop,_nTemplAT,_nTemplBomb,_templateAT,_templateBomb;
	local TEMPLATE _tmplToBuild;
  local bool _bResult, _bBombVTOL;
	
  if( _factory == NULLOBJECT){ return;	}
  if( !structureIdle(_factory) ) { return;	}

	_bResult = false;
	_bBombVTOL = false;

	_t = -1;
  _nLoop      = 0;
	_nTemplAT   = 0;
	_nTemplBomb = 0;
	while( _nLoop < numVtolTemplates )
	{
		if ( _nLoop < 8 ){//AT  - light/medium body
      if( skCanBuildTemplate(player,_factory, vtols[_nLoop]) ){
				_nTemplAT++;
				_bResult = true;
				//dbg("vtolFactoryBuildVtol: can build AT vtols["& _nLoop &"]",player);
			}
		} else {  //Bomb - Heavy Body
      if( skCanBuildTemplate(player,_factory, vtols[_nLoop]) ){
				//dbg("vtolFactoryBuildVtol: can build Bomb vtols["& _nLoop &"]",player);
				_nTemplBomb++;
				_bResult = true;
			}
   }
		_nLoop++;
	}

	if(!_bResult)	{  
    //dbg("vtolFactoryBuildVtol: no templates lancer("& researchFinished(lancerATweap,player) &") scorpion("& skVtolEnableCheck(player) &")("& _nTemplAT &")("& _nTemplBomb &") ",player); 
    return;
  }
	

  _nRnd = random(100);
  if ( _nTemplBomb == 0 ){ //Only AT

    if ( _nRnd < 70 ){ //Lancer - Scourge
    	//Lancer-Scourge
      if( skCanBuildTemplate( player ,_factory, vtols[0]) ){ _t = 0; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[2]) ){ _t = 2; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[4]) ){ _t = 4; }
    	if( skCanBuildTemplate( player ,_factory, vtols[6]) ){ _t = 6; }
    	if( skCanBuildTemplate( player ,_factory, vtols[7]) ){ _t = 7; }
    	 if ( _t == -1 ){ //backup
        if( skCanBuildTemplate( player ,_factory, vtols[1]) ){ _t = 1; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[3]) ){ _t = 3; }
      	if( skCanBuildTemplate( player ,_factory, vtols[5]) ){ _t = 5; }
       }
    } else {//HPV
      if( skCanBuildTemplate( player ,_factory, vtols[1]) ){ _t = 1; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[3]) ){ _t = 3; }
    	if( skCanBuildTemplate( player ,_factory, vtols[5]) ){ _t = 5; }
  	  if ( _t == -1 ){ //backup
        if( skCanBuildTemplate( player ,_factory, vtols[0]) ){ _t = 0; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[2]) ){ _t = 2; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[4]) ){ _t = 4; }
      	if( skCanBuildTemplate( player ,_factory, vtols[6]) ){ _t = 6; }
      	if( skCanBuildTemplate( player ,_factory, vtols[7]) ){ _t = 7; }
  	  }
    } 
  
  
  } else {
   
    if ( _nRnd < 50 ){ //Bomb

    	if( skCanBuildTemplate( player ,_factory, vtols[8]) ) { _t = 8; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[9]) ) { _t = 9; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[10]) ){ _t = 10; } 
    	if( skCanBuildTemplate( player ,_factory, vtols[11]) ){ _t = 11; } 
   
    } else { //AT
    
      _nRnd = random(100);
      if ( _nRnd < 70 ){ //Lancer - Scourge
      	//Lancer-Scourge
        if( skCanBuildTemplate( player ,_factory, vtols[0]) ){ _t = 0; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[2]) ){ _t = 2; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[4]) ){ _t = 4; }
      	if( skCanBuildTemplate( player ,_factory, vtols[6]) ){ _t = 6; }
      	if( skCanBuildTemplate( player ,_factory, vtols[7]) ){ _t = 7; }
      	 if ( _t == -1 ){ //backup
          if( skCanBuildTemplate( player ,_factory, vtols[1]) ){ _t = 1; } 
        	if( skCanBuildTemplate( player ,_factory, vtols[3]) ){ _t = 3; }
        	if( skCanBuildTemplate( player ,_factory, vtols[5]) ){ _t = 5; }
         }
      } else {//HPV
        if( skCanBuildTemplate( player ,_factory, vtols[1]) ){ _t = 1; } 
      	if( skCanBuildTemplate( player ,_factory, vtols[3]) ){ _t = 3; }
      	if( skCanBuildTemplate( player ,_factory, vtols[5]) ){ _t = 5; }
    	  if ( _t == -1 ){ //backup
          if( skCanBuildTemplate( player ,_factory, vtols[0]) ){ _t = 0; } 
        	if( skCanBuildTemplate( player ,_factory, vtols[2]) ){ _t = 2; } 
        	if( skCanBuildTemplate( player ,_factory, vtols[4]) ){ _t = 4; }
        	if( skCanBuildTemplate( player ,_factory, vtols[6]) ){ _t = 6; }
        	if( skCanBuildTemplate( player ,_factory, vtols[7]) ){ _t = 7; }
    	  }
      } 
          
    }
  }
	
	if ( _t == -1 ){
   //dbg("vtolFactoryBuildVtol: tmplate not found lancer("& researchFinished(lancerATweap,player) &") scorpion("& researchFinished(scorpionBody,player) &") _t("& _t &"), _bBombVTOL("& _bBombVTOL &") _nTemplBomb("& _nTemplBomb &") _nTemplAT("& _nTemplAT &")_nRnd("& _nRnd &") ",player);
	 exit;
  }
  
	if( skCanBuildTemplate( player ,_factory, vtols[_t]) ){
   //printDebug1("vtolFactoryBuildVtol: build VTOL _t("& _t &"), _bBombVTOL("& _bBombVTOL &") _nTemplBomb("& _nTemplBomb &") _nTemplAT("& _nTemplAT &") _nRnd("& _nRnd &") lancer("& researchFinished(lancerATweap,player) &") scorpion("& researchFinished(scorpionBody,player) &")");
    buildDroid(vtols[_t],_factory,player,1);
  } 
  //else {
    //dbg("vtolFactoryBuildVtol: CANNOT build VTOL; lancer("& researchFinished(lancerATweap,player) &") scorpion("& researchFinished(scorpionBody,player) &") _t("& _t &"), _bBombVTOL("& _bBombVTOL &") _nTemplBomb("& _nTemplBomb &") _nTemplAT("& _nTemplAT &")_nRnd("& _nRnd &") ",player);
  //}
	
	
}
//-----------------------------------------------------------------------------
function void deactivateTankAttack()
{
  tTanksSentToGathering      = 0;
  tTankAttackAction          = 0;
  bTankAttIsOn               = false;       
  lTankSentToGatheringPoint  = false;
  bTankAlreadyGathered       = false;
  nTankGatheringX            = -1; 
  nTankGatheringY            = -1;
  tankAttackX                = -1;
  tankAttackY                = -1;
  targetPlayerTank           = -1;
  attackTankObj              = NULLOBJECT;
  bAttackTeamAttacked        = false;
  bAttackingHumanDerrick     = false; 
  bFinalAttack_1vs1          = false;
  setEventTrigger(TankAttack,inactive);
}
//-----------------------------------------------------------------------------
function void deactivateCybAttack()
{
  bCybAttIsOn               = false;
  lCybSentToGatheringPoint  = false;
  bCybAlreadyGathered       = false;
  cybAttackX                = -1;
  cybAttackY                = -1;
  nCybGatheringX            = -1; 
  nCybGatheringY            = -1;
  targetPlayerCyb           = -1;
  tCybSentToGathering       = 0;
  tCybAttackAction          = 0;
  bAttackTeamAttacked        = false; 
  bAttackingHumanDerrick     = false; 
  setEventTrigger(CyborgAttack,inactive);
}
//-----------------------------------------------------------------------------
function bool harvestNearOilRes()
{
  local FEATURE _oilRes, _bestOilRes;
  local DROID _droid;
  local int _n,_t,_xCoord,_yCoord,_player,_tempDist,_bestDist,_dist;
  local bool _okToProceed;
  
  _oilRes       = NULLOBJECT;
  _bestOilRes   = NULLOBJECT;
  _okToProceed  = true;
  _bestDist     = 9999*TILE;

  if ( nMyDerricks >= numMaxDerricks  ) { return false; }
  
  _droid = closestDroidCanBuild(cybConstGrp,baseX,baseY);//needed for droidCanReach
  if( _droid != NULLOBJECT ) {

    initGetFeature(oilRes,player,player);
  	_oilRes = getFeature(player);
    	
    while(_oilRes != NULLOBJECT)
  	{
 		  
       if ( droidCanReach(_droid, _oilRes.x ,_oilRes.y) ) {
        
        //check oilRes is not in Ally base range
   		  _okToProceed = true;	
        _player=0;
        while (_player < MAX_PLAYERS)
      	{
          //check oilRes is not in range of an Ally base, leave this oilRes to the Ally 
          if ( friendlyPlayer(_player) and _player != player and isPlayerStillLive(_player) ){//OK

            _xCoord = aPl[_player][X_COORD];
            _yCoord = aPl[_player][Y_COORD];
            _dist = max(nBaseRange,25*TILE);
            
            if ( _xCoord > 0 and _yCoord > 0 ){
              if ( distBetweenTwoPoints(_oilRes.x ,_oilRes.y ,_xCoord ,_yCoord ) < _dist )
              { _okToProceed = false; }
            } else {
              printDebug1("#### harvestNearOilRes(); cannot get friendly base coordinates for friendly player ("& getPlayerName(_player) &") to check if oilres is in his base range");
            }
          }
          
          _player++;
        }//endwhile

        //Check this oilRes is not too far away, trucks will harvest anyway
        _n  = ((mapWidth+mapHeight)/2)*TILE;
        _n  = (_n/2);//half map
        _t = distBetweenTwoPoints(_oilRes.x ,_oilRes.y , baseX , baseY); 
        if ( _t > _n )
        { _okToProceed = false; }
        

        //check for threats in range
        if ( threatInRange(player ,_oilRes.x, _oilRes.y, THREAT_RANGE_TILES_SHORT*128, false) )
        { _okToProceed = false; }

        if ( _okToProceed  ){
          _tempDist = distBetweenTwoPoints(_oilRes.x, _oilRes.y, _droid.x, _droid.y);
      		if(_tempDist < _bestDist )	
      		{
      			_bestOilRes = _oilRes;
      			_bestDist = _tempDist;
      		}
      	}
        
      }//endif droidCanReach
      
   		_oilRes = getFeature(player);
    }//while
      

  } 
  if ( _bestOilRes != NULLOBJECT ){
    _droid = closestIdleDroid(cybConstGrp,_bestOilRes.x,_bestOilRes.y);
    if ( _droid == NULLOBJECT and (buildDefGrp.members + buildGrp.members) < 4 ){
      _droid = closestDroidCanBuild(cybConstGrp,_bestOilRes.x, _bestOilRes.y);
    }
    if ( _droid != NULLOBJECT ) { 
      if ( droidCanReach( _droid, _bestOilRes.x, _bestOilRes.y) ){
        tHarvestNearOilRes = gameTime;
        orderDroidStatsLoc( _droid, DORDER_BUILD, derrick, _bestOilRes.x, _bestOilRes.y);
        return true;
      }
    }
  } 
  
  return false;
}
//-----------------------------------------------------------------------------
function int getOilResTargetFree()
{
  local int _i;
  _i = 0;
  while ( _i < 11 )
  {
    //dbg("getOilResTargetFree: _i ("& _i &") id("& oilResTargetId[_i]  &")",player);
    if (oilResTargetId[_i] == -1)
    {
      return _i;
    }
    _i++;
  }
  return -1;
}


//-----------------------------------------------------------------------------
function void checkDerrickIsBuilt(int _player)
{
  local STRUCTURE _structure;
  local FEATURE _tempOilRes;
  local int _i, _cc,_el;
  
  //if no oliRes left then reset the array!
  initGetFeature(oilRes,-1,player);
	_tempOilRes = getFeature(player);
  _i =  0;
  while(_tempOilRes != NULLOBJECT and _i < MAX_WHILE_LOOPS)
	{
	 _i++;
	 _tempOilRes = getFeature(player);
	}
	
	if( _i == 0 ){
    //general reset of array
    _cc = 0;
    while ( _cc < 11 )
    {
        oilResTargetId[_cc] = -1; oilResTargetX[_cc] = -1; oilResTargetY[_cc] = -1;
        _cc++;
    }
  }

  _el =  0;
  initEnumStruct(false,derrick,_player,_player);
  _structure= enumStruct();
  //displayMsg("checkDerrickIsBuilt player (" & _player & ")" ); /* -------DEBUG MESSAGE -------------- */
  while ( _structure != NULLOBJECT )
  {
    while ( _el < 11 )
    {
       if (( _structure.x == oilResTargetX[_el] ) and ( _structure.y == oilResTargetY[_el] ) and ( structureComplete(_structure) ))
       {
         //dbg("*** checkDerrickIsBuilt: derrick (" & _structure.id & ") completed, array pos ("& _el &") is free",player ); /* -------DEBUG MESSAGE -------------- */
         oilResTargetId[_el]  = -1;
         oilResTargetX[_el]   = -1;
         oilResTargetY[_el]   = -1;
       } 
        //else { if (  _structure.x == oilResTargetX[_el]  and  _structure.y == oilResTargetY[_el]  ){displayMsg("checkDerrickIsBuilt: derrick (" & _structure.id & ") being built" ); }}
      _el++;
    }
    _el = 0;
    _structure= enumStruct(); 
  }
}
//-----------------------------------------------------------------------------
function void stopDroidHarvesting()
{
  local int _player, _dist, _dist2, _c2;
 
  _player=0;
  
  if ( harvesterGroup.members == 0 and cybConstGrp.members == 0){return;}
    
  while ( _player < MAX_PLAYERS )
  {
    initEnumStruct(false,derrick,_player,_player);
    structure= enumStruct();
    _c2=0;
    while ( structure != NULLOBJECT and _c2 < MAX_WHILE_LOOPS)
    {
      //check harvesting team first
      initIterateGroup(harvesterGroup);
    	droid = iterateGroup(harvesterGroup);
    	while(droid != NULLOBJECT)
    	{
        if( droid.orderx == structure.x and droid.ordery == structure.y ){
      	  _dist = distBetweenTwoPoints(structure.x,structure.y,droid.x,droid.y);
          if( _dist > 3*TILE ){
   		      //dbg("dbg->stopDroidHarvesting: truck ("& droid.id &") harvesting at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
            if ( bOilResLeft ){
      		    //dbg("dbg->stopDroidHarvesting: a) stop harvesting truck ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
              orderDroid( droid, DORDER_STOP );
            } else {
		          if( _dist < 20 * TILE and !threatInRange(player,structure.x,structure.y, THREAT_RANGE_TILES*128, false))
              {
      		      //dbg("dbg->stopDroidHarvesting: stop harvesting truck ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &"), order build def here!!!",player);
                boolResult = buildDefStruct(droid,structure.x,structure.y);
                if ( !boolResult ){//cannot reach location!
      		        //dbg("dbg->stopDroidHarvesting: harvesting truck ("& droid.id &") cannot build def at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &"), order build def here!!!",player);
                  orderDroid( droid, DORDER_RTB );
                }
              } else {
      		      //dbg("dbg->stopDroidHarvesting: b) stop harvesting truck ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
                orderDroid( droid, DORDER_RTB );
              }
            }
      		}
    		}
    		droid = iterateGroup(harvesterGroup);
      }
      //check cyborg engineers
      initIterateGroup(cybConstGrp);
    	droid = iterateGroup(cybConstGrp);
    	while(droid != NULLOBJECT)
    	{
        if( droid.orderx == structure.x and droid.ordery == structure.y ){
      	  _dist = distBetweenTwoPoints(structure.x,structure.y,droid.x,droid.y);
          if( _dist > 3*TILE ){
   		      //dbg("dbg->stopDroidHarvesting: cyborg ("& droid.id &") harvesting at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
            if ( bOilResLeft ){
      		    //dbg("dbg->stopDroidHarvesting: a) stop harvesting cyborg ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
              orderDroid( droid, DORDER_STOP );
            } else {
		          if( _dist < 20* TILE and !threatInRange(player,structure.x,structure.y, THREAT_RANGE_TILES*128, false))
              {
      		      //dbg("dbg->stopDroidHarvesting: stop harvesting cyborg ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &"), order build def here!!!",player);
                boolResult = buildDefStruct(droid,structure.x,structure.y);
                if ( !boolResult ){orderDroid( droid, DORDER_RTB ); }
              } else {
      		      //dbg("dbg->stopDroidHarvesting: b) stop harvesting cyborg ("& droid.id &") at ("& structure.x/TILE &"-"& structure.y/TILE &") distance ("& _dist/TILE &")",player);
                orderDroid( droid, DORDER_RTB );
              }
            }
      		}
    		}
    		droid = iterateGroup(cybConstGrp);
      }
      
      structure= enumStruct();
      _c2++; 
    }
    _player++;
  }

  //check if any threat is in range
  initIterateGroup(harvesterGroup);
	droid = iterateGroup(harvesterGroup);
	while(droid != NULLOBJECT)
	{
	  _dist = distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y);
    if ( _dist > 4*TILE and threatInRange(player,droid.orderx,droid.ordery, THREAT_RANGE_TILES*128, false) )
    {
      //dbg("dbg->stopDroidHarvesting: THREAT stop truck ("& droid.id &") harvesting at ("& droid.orderx/TILE &"-"& droid.ordery/TILE &") distance ("& _dist/TILE &")",player);
      orderDroid( droid, DORDER_RTB );
  	}
		droid = iterateGroup(harvesterGroup);
  }
  
  initIterateGroup(cybConstGrp);
	droid = iterateGroup(cybConstGrp);
	while(droid != NULLOBJECT)
	{
	  _dist2 = distBetweenTwoPoints(baseX,baseY,droid.x,droid.y);
	  _dist  = distBetweenTwoPoints(droid.orderx,droid.ordery,droid.x,droid.y);
    if ( _dist2 > nBaseRange and _dist > 4*TILE and threatInRange(player,droid.orderx,droid.ordery, THREAT_RANGE_TILES*128, false) )
    {
      //dbg("dbg->stopDroidHarvesting: THREAT stop cyb eng ("& droid.id &") harvesting at ("& droid.orderx/TILE &"-"& droid.ordery/TILE &") distance ("& _dist/TILE &")",player);
      orderDroid( droid, DORDER_RTB );
  	}
		droid = iterateGroup(cybConstGrp);
  }
   
  return;
}
//-----------------------------------------------------------------------------
function bool buildDefStruct(DROID _droid, int _x, int _y )
{
  local int _t;
  _t = max(pickDefQueueDepth - 1 - random(3),0);
	if( isStructureAvailable(pickDefQueue[_t],player) )
	{
		buildX = _x ;
		buildY = _y ;
		if(pickStructLocation(pickDefQueue[_t], ref buildX, ref buildY,player))
		{
			 if (droidCanReach(_droid, buildX, buildY) ){
         orderDroidStatsLoc(_droid, DORDER_BUILD, pickDefQueue[_t], buildX, buildY); 				
         //displayMsg("buildDefStruct: droid ("& _droid.id &") build def ["& _t &"] best is ["& pickDefQueueDepth &"] " );
         return true;
       }
		}	
	}  
  return false;
} 

//-----------------------------------------------------------------------------
function int getWeaponUnitsInfo( int _player, int _choice)
{

  if ( _choice == WUI_TOTUNITS){
    return aStat[OC_CYBORGS][_player] + aStat[OC_TANKS][_player];
  }
  if ( _choice == WUI_POWER){
    return aStat[OC_CYB_POWER][_player] + aStat[OC_TK_POWER][_player];
  }
  if ( _choice == WUI_HP){
    return aStat[OC_CYB_HP][_player] + aStat[OC_TK_HP][_player];
  }
  return -1;
}
//-----------------------------------------------------------------------------
function float getPowerIndex(int _player)
{
  
  
  local RESEARCHSTAT _powUpgrades[7];
  local int _powUpgrPerc[7],_nArr,_index,_nLastRes, _nDerricks;
  local float _powIndRet;
  _nArr = 7;

  _powUpgrades[0] = powUpgrades0; 
  _powUpgrades[1] = powUpgrades1;
  _powUpgrades[2] = powUpgrades2;
  _powUpgrades[3] = powUpgrades3;
  _powUpgrades[4] = powUpgrades4;
  _powUpgrades[5] = powUpgrades5;
  _powUpgrades[6] = powUpgrades6;

  _powUpgrPerc[0] = 125; 
  _powUpgrPerc[1] = 150; 
  _powUpgrPerc[2] = 175; 
  _powUpgrPerc[3] = 200; 
  _powUpgrPerc[4] = 230; 
  _powUpgrPerc[5] = 260; 
  _powUpgrPerc[6] = 290; 

  _nLastRes = -1;
  _index = 0;
  while ( _index < _nArr ){
    if (researchFinished( _powUpgrades[_index],_player) ){
      _nLastRes = _index;
    } //else {  displayMsg("getPowerIndex: NO _player("& _player &") _index("& _index &") completed("& researchFinished( _powUpgrades[_index],_player) &")" );}
    _index++;
  }
  _nDerricks = getNumDerricks(_player);
  
  if ( _nLastRes != -1 )
  {
    _powIndRet = (float)_nDerricks * ((float)_powUpgrPerc[_nLastRes]/(float)100);
    return _powIndRet; 
  } //else { displayMsg("dbg -> getPowerIndex: NO _player ("& _player &") _nLastRes("& _nLastRes &") " );}
  
  return (float)_nDerricks; 
  //researchFinished(res,pl)
  
}
//-----------------------------------------------------------------------------
function int getNumDerricks(int _player)
{
  local int _count;
  local STRUCTURE _structure;
  _count = 0;
  initEnumStruct(false,derrick,_player,_player);
  _structure= enumStruct();
  while ( _structure != NULLOBJECT )
  {
    _count++;
    _structure= enumStruct();  
  }
  return _count;
}

//-----------------------------------------------------------------------------
// show a debug message, ca be activated/deactivated
function void displayMsg(STRING _message)
{
  if( isHumanPlayer(player) )
  { 
    dbg(_message, player);
  }
}
//-----------------------------------------------------------------------------
// show a debug message -> reports error
function void  dropBeaconToAllies(STRING _message, int _x, int _y, int _z, bool _bToHuman)
{
  local int _toPlayer;
  _toPlayer = 0;
  
  //avoid too many blips...
  if ( _message != "help" ){
    if ( (gameTime - tBeaconSent) < 2*TIME_MINUTE ){ return; }
  } else {
    if ( (gameTime - tBeaconSent) < 1*TIME_MINUTE ){ return; }
  }
  
  while ( _toPlayer < MAX_PLAYERS ){
    if( friendlyPlayer(_toPlayer) ){ 
      if ( _bToHuman ){
        if ( isHumanPlayer(_toPlayer) ){
          dropBeacon( _message, _toPlayer, player, _x, _y, _z );
          msg( _message, player, _toPlayer);
        }
      } else { //send msg to AI
        if ( !isHumanPlayer(_toPlayer) ){
          dropBeacon( _message, _toPlayer, player, _x, _y, _z );
          msg( _message, player, _toPlayer);
        } else {
          dropBeacon( _message, _toPlayer, player, _x, _y, _z );
          msg( _message, player, _toPlayer);
        }
      }
    }
    _toPlayer++;
  }
  tBeaconSent = gameTime;
  return;
  
}

//-----------------------------------------------------------------------------
// show a debug message -> reports error
function void sendMsgToAllAllies(STRING _message, bool _bToHuman )
{
  local int _player; 
  local bool _bProceed;
  
  _player = 0;
  
  while ( _player < MAX_PLAYERS ){

    _bProceed = true;
    if ( _bToHuman and !isHumanPlayer(_player) ){
      _bProceed = false;
    }
    if( _bProceed and friendlyPlayer(_player) and _player != player )
    { 
      msg(_message, player, _player );
    }
    _player++;
  }
}
//-----------------------------------------------------------------------------
// show a debug message -> reports error
function void displayErrMsg(STRING _message)
{
  local int _player; 
  _player = 0;
  while ( _player < MAX_PLAYERS ){
    if( isHumanPlayer(_player) )
    { 
      dbg(_message, _player);
    }
    _player++;
  }
}
//-----------------------------------------------------------------------------
// Return an AA defence as target for 
// VTOL: _nDefInRange*3 < vtolGr.members
// DROID: _nDefInRange < 1 
function STRUCTURE getAAStruct(bool _bVTOLTarget)
{
  local	int	_n, _bestDist, _tempDist, _targetPl, _dist, _dist2;
  local int _numPl,_nDefInRange,_xCoord,_yCoord;
	local	STRUCTURE		_bestAAdef, _tempAAdef, _BaseStruct;
  
	_bestDist   = 999*TILE;
	_bestAAdef  = NULLOBJECT;
	_numPl      = 0;//avoid to start always from player 0
  _targetPl   = random(MAX_PLAYERS);//avoid to start always from player 0
  
  while(_numPl < MAX_PLAYERS)
	{
  	
    if ( !friendlyPlayer(_targetPl) and isPlayerStillLive(_targetPl) ){
      //displayMsg("undefendedEnemyAAdef:   AAdef x-y("& _targetPl &"-"& count &")");
      //find enemy HQ and check distance to AAdef
      _dist = 0;

      _xCoord = aPl[_targetPl][X_COORD];
      _yCoord = aPl[_targetPl][Y_COORD];

      if ( _xCoord > 0 and _yCoord > 0 ){
        //only AAdefs visible to player (myself) are processed
        
        _n=0;
        while (_n < numGenAA){
          
          if ( AIstrength < 4 ){
            initEnumStruct(false,vtolGenStruct[_n],_targetPl,player); //only struct visible to player
          } else {
            initEnumStruct(false,vtolGenStruct[_n],_targetPl,_targetPl); //all structs, also those not visible to player
          }
        	_tempAAdef = enumStruct();
        	while(_tempAAdef != NULLOBJECT)
        	{
            _tempDist = distBetweenTwoPoints(_tempAAdef.x, _tempAAdef.y, baseX, baseY);
            _dist     = distBetweenTwoPoints(_xCoord, _yCoord, _tempAAdef.x, _tempAAdef.y);
            _dist2    = distBetweenTwoPoints(_xCoord, _yCoord, baseX, baseY);
     
            if ( _bVTOLTarget ){
              _nDefInRange = getAA_OnTheWay(baseX, baseY, _tempAAdef.x, _tempAAdef.y, AA_THREAT_RANGE);
              if ( _dist2 > _tempDist and _tempDist < _bestDist and _dist > nBaseRange and _nDefInRange*4 < vtolGr.members ){
                _bestAAdef   = _tempAAdef;
                _bestDist    = _tempDist;
             	}
            } else {
              _nDefInRange = numEnemyWeapStructsInRange(player, _tempAAdef.x, _tempAAdef.y, COMBAT_RANGE , false);
              if (_tempDist < _bestDist and _dist > nBaseRange and _nDefInRange < 1 ){
                _bestAAdef   = _tempAAdef;
                _bestDist    = _tempDist;
             	}
            }
            
         		_tempAAdef = enumStruct();
         	}//while
         	
          _n++;
       	}//while    
      } //coord    	
   	} //friendly player
 	  _targetPl++;
 	  if ( _targetPl > 7 ){ _targetPl = 0; }
 	  _numPl++;
  }//endwhile players
  
  return _bestAAdef;
}
//-----------------------------------------------------------------------------
// Return a derrick as target for 
// VTOL: _nDefInRange*3 < vtolGr.members
// DROID: _nDefInRange < 1 
function STRUCTURE undefendedEnemyDerrick(bool _bVTOLTarget)
{
  local	int	_bestDist, _tempDist, _targetPl, _dist, _numPl,_nDefInRange;
  local int _xCoord,_yCoord;
	local	STRUCTURE		_derrick, _tempDerrick, _BaseStruct;
  
	_bestDist   = 999*TILE;
	_derrick    = NULLOBJECT;
	_numPl      = 0;//avoid to start always from player 0
  _targetPl   = random(MAX_PLAYERS);//avoid to start always from player 0
  
  while(_numPl < MAX_PLAYERS)
	{
  	
    if ( !friendlyPlayer(_targetPl) and isPlayerStillLive(_targetPl) ){
      //displayMsg("undefendedEnemyDerrick:   derrick x-y("& _targetPl &"-"& count &")");
      _dist = 0;
      _xCoord = aPl[_targetPl][X_COORD];
      _yCoord = aPl[_targetPl][Y_COORD];

      if ( _xCoord > 0 and _yCoord > 0 ){
        //only derricks visible to player (myself) are processed
        if ( AIstrength < 4 ){
          initEnumStruct(false,derrick,_targetPl,player); //only struct visible to player
        } else {
          initEnumStruct(false,derrick,_targetPl,_targetPl); //all structs, also those not visible to player
        }
      	_tempDerrick = enumStruct();
      	while(_tempDerrick != NULLOBJECT )
      	{
          _tempDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY);
          _dist     = distBetweenTwoPoints(_xCoord, _yCoord, _tempDerrick.x, _tempDerrick.y);
          if ( _bVTOLTarget ){
            _nDefInRange = getAA_OnTheWay(baseX, baseY,_tempDerrick.x, _tempDerrick.y, AA_THREAT_RANGE);
            if (_tempDist < _bestDist and _dist > nBaseRange+3*TILE and _nDefInRange*4 < vtolGr.members ){
              //dbg("derr: id("& _derrick.id &") pl("& _targetPl &") dist("& _tempDist/TILE &")<("& _bestDist/TILE &") ("& _dist/TILE &")<("& nBaseRange/TILE &")+3 aa("& _nDefInRange &")*4<("& vtolGr.members &")",player);
              _derrick   = _tempDerrick;
              _bestDist  = _tempDist;
           	}
          } else {
            _nDefInRange = numEnemyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, COMBAT_RANGE , false);
            if (_tempDist < _bestDist and _dist > 20*TILE and _nDefInRange < 1 ){
              _derrick   = _tempDerrick;
              _bestDist  = _tempDist;
           	}
          }
          
       		_tempDerrick = enumStruct();
       	}//while
     	}//struct
       	
     	
   	}
 	  _targetPl++;
 	  if ( _targetPl > 7 ){ _targetPl = 0; }
 	  _numPl++;
  }//endwhile players
  
  return _derrick;
}
//-----------------------------------------------------------------------------
function STRUCTURE closestEnemyDerrick(bool _mustBeHuman, int _targetPlayer)
{
	
  local	int				  _dist2, _bestDist, _tempDist, _targetPl, _dist,_xCoord,_yCoord ;
	local	STRUCTURE		_derrick, _tempDerrick;
	local bool _bProceed;
  
	_bestDist   = 9999*TILE;
	_derrick    = NULLOBJECT;
	_targetPl   = 0;//avoid to start always from player 0
  
  while(_targetPl < MAX_PLAYERS)
	{
  	
    _bProceed = true;
    if ( _mustBeHuman and !isHumanPlayer(_targetPl) ){
      _bProceed = false;
    }
    //a target player is required?
    if ( _targetPlayer >= 0 and _targetPlayer != _targetPl ){
      _bProceed = false;
    }

    if ( !friendlyPlayer(_targetPl) and _bProceed ){
  
      //displayMsg("closestEnemyDerrick:   derrick x-y("& _targetPl &"-"& count &")");
      //find enemy HQ and check distance to derrick
      _dist = 0;
      _xCoord = aPl[_targetPl][X_COORD];
      _yCoord = aPl[_targetPl][Y_COORD];

      if (_xCoord>0 and _yCoord>0 ){
        initEnumStruct(false,derrick,_targetPl,_targetPl);
      	_tempDerrick = enumStruct();
      	while( _tempDerrick != NULLOBJECT )
      	{
          _tempDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY);
          _dist     = distBetweenTwoPoints(_xCoord, _yCoord, _tempDerrick.x, _tempDerrick.y);
          _dist2    = distBetweenTwoPoints(_xCoord, _yCoord, baseX, baseY);
   
          if ( _tempDist < _bestDist and _dist > nBaseRange and _dist2 > _tempDist ){
            //dbg("closestEnemyDerrick: OK _targetPl("& _targetPl &") _dist("& _dist/TILE &") > 20 TILES  _dist2("& _dist2/TILE &") > _tempDist("& _tempDist/TILE &") _tempDerrick("& _tempDerrick.id &") derrick x-y("& _tempDerrick.x/TILE &"-"& _tempDerrick.y/TILE &")",player);
            _derrick   = _tempDerrick;
            _bestDist  = _tempDist;
         	} 
       		
          _tempDerrick = enumStruct();
       	}//while
     	}
       	
     	
   	}
 	  _targetPl++;
  }//endwhile players
  
  return _derrick;
  
}
//-----------------------------------------------------------------------------
/*
 Used to pick up the most appropriate Derrick to defend.
 It also check that the Derrick has already enough defences or not. 
*/
function STRUCTURE closestDerrickToDefend()
{
	local	int				    _nMaxDef, _bestDist, _derrickDist;
  local	STRUCTURE		  _derrick, _tempDerrick;
	local bool         _OK1, _OK2;

  if ( AIPersonality == AI_TURTLE ){      
    if ( pickWallDefQueueDepth <= 0 ){_nMaxDef = MAX_DEFSTR_DERRICKS;}
    if ( pickWallDefQueueDepth == 1 ){_nMaxDef = MAX_DEFSTR_DERRICKS+1;}
    if ( pickWallDefQueueDepth == 2 ){_nMaxDef = MAX_DEFSTR_DERRICKS+2;}
    if ( pickWallDefQueueDepth > 2 ) {_nMaxDef = MAX_DEFSTR_DERRICKS+3;}
  } else {
    if ( pickWallDefQueueDepth >= 2 ){_nMaxDef = MAX_DEFSTR_DERRICKS+1;}
  }
  //keep low the number of def in the initial phase of the game
  if ( gameTime < 30*TIME_MINUTE ){_nMaxDef = MAX_DEFSTR_DERRICKS;}

  
	_bestDist      = 999*TILE;
	_derrick       = NULLOBJECT;

  
	if( !isStructureAvailable(pickDefQueue[pickDefQueueDepth],player) )
	{
	 return _derrick;
	}

  initEnumStruct(false,derrick,player,player);
	_tempDerrick = enumStruct();

	while(_tempDerrick != NULLOBJECT)
	{
 		_OK1 = false;
 		_OK2 = false;
    _derrickDist = distBetweenTwoPoints(_tempDerrick.x,_tempDerrick.y, baseX, baseY);
    if( _derrickDist > max(nBaseRange,15*TILE) )
 		{
   		
       //check derrick area
       if( numFriendlyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, TILE*5, false) < _nMaxDef)
      {
 	      if ( _derrickDist < _bestDist )
        {
          _OK1 = true;
          //displayMsg("closestDerrickToDefend: ("& _tempDerrick.id &") distance ("& _OK1 &")("& _OK2 &") !!");  
	      } 
      } //else { displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") already with defences in DERRICK AREA" );   }
      
      //now check the building area
      buildX = _tempDerrick.x;
      buildY = _tempDerrick.y;
            
      boolResult = pickStructLocation(pickDefQueue[pickDefQueueDepth], ref buildX, ref buildY, player);
  		if(boolResult)
  		{
  		  //check for defence structs in BUILDING area, this is an HACK
  		  if( numFriendlyWeapStructsInRange(player, buildX, buildY, TILE*6, false) < MAX_DEFSTR_DERRICKS){
          _OK2 = true;
        } //else { displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") already with defences in BUILD AREA" );   }
      } //else { displayMsg("closestDerrickToDefend: cannor build a def struct around ("& _tempDerrick.id &") " );   }
           
      if ( _OK1 and _OK2 )
      {
        _derrick   = _tempDerrick;
        _bestDist  = _derrickDist;
      } 
       
    } //else { //displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") is in the base" );  }
  	_tempDerrick = enumStruct();
  }//endwhile
	return _derrick;
}
//-----------------------------------------------------------------------------
//Pick up the closest oilRes at given coord and check that oliRes is not already
//a "target" of another droid
function STRUCTURE closestOilRes(DROID _droid, int _x, int _y)
{
	local	int	_bestDist,_tempDist, _nOilResFound, _i, _ii, _player;
	local	FEATURE	_closestOilRes,_tempOilRes;
  local bool _okToProceed;
  local STRUCTURE _hq;
  
	_bestDist = 999*TILE;
	_closestOilRes = NULLOBJECT;
  _okToProceed = TRUE;
  _nOilResFound = 0;
	
	_player=0;
  while (_player < MAX_PLAYERS)
	{
    initGetFeature(oilRes,-1,player);
  	_tempOilRes = getFeature(player);  	
    _ii = 0;
    while(_tempOilRes != NULLOBJECT and _ii < MAX_WHILE_LOOPS)
  	{

      //check the oilRes can be reached      
      if ( _droid != NULLOBJECT ){//droid is set in harvestoperate and cannot be NULLOBJECT
        if ( !droidCanReach(_droid, _tempOilRes.x ,_tempOilRes.y)){
          _okToProceed = false;
        }
      } else {
          _okToProceed = false;
      }
      //displayMsg("OilRes ("& _tempOilRes.id &") @("& _tempOilRes.x/TILE &")("& _tempOilRes.y/TILE &") can be reached ("& _okToProceed &") by droid ("& _droid.id &")");

      //check that this OilRes is not already a "target" of a droid
      if ( gameTime < TIME_HARVESTING_PHASE ){
        _i = 0;
        while (_i < 11)
        {    
          if ( _tempOilRes.id == oilResTargetId[_i] ){  
            _okToProceed = false; 
          }
      		_i++;
    		}
  		}
  		
      //check oilRes is not in range of an Ally base, leave this oilRes to the Ally 
      if ( _okToProceed and (_player != player) and allianceExistsBetween(_player,player) ){//OK
        _hq = getStructure(playerHQ,_player);
        if ( _hq != NULLOBJECT ) {
          if( distBetweenTwoPoints(_tempOilRes.x ,_tempOilRes.y ,_hq.x ,_hq.y) < 15 * TILE  )
          {
            _okToProceed = false;
          }
        }
      }

      //check for threats in range
      if( gameTime > TIME_HARVESTING_PHASE ){
        if( threatInRange(player ,_tempOilRes.x, _tempOilRes.y, THREAT_RANGE_TILES_LONG*128, false) )
        {
          _okToProceed = false;
        }
      } else {
        if ( threatInRange(player ,_tempOilRes.x, _tempOilRes.y, THREAT_RANGE_TILES_SHORT*128, false) )
        {
          _okToProceed = false;
        }
      }
      
      
      if ( _okToProceed  )	{
        _tempDist = distBetweenTwoPoints(_tempOilRes.x, _tempOilRes.y, _x, _y);
        //displayMsg("Closest Oil Res: oilRes ("& _tempOilRes.id &") dist / best ("& _tempDist/TILE &" / "& _bestDist/TILE &") ("& _tempOilRes.x/TILE &"-"& _tempOilRes.y/TILE &")");
    		if (_tempDist < _bestDist )	
    		{
    			_closestOilRes = _tempOilRes;
    			_bestDist      = _tempDist;
    		}
    	} //else { displayMsg("Closest Oil Res: player ("& player &") cannot proceed for oilRes ("& _tempOilRes.id &") dist ("& distBetweenTwoPoints(_tempOilRes.x, _tempOilRes.y, _x, _y)/TILE &") ("& _tempOilRes.x/TILE &"-"& _tempOilRes.y/TILE &")");  }
  		_tempOilRes = getFeature(player);
  		_nOilResFound++;
  		_okToProceed = true;
  		_ii++;
  	}
  	_player++;
	}

	return _closestOilRes;
}

//-----------------------------------------------------------------------------
function DROID getADroid(GROUP _theGRP)
{
	local DROID _tempTruck,_returnTruck;
  
  _returnTruck = NULLOBJECT;
  
	initIterateGroup(_theGRP);
	_tempTruck = iterateGroup(_theGRP);
	while(_tempTruck != NULLOBJECT)
	{
	   _returnTruck = _tempTruck;
	   _tempTruck = iterateGroup(_theGRP);
	}

	return _returnTruck;
}
//-----------------------------------------------------------------------------
function bool droidOrderIdle(DROID _droid)
{

	if(_droid.order == DORDER_RTB){
		return true;
	}

	if(_droid.order == DORDER_STOP){
		return true;
	}

	if(_droid.order == DORDER_NONE){
		return true;
	}

	if(_droid.order == DORDER_GUARD){
		return true;
	}
	
	return false;
}
//-----------------------------------------------------------------------------
function void debugCentreView(DROID _droid)
{

  local int _player;
  _player = 0;
  if( debugCenterView == true ){  
  	while(_player < 8)
  	{
      if( isHumanPlayer(_player) and allianceExistsBetween(_player,player) ) { //OK 
        centreView(_droid);        
      }
      _player++;
    }
  }
}
//-----------------------------------------------------------------------------
// _x and _y are changed per reference
function int getSafeBuildCoord( DROID _droid, STRUCTURESTAT _struct, int _x, int _y, int _choice)
{
  local int _x1, _y1, _c1, _c2, _c3, _aX[8], _aY[8], _aD[8];

  _c3 = 0;
  while ( _c3 < 8){
    _aX[_c3] = -1;
    _aY[_c3] = -1;
    _aD[_c3] = -1;
    _c3++;
  }
  
  boolResult = pickStructLocation(_struct, ref _x, ref _y, player);
  boolResult2 = droidCanReach(_droid, _x ,_y);
  if ( boolResult and boolResult2 ){
    if ( _choice == 0 ){ return _x; }
    if ( _choice == 1 ){ return _y; }
  }

  _x1 = _x; _y1 = _y;
  _c3 = 1; _c2 = 0;
  while ( _c3 < 3){
  
    _x = _x1 + _c3*TILE;
    _y = _y1 + _c3*TILE;
    boolResult = pickStructLocation(_struct, ref _x, ref _y, player);
    boolResult2 = droidCanReach(_droid, _x ,_y);
    //dbg("dbg->getSafeBuildCoord: try  x-y("& _x/TILE &"-"& _y/TILE &") from ("& _x1/TILE &"-"& _y1/TILE &")",player);
    if ( boolResult and boolResult2 ){
      _aX[_c2] = _x;
      _aY[_c2] = _y;
      _aD[_c2] = distBetweenTwoPoints(_x,_y,_x1,_y1);
      //dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
      _c2++;
    }

    _x = _x1 - _c3*TILE;
    _y = _y1 - _c3*TILE;
    boolResult = pickStructLocation(_struct, ref _x, ref _y, player);
    boolResult2 = droidCanReach(_droid, _x ,_y);
    if ( boolResult and boolResult2 ){
      _aX[_c2] = _x;
      _aY[_c2] = _y;
      _aD[_c2] = distBetweenTwoPoints(_x,_y,_x1,_y1);
      //dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
      _c2++;
    }

    _x = _x1 + _c3*TILE;
    _y = _y1 - _c3*TILE;
    boolResult = pickStructLocation(_struct, ref _x, ref _y, player);
    boolResult2 = droidCanReach(_droid, _x ,_y);
    if ( boolResult and boolResult2 ){
      _aX[_c2] = _x;
      _aY[_c2] = _y;
      _aD[_c2] = distBetweenTwoPoints(_x,_y,_x1,_y1);
      //dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
      _c2++;
    }
  
    _x = _x1 - _c3*TILE;
    _y = _y1 + _c3*TILE;
    boolResult = pickStructLocation(_struct, ref _x, ref _y, player);
    boolResult2 = droidCanReach(_droid, _x ,_y);
    if ( boolResult and boolResult2 ){
      _aX[_c2] = _x;
      _aY[_c2] = _y;
      _aD[_c2] = distBetweenTwoPoints(_x,_y,_x1,_y1);
      //dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
      _c2++;
    }

    _c3++;
  }
  
  _c3 = 0; 
  _c1 = 9999*TILE;
  //find the nearest place to build
  while ( _c3 < _c2 ){
    //dbg("dbg->getSafeBuildCoord: ("& _aX[_c3]/TILE &"-"& _aY[_c3]/TILE &")   dist ("& _aD[_c3]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
    if ( _aD[_c3] < _c1 ){
      _x  = _aX[_c3];
      _y  = _aY[_c3];
      _c1 = _aD[_c3];
    }
    _c3++;
  }

  //dbg("dbg->getSafeBuildCoord: safe build pos found in ("& _x/TILE &"-"& _y/TILE &") dist ("& _c1/TILE &") from ("& _x1/TILE &"-"& _y1/TILE &")",player);

  if ( _choice == 0 ){ return _x; }
  if ( _choice == 1 ){ return _y; }

  return -1;
  
} 
//-----------------------------------------------------------------------------
//sends the defTruck to help building structures. 
//It checks there are no threat in range.
function void helpBuild(DROID _idleTruck)
{
  local STRUCTURE  _structurestat;
  local int _i,_n1,_n2,_n3;
  local bool _bProceed,_bFound;
  
  _i=0;
  _n1=0; _n2=0; _n3=0;

  _bFound = false;  //stop the loop
  
  if ( _idleTruck != NULLOBJECT ) {
  
    //look for wall def structures 
    _bProceed = true;
    while(_i < pickWallDefQueueDepth and _bProceed )
    {
      initEnumStruct(false,pickWallDefQueue[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if ( !structureComplete(_structurestat) ){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y);
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y);
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          } //else {displayMsg("helpBuild: there is some threat in range");}
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
    if ( _bProceed == false ){ _bFound = true; }

    //look for def structures
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while(_i < pickDefQueueDepth and _bProceed )
    {
      initEnumStruct(false,pickDefQueue[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if ( !structureComplete(_structurestat) ){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          } //else {displayMsg("helpBuild: there is some threat in range");}
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
    if ( _bProceed == false ){ _bFound = true; }
    //look for for incendries
    //numIncendrys	INT					8
    //incendrys[7]	STRUCTURESTAT		"Emplacement-MortarPit01"
    //look for def structures first
    _i=0;
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while(_i < numIncendrys and _bProceed)
    {
      initEnumStruct(false,incendrys[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if ( !structureComplete(_structurestat) ){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          } //else {displayMsg("helpBuild: there is some threat in range");}
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
    if ( _bProceed == false ){ _bFound = true; }
  	//look for sensor types
  	//numSense	INT					3
  	//sense[0]		STRUCTURESTAT		"Sys-SensoTowerWS"
    _i=0;
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while(_i < numSense and _bProceed)
    {
      initEnumStruct(false,sense[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if ( !structureComplete(_structurestat) ){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          } //else {displayMsg("helpBuild: there is some threat in range");}
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
  
    if ( _bProceed == false ){ _bFound = true; }
  
  	//look for anti a.
  	//numAA	INT					6
  	//vtolGenStruct[0]	STRUCTURESTAT		"AASite-QuadMg1"			//hurricane
     _i=0;
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while(_i < numGenAA and _bProceed)
    {
      initEnumStruct(false,vtolGenStruct[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if ( !structureComplete(_structurestat) ){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
            if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES*128, false) )
            {
              if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
         				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
                _bProceed = false;
              }
            } //else {displayMsg("helpBuild: there is some threat in range");}
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
     if ( _bProceed == false ){ _bFound = true; }

  	//look for Fortresses structs.
  	//numFortressDef
  	//fortressDef[0]
     _i=0;
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while(_i < numFortressDef and _bProceed)
    {
      initEnumStruct(false,fortressDef[_i],player,player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if(!structureComplete(_structurestat)){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES_SHORT*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          }
          } //else {displayMsg("helpBuild: there is some threat in range");}
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i
  
  
    if ( _bProceed == false ){ _bFound = true; }

   	//look for Essential structs.
  	//numStructs	
  	//structs[0]	
     _i=0;
    _n1=0; _n2=0; _n3=0;
    _bProceed = true;
    while( (_i+1) < numBaseStructs  and _bProceed) //do not help build derricks
    {
      initEnumStruct(false, baseStructs[_i], player, player);
      _structurestat = enumStruct();
      while (_structurestat != NULLOBJECT){
        if(!structureComplete(_structurestat)){
          if ( distBetweenTwoPoints(baseX, baseY, _structurestat.x, _structurestat.y) > nBaseRange )
          {
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y );
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y );
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
          }
          if ( _n1+_n2+_n3 < 2  ){
          if ( !threatInRange(player,_structurestat.x, _structurestat.y, THREAT_RANGE_TILES_SHORT*128, false) )
          {
            if (droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) ){
       				orderDroidObj(_idleTruck,DORDER_HELPBUILD,_structurestat);
              _bProceed = false;
            }
          } 
          }
        }
        _structurestat = enumStruct();
      }//while struct
      _i++;
    }//While _i

    _idleTruck = getNearestIdleDroid(baseX, baseY);
    
    //stop the loop?
    
  }//if _idleTruck
  
  return;
}


//-----------------------------------------------------------------------------
//search for the most damaged structure in the base and repair it
//if found return true, otherwise return false. Return false also
// if not idle trucks are found. it checks there are no threats in range
function bool repairStructs(int _group)
{
	local	int	_mostDamage,_tempDamage, _i,_numStrToCheck,_n1,_n2,_n3;
	local	STRUCTURE	_structure, _mostDamagedStructure;
	local DROID _idleTruck;
	local bool _bProceed;

	_mostDamage            = 0;
	_mostDamagedStructure  = NULLOBJECT;
	_idleTruck             = NULLOBJECT;

  if (_group == BUILDDEF_GRP){  
    _idleTruck = closestIdleDroid(buildDefGrp,baseX, baseY);
  }
  if (_group == CYBENG_GRP){  
    _idleTruck = closestIdleDroid(cybConstGrp,baseX, baseY);
  }
  if (_group == BUILD_GRP){  
    _idleTruck = closestIdleDroid(buildGrp,baseX, baseY);
  }
  if (_group == HARVEST_GRP){  
    _idleTruck = closestIdleDroid(harvesterGroup,baseX, baseY);
  }

  if (_idleTruck == NULLOBJECT){ return false; }


	_i = 0; _n1=0; _n2=0; _n3=0;
	
	_numStrToCheck = (numBaseStructs - 1);
	while( _i < _numStrToCheck )//exclude derricks, threated below in this function
	{
		initEnumStruct(FALSE,baseStructs[_i],player,player);
		_structure = enumStruct();
		while(_structure != NULLOBJECT)
		{
			_tempDamage = 100 - _structure.health;
      if ( distBetweenTwoPoints(baseX, baseY, _structure.x, _structure.y) < nDefendRange )
      {
  			if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          	if(_tempDamage > _mostDamage){
  						_mostDamage           = _tempDamage;
  						_mostDamagedStructure = _structure;
  					}
  			}
  		}
   		_structure = enumStruct();
		}
		_i = _i + 1;
	}

 	if(_mostDamagedStructure != NULLOBJECT)	{
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedStructure);
		return true;
	}

  initEnumStruct(false,derrick,player,player);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
	  _bProceed = true;
    _tempDamage = 100 - _structure.health;
	  if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
      if ( distBetweenTwoPoints(baseX, baseY, _structure.x, _structure.y) > nBaseRange )
      {
        
        
        _n2 = numDroidsBuilding(cybConstGrp, _structure.x, _structure.y );
        _n1 = numDroidsBuilding(buildGrp,    _structure.x, _structure.y );
        _n3 = numDroidsBuilding(buildDefGrp, _structure.x, _structure.y );

        if ( _n1+_n2+_n3 > 0 or threatInRange(player,_structure.x, _structure.y, THREAT_RANGE_TILES*128, false) )
        {
          _bProceed = false;
        }
      }
      if(_tempDamage > _mostDamage and _bProceed){
				_mostDamage           = _tempDamage;
				_mostDamagedStructure = _structure;
			}
		}
   	_structure = enumStruct();
	}
	
 	if(_mostDamagedStructure != NULLOBJECT)	{
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedStructure);
		return true;
	}

  return false;
}

//-----------------------------------------------------------------------------
//search for the most damaged sefense in the base and repair it
//if found return true, otherwise return false. Return false also
// if not idle trucks are found. it checks there are no threats in range
function bool repairDefStructs(int _group)
{
	local	int			_mostDamage,_tempDamage, _i;
	local	STRUCTURE	_defense, _mostDamagedDefense;
	local DROID _idleTruck;

	_mostDamage = 0;
	_mostDamagedDefense = NULLOBJECT;

	_idleTruck = NULLOBJECT;

  if (_group == BUILDDEF_GRP){  
    _idleTruck = closestIdleDroid(buildDefGrp,baseX, baseY);
  }
  if (_group == CYBENG_GRP){  
    _idleTruck = closestIdleDroid(cybConstGrp,baseX, baseY);
  }
  if (_group == BUILD_GRP){  
    _idleTruck = closestIdleDroid(buildGrp,baseX, baseY);
  }
  if (_group == HARVEST_GRP){  
    _idleTruck = closestIdleDroid(harvesterGroup,baseX, baseY);
  }

  if (_idleTruck == NULLOBJECT){ return false; }

//look for vtol def
/*
            _n1 = numDroidsBuilding(buildGrp, _structurestat.x, _structurestat.y);
            _n2 = numDroidsBuilding(cybConstGrp, _structurestat.x, _structurestat.y);
            _n3 = numDroidsBuilding(buildDefGrp, _structurestat.x, _structurestat.y );
*/
  _i=0;
  while(_i < numGenAA )
  {
    initEnumStruct(FALSE,vtolGenStruct[_i],player,player);
    _defense = enumStruct();
    while (_defense != NULLOBJECT){
			if(distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange ){
				_tempDamage = 100 - _defense.health;
				if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          if ( !threatInRange(player,_defense.x, _defense.y, THREAT_RANGE_TILES*128, false) ) {
          	if(_tempDamage > _mostDamage)	{
  						_mostDamage = _tempDamage;
  						_mostDamagedDefense = _defense;
  					}
					}
				}
      }
      _defense = enumStruct();
    }//while struct
    _i++;
  }//While _i
	if(_mostDamagedDefense != NULLOBJECT)
	{
    //displayMsg("**** repairDefStructs: found a damaged def struct damage=("& _mostDamage &") ");
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}

  _i=0;
  //look for def structures 
  while(_i < pickWallDefQueueDepth )
  {
    initEnumStruct(FALSE,pickWallDefQueue[_i],player,player);
    _defense = enumStruct();
    while (_defense != NULLOBJECT){
			if(distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange ){
				_tempDamage = 100 - _defense.health;
				if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          if ( !threatInRange(player,_defense.x, _defense.y, THREAT_RANGE_TILES*128, false) ) {
          	if(_tempDamage > _mostDamage)	{
  						_mostDamage = _tempDamage;
  						_mostDamagedDefense = _defense;
  					}
					}
				}
      }
      _defense = enumStruct();
    }//while struct
    _i++;
  }//While _i
  if(_mostDamagedDefense != NULLOBJECT)	{
    //displayMsg("**** repairDefStructs: found a damaged WALL def struct damage=("& _mostDamage &") ");
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}

  _i=0;
  //look for def structures 
  while(_i < pickDefQueueDepth )
  {
    initEnumStruct(FALSE,pickDefQueue[_i],player,player);
    _defense = enumStruct();
    while (_defense != NULLOBJECT){
			if(distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange ){
				_tempDamage = 100 - _defense.health;
				if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          if ( !threatInRange(player,_defense.x, _defense.y, THREAT_RANGE_TILES*128, false) ) {
          	if(_tempDamage > _mostDamage)	{
  						_mostDamage = _tempDamage;
  						_mostDamagedDefense = _defense;
  					}
					}
				}
      }
      _defense = enumStruct();
    }//while struct
    _i++;
  }//While _i
  if(_mostDamagedDefense != NULLOBJECT)	{
    //displayMsg("**** repairDefStructs: found a damaged def struct damage=("& _mostDamage &") ");
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}

   //double check...
   if (_idleTruck == NULLOBJECT){ return false; }

 //look for for incendries
  _i=0;
  while(_i < numIncendrys )
  {
    initEnumStruct(FALSE,incendrys[_i],player,player);
    _defense = enumStruct();
    while (_defense != NULLOBJECT){
			if(distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange ){
				_tempDamage = 100 - _defense.health;
				if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          if ( !threatInRange(player,_defense.x, _defense.y, THREAT_RANGE_TILES*128, false) )  {
          	if(_tempDamage > _mostDamage)	{
  						_mostDamage = _tempDamage;
  						_mostDamagedDefense = _defense;
  					}
					}
				}
      }
      _defense = enumStruct();
    }//while struct
    _i++;
  }//While _i
	if(_mostDamagedDefense != NULLOBJECT)
	{
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}

  //double check...
   if (_idleTruck == NULLOBJECT){ return false; }

	//look for sensor types
	//numSense	INT					3
	//sense[0]		STRUCTURESTAT		"Sys-SensoTowerWS"
  _i=0;
  while(_i < numSense )
  {
    initEnumStruct(FALSE,sense[_i],player,player);
    _defense = enumStruct();
    while (_defense != NULLOBJECT){
			if( distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange ){
				_tempDamage = 100 - _defense.health;
				if(_tempDamage >= STRUCT_REPAIR_DAMAGE){
          if ( !threatInRange(player,_defense.x, _defense.y, THREAT_RANGE_TILES*128, false) ) {
          	if(_tempDamage > _mostDamage)	{
  						_mostDamage = _tempDamage;
  						_mostDamagedDefense = _defense;
  					}
					}
				}
      }
      _defense = enumStruct();
    }//while struct
    _i++;
  }//While _i
	if(_mostDamagedDefense != NULLOBJECT){
    //displayMsg("**** repairDefStructs: found a damaged def struct damage=("& _mostDamage &") ");
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}
  return false;
}

//-----------------------------------------------------------------------------
/*
update gateways coordinate
this works for now with maps with at least 2 gateways near the base
*/
function int updateGateways()
{
	local int _x,_y,_tx,_ty,_i,_xx[4],_yy[4];
	local float _basecoordX,_basecoordY;
	local int _dist;
	
  _x = 0;
  _y = 0;

  _i=0;
  while (_i<4){
    _xx[_i] = -1;
    _yy[_i] = -1;
    _i++;
  }

  //displayMsg("updateGateways:MAP DIMENSIONS("& mapWidth &"-"& mapHeight &")");

  //corner 1
  _tx = max( baseX-TILE*8 , 0 );
  _ty = max( baseY-TILE*8 , 0 );
  _basecoordX = (float)_tx/(float)TILE;
  _basecoordY = (float)_ty/(float)TILE;
	if ( getNearestGateway( (int)_basecoordX, (int)_basecoordY, ref _x, ref _y ) ){
	  _dist = distBetweenTwoPoints(baseX, baseY, _x*TILE, _y*TILE);
    //displayMsg("updateGateways:Base coord 1 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
  	if( _dist < gatewaysRangeTiles*TILE)	{
    	 //displayMsg("updateGateways:Base coord 1a ("& baseX/TILE &"-"& baseY/TILE &") = ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
       _xx[0] = _x;
       _yy[0] = _y;
    }//else {displayMsg("updateGateways:Base coord 1 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
  }//else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}

  //corner 2
  _x = 0;
  _y = 0;
  _tx = min( baseX+TILE*8 , mapWidth*TILE );
  _ty = min( baseY+TILE*8 , mapHeight*TILE );
  _basecoordX = (float)_tx/(float)TILE;
  _basecoordY = (float)_ty/(float)TILE;
	if ( getNearestGateway( (int)_basecoordX, (int)_basecoordY, ref _x, ref _y ) ){
	  _dist = distBetweenTwoPoints(baseX, baseY, _x*TILE, _y*TILE);
    //displayMsg("updateGateways:Base coord 2 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
  	if( _dist < gatewaysRangeTiles*TILE)	{
      if( (_xx[0]+_yy[0] != _x+_y) )    {
    	  //displayMsg("updateGateways:Base coord 2a ("& baseX/TILE &"-"& baseY/TILE &") = ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
        _xx[1] = _x;
        _yy[1] = _y;
      }
    }//else {displayMsg("updateGateways:Base coord 2 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
  }//else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}

  //corner 3
  _x = 0;
  _y = 0;
  _tx = min( baseX+TILE*8 , mapWidth*TILE );
  _ty = max( baseY-TILE*8 , 0 );
  _basecoordX = (float)_tx/(float)TILE;
  _basecoordY = (float)_ty/(float)TILE;
	if ( getNearestGateway( (int)_basecoordX, (int)_basecoordY, ref _x, ref _y ) )
	{
	  _dist = distBetweenTwoPoints(baseX, baseY, _x*TILE, _y*TILE);
    //displayMsg("updateGateways:Base coord 3 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
  	if( _dist < gatewaysRangeTiles*TILE)	{
      if( (_xx[0]+_yy[0] != _x+_y) and (_xx[1]+_yy[1] != _x+_y) )    {
      	 //displayMsg("updateGateways:Base coord 3a ("& baseX/TILE &"-"& baseY/TILE &") = ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
        _xx[2] = _x;
        _yy[2] = _y;
      }
    }//else {displayMsg("updateGateways:Base coord 3 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
  }//else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}

  //corner 4
  _x = 0;
  _y = 0;
  _tx = max( baseX-TILE*8 , 0 );
  _ty = min( baseY+TILE*8 , mapHeight*TILE );
  _basecoordX = (float)_tx/(float)TILE;
  _basecoordY = (float)_ty/(float)TILE;
	if ( getNearestGateway( (int)_basecoordX, (int)_basecoordY, ref _x, ref _y ) )
	{
	  _dist = distBetweenTwoPoints(baseX, baseY, _x*TILE, _y*TILE);
    //displayMsg("updateGateways:Base coord 4 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
  	if( _dist < gatewaysRangeTiles*TILE)	{
     if( (_xx[0]+_yy[0] != _x+_y) and (_xx[1]+_yy[1] != _x+_y) and (_xx[2]+_yy[2] != _x+_y) )    {
    	 //displayMsg("updateGateways:Base coord 4a ("& baseX/TILE &"-"& baseY/TILE &") = ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
      _xx[3] = _x;
      _yy[3] = _y;
     }
   }// else {displayMsg("updateGateways:Base coord 4 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
  }//else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}
 
  
  //find out how many gateways have been found 
  _i=0;
  while ( _i < 4 ) {
    if( _xx[_i] > 0 and _yy[_i] > 0 )  {    
      //displayMsg("updateGateways: gateways stored at x:("& _xx[_i] &"-"& _yy[_i] &")");
      aGatewayPosX[nRealGatewaysFound] = _xx[_i]*TILE;
      aGatewayPosY[nRealGatewaysFound] = _yy[_i]*TILE;
      _dist = distBetweenTwoPoints(baseX, baseY, aGatewayPosX[nRealGatewaysFound], aGatewayPosY[nRealGatewaysFound]);
      nRealGatewaysFound++;
      printDebug1( "updateGateways; gateway #"& nRealGatewaysFound &" coord x-y" & _xx[_i] & "-" & _yy[_i] &" dist from base("& _dist/TILE &") defend range("& nDefendRange/TILE &")" );
    }
    _i++;
  }//endwhile
  
  /*
  if (nRealGatewaysFound == 0){
    numDefStrAtGateway = 3;
  }
  if (nRealGatewaysFound == 1){
    numDefStrAtGateway = 5;
  }
  if (nRealGatewaysFound == 2){
    numDefStrAtGateway = 4;
  }
  if (nRealGatewaysFound == 3){
    numDefStrAtGateway = 3;
  }
  if (nRealGatewaysFound == 4){
    numDefStrAtGateway = 2;
  }
  if (nRealGatewaysFound > 4){
    numDefStrAtGateway = 2;
  }
  */
  numDefStrAtGateway = 1;
  //reSortGateways - put the gateways near to the enemy on the top of the array.
  //reSortGateways();
  //displayMsg("*** updateGateways: tot REAL gateways found: ("& nRealGatewaysFound &")" );

  return nRealGatewaysFound;//default is 0
}

//-----------------------------------------------------------------------------
function void initAssignUnitToGrp()
{
	local GROUP xGRP;
	local DROID _droid;
	local int cc,_tot;
	
	cc=0;
  groupAddArea(xGRP, player, 0, 0, (mapWidth*128), (mapHeight*128));
  initIterateGroup(xGRP);
  droid = iterateGroup(xGRP);
  while(droid != NULLOBJECT)
  {
    assignDroidToGrp(droid);
    droid = iterateGroup(xGRP);
  }

  //in assignDroidToGrp all trcks are assigned as default to buildGrp
  //keep 2 trucks in buildGrp at the beginning to speed up building of structures
  _tot =  buildGrp.members;
  printDebug1("InitAssignUnitToGrp(); tot buildGrp: ("& _tot &")");
  if ( _tot == 3 ){
    _droid = getADroid(buildGrp);
   	if (_droid != NULLOBJECT){
    	groupAddDroid(harvesterGroup, _droid );
  	}
  }
  if ( _tot > 3 ){
    _droid = getADroid(buildGrp);
   	if (_droid != NULLOBJECT){
    	groupAddDroid(harvesterGroup, _droid );
  	}
    _droid = getADroid(buildGrp);
   	if (_droid != NULLOBJECT){
    	groupAddDroid(harvesterGroup, _droid );
  	}
  }

}
//-----------------------------------------------------------------------------
function void updateBaseRange()
{
	
	local int _baseRange,_i,_result;
	
  maxy = 0; maxx = 0;
	miny = (mapHeight*128); minx = (mapWidth*128);

	_baseRange = 1;	//avoid possible div by 0
	aaRange = 1;

	_i = 0;
	while( _i+1 < numBaseStructs )//need +1 to exclude the derricks!!!
	{
		initEnumStruct(FALSE,baseStructs[_i],player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.x < minx){minx = structure.x;}
			if(structure.x > maxx){maxx = structure.x;}
			if(structure.y < miny){miny = structure.y;}
			if(structure.y > maxy){maxy = structure.y;}

			_result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
			if(_result > _baseRange){_baseRange = _result;}

			structure = enumStruct();
		}
		_i = _i + 1;
	}

	_result = 7 * TILE;

	minx = minx - _result; maxx = maxx + _result;
	miny = miny - _result; maxy = maxy + _result;

	if(minx < 0){minx = TILE;}
	if(miny < 0){miny = TILE;}
	if(maxx > (mapWidth * TILE)){maxx = (mapWidth * TILE) - TILE;}
	if(maxy > (mapHeight * TILE)){maxy = (mapHeight * TILE) - TILE;}

	aaRange = _baseRange + TILE;		//between the base and _baseRange

	nBaseRange = _baseRange + (5 * TILE);
	if ( nBaseRange < 12*TILE ){ nBaseRange =  12*TILE; }//game start
}

//-----------------------------------------------------------------------------
function void updateDefendRange()
{  
  
  local int _n,_g,_dist,_xCoord,_yCoord;
    
  //Update nDefendRange
  _n = 0;
  _g = 999*TILE;
  while ( _n < MAX_PLAYERS )
  {
    if ( !friendlyPlayer(_n) and isPlayerStillLive(_n) ) {//replace the code below with initenumstruct()
      _xCoord = getEnemy_baseCoord( _n , "X" );
      _yCoord = getEnemy_baseCoord( _n , "Y" );
      if ( _yCoord > 0 and _yCoord > 0 ){
        _dist = distBetweenTwoPoints( baseX ,baseY ,_xCoord ,_yCoord );
        if ( _dist < _g ){
          _g  = _dist;//best dist
        }
      }
    }    
    _n++;
  }
  if ( _g != 999*TILE ){
  
    nDefendRange = _g/2; 
  
  } else {
    
    if ( nPlayersInGame > 1 ){
      if (nPlayersInGame < 5 ){
        nDefendRange = (int)(float)( ( max(mapWidth,mapHeight)*TILE ) / 2 );
      } else if (nPlayersInGame >= 5 and nPlayersInGame < 8 ){
        nDefendRange = (int)(float)( ( max(mapWidth,mapHeight)*TILE ) / 4 );
      }
      nDefendRange = (int)((float)(nDefendRange)*0.7);
    }
  
  }
  
  if (nDefendRange < nBaseRange){ //double check...
    nDefendRange = nBaseRange + 8*TILE;
  }
  
  if ( nEnemyPlayers > 1 ){
    if (nDefendRange > MAX_DEFEND_RANGETILES*TILE){ //do not make it too big
      nDefendRange = MAX_DEFEND_RANGETILES*TILE;
    }
  }
  //introduce a min def range
  if (nDefendRange < 25*TILE){ nDefendRange = 25*TILE; }
  
}
//-----------------------------------------------------------------------------
//update base coordinates dinamically
function void updateBaseCoord()
{
	local	STRUCTURE	_structure;
	local	DROID		_truck;
	local	bool		_bHaveBaseStructs;
	local	int			_index,_baseX,_baseY,_numBaseStructs,_bucket;

	_bHaveBaseStructs = FALSE;

	//Go through all structures
	_index = 0;
	_numBaseStructs = 0;
	_baseX = 0;
	_baseY = 0;
	while(_index+1 < numBaseStructs)//+1 to exclude derricks!!
	{
		initEnumStruct(FALSE,baseStructs[_index],player,player);
		_structure = enumStruct();
		while(_structure != NULLOBJECT)
		{
			_baseX = _baseX + _structure.x / TILE;
			_baseY = _baseY + _structure.y / TILE;

			_numBaseStructs++;
			_structure = enumStruct();
		}
		_index++;
	}

	if(_numBaseStructs > 0)
	{
		baseX = (_baseX / _numBaseStructs) * TILE;
		baseY = (_baseY / _numBaseStructs) * TILE;
	}
	else
	{
		
			_truck = getADroid(buildGrp);
			if(_truck == NULLOBJECT)
			{
			 _truck = getADroid(harvesterGroup);
			}
			if(_truck == NULLOBJECT)
			{
		    _truck = getADroid(buildDefGrp);
			}


		if(_truck != NULLOBJECT){
			baseX = _truck.x;
			baseY = _truck.y;
		}else{	
      baseX = (TILE * mapWidth) / 2;
			baseY = (TILE * mapHeight) / 2;
			printDebug1("#### updateBaseCoord; Couldn't find base location for " & getPlayerName(player));
    }
	
  }
}
//perform a research o resLab _resFac on the  _lastResIndex+1 item
//returns -1 if no researches have started
//-----------------------------------------------------------------------------
function int do_CheapResearch(STRUCTURE _resFac, int _lastResIndex)
{
	local	bool	_bStarted;
	local	int		_tech, _nn, _ii;

	/* current tech tree */
	_tech     = 0;	//0=tank 
  _nn       = 0;
 

	_bStarted = false;	//this res lab idle for now
	
  while(!_bStarted and _lastResIndex < numCheapRes[0] and _nn < 100)
	{
		
    _lastResIndex = find_Research(_lastResIndex, _tech, 2);//1=standard res, 2= cheap
		if(_lastResIndex > -1)	//research found
		{
			_bStarted = pursueResearch(_resFac,player,researchCheap[_tech][_lastResIndex]);
			if ( _bStarted ){
		   //printDebug1("do_CheapResearch; pursue ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,researchCheap[_tech][_lastResIndex]) &") nProdSelect("& nProdSelect &") nResCount("& nResearchCounter &")");
			  nResearchCounter   = 0;
        tLastResearch     = gameTime;
		    //displayMsg("*** do_CheapResearch : pursue: ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,researchCheap[_tech][_lastResIndex]) &") researchFinished("& researchFinished(researchCheap[_tech][_lastResIndex],player)&") researchStarted("& researchStarted(researchCheap[_tech][_lastResIndex],player)&") lStopResearch("& lStopResearch &") nProdSelect("& nProdSelect &") lStopCheapResearch("& lStopCheapResearch &") pow("& playerPower(player) &")");
      } //else {displayMsg("### do_CheapResearch: COULD NOT pursue: ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,researchCheap[_tech][_lastResIndex]) &") researchFinished("& researchFinished(researchCheap[_tech][_lastResIndex],player)&") researchStarted("& researchStarted(researchCheap[_tech][_lastResIndex],player)&") lStopResearch("& lStopResearch &") nProdSelect("& nProdSelect &") lStopCheapResearch("& lStopCheapResearch &") pow("& playerPower(player) &")"); }
		
    }
		
	 _nn++;
	 _lastResIndex++;
  }

	if(!_bStarted)	{return -1;}
	return _lastResIndex;
}

//-----------------------------------------------------------------------------
// find_research return a valid research even if this cannot be pursued because an
// ally (or another factory?) is researching it.  That value index for the array is then
// passed to pursueResearch() anyway and this will return false. At the end of the
// while loop that value index is the increased by one and find_research
// will start looking for valid reseaches from that point. 
function bool do_Research(STRUCTURE _resFac)
{
	local	bool	_bStarted;
	local	int		_tech, _VTOLprob,_lastResIndex;

  /* current tech tree */
	_tech     = 0;	//0=STANDARD research 9=VTOL research 
  if ( AIPersonality == AI_CYBORG){
    
    _VTOLprob = 0;
  
  } else {    
    
    if ( AIPersonality == AI_VTOL ){      
    
      if ( gameTime > TIME_START_VTOLRESEARCH ){      
        if ( !skVtolEnableCheck(player) ){
          _VTOLprob = 99; //max speed VTOL research
        } else {
          _VTOLprob = 35;
        }      
      } else {      
        if ( !skVtolEnableCheck(player) ){
          _VTOLprob = 85;
        } else {
          _VTOLprob = 35;
        }     
      }    
    
    } else {
      
        //Other AIs
        if ( gameTime > TIME_START_VTOLRESEARCH ){    
          if ( !skVtolEnableCheck(player) ){
            _VTOLprob = 70;
          } else {
            _VTOLprob = 25;
          }
        } else {
          if ( !skVtolEnableCheck(player) ){
            _VTOLprob = 25;
          } else {
            _VTOLprob = 10;//T2 and T3 games
          }
        }
    }
  }

  if ( random(100) > _VTOLprob ){
    _tech = 0;//standard researches
  } else {
    _tech = 9;//VTOL
  }    
	
	_bStarted = false;	//this res lab idle for now
    
  
  while ( _lastResIndex < numRes[_tech] ){

    if ( _tech == 9 ){ //VTOL stuff
     
      _lastResIndex = find_Research(_lastResIndex, _tech, 1);//1=standard Research
      if(_lastResIndex > -1){
      	_bStarted = pursueResearch(_resFac,player,research[_tech][_lastResIndex]);
      	if ( _bStarted ){
         //printDebug1("do_Research; pursue VTOL ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,research[_tech][_lastResIndex]) &") nProdSelect("& nProdSelect &") nResCount("& nResearchCounter &") _VTOLprob("& _VTOLprob &"%)");
          tLastResearch = gameTime;
          nResearchCounter++;
          return true;
        } 
      } else {
       //printDebug1("do_Research; no VTOL research found");
        return false;
      }

    } else { //NOT VTOL STUFF _tech==0 or _tech==1
    
      _lastResIndex = find_Research(_lastResIndex, _tech, 1);//1=standard Research
      if(_lastResIndex > -1){      
      	
        _bStarted = pursueResearch(_resFac,player,research[_tech][_lastResIndex]);
      	if ( _bStarted ){
         //printDebug1("do_Research; pursue ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,research[_tech][_lastResIndex]) &") nProdSelect("& nProdSelect &") VTOL%("& _VTOLprob &"%) nResCount("& nResearchCounter &")");
          tLastResearch = gameTime;
          nResearchCounter++;
          return true;
        }      
      
      } else { //no researches for this TECH found
    
       //printDebug1("do_Research; A-no research found on _tech["& _tech &"] numRes[_tech]("& numRes[_tech] &") _lastResIndex["& _lastResIndex &"]; ");
    	  if(_tech == 0){ 
          //printDebug1("do_Research; B-no research found on _tech["& _tech &"] _lastResIndex["& _lastResIndex &"]; try to _tech[1]");
         _tech = 1;
        } else {
         //printDebug1("do_Research; 1-no more research found  _tech["& _tech &"] _lastResIndex["& _lastResIndex &"]");
          return false;
        }

      }
      
    }

    _lastResIndex++;

    
  }//endwhile

	return false;
}
//-----------------------------------------------------------------------------
// return the _resIndex to be used for pursueResearch(_resFac,me,research[_tech][_resIndex])
// if not research is found returns -1
function int find_Research(int _searchStart, int _techTree, int whichArray)
{
	local int _retInt;
	
  
  if ( _searchStart < 0 ){
   //printDebug1("#### find_Research; error on _searchStart("& _searchStart &"); _techTree("& _techTree &") whichArray("& whichArray &")" );
    return -1;
  }
  if ( _techTree < 0 or (_techTree > 1 and _techTree < 9 ) or _techTree > 9 ){
   //printDebug1("#### find_Research; error!!! _searchStart("& _searchStart &"); _techTree("& _techTree &") whichArray("& whichArray &")" );
    return -1;
  }

  _retInt = _searchStart;
  
	if ( whichArray == 1 ){// =============== STANDARD RESEARCH  ==================

    //find standard research to pursue
    while(_retInt < numRes[_techTree] and _retInt < MAX_WHILE_LOOPS)
    {
    	if((not researchFinished(research[_techTree][_retInt], player)) and (not researchStarted(research[_techTree][_retInt], player)))
    	{
        //printDebug1("find_Research; research found, whichArray("& whichArray &") _techTree("& _techTree &") _searchStart("& _searchStart &") _retInt("& _retInt &") " );
        return _retInt;		//found research
    	}
    	_retInt++;
    }

  } else { // =============== CHEAP RESEARCH ==================
  
    while(_retInt < numCheapRes[0] and _retInt < MAX_WHILE_LOOPS)
  	{
  		if((not researchFinished(researchCheap[_techTree][_retInt], player)) and (not researchStarted(researchCheap[_techTree][_retInt], player)))
  		{
        //printDebug1("find_Research; research found, whichArray("& whichArray &") _techTree("& _techTree &") _searchStart("& _searchStart &") _retInt("& _retInt &") " );
        return _retInt;		//found research
  		} //else {displayMsg("Cheap Research index ("& _retInt &") cannot be researched ");   }
  		_retInt++;
  	}

  }

  //printDebug1("find_Research; no research found, whichArray("& whichArray &") _techTree("& _techTree &") _searchStart("& _searchStart &") _retInt("& _retInt &") set now to -1" );
	
  _retInt = -1;		//not found
	return(_retInt);
}
//-----------------------------------------------------------------------------
function int numFactModule(int _player, int _numModules)
{
  local STRUCTURE _str;
  local int _count;

  _count=0;

  initEnumStruct(false,factory,_player,_player);
  _str = enumStruct();
  while(_str != NULLOBJECT)
  {
    //dbg(" player("& _player &")  test("& testStructureModule(_player, _str, 1) &")str ("& _str.id &") cap("&  skGetFactoryCapacity(_str) &") >= ("& _numModules &")",player);
    if ( skGetFactoryCapacity(_str) >= _numModules ){
     _count++;
    }
    _str = enumStruct();
  }
  return _count;
}
//-----------------------------------------------------------------------------
function int numStructsByType(STRUCTURESTAT _structure, int _player, bool _bCompletedStructOlny)
{
  local STRUCTURE _str;
  local int _count;

  _count=0;

  initEnumStruct(false,_structure,_player,_player);
  _str = enumStruct();
  while(_str != NULLOBJECT)
  {
    if ( _bCompletedStructOlny ){
      if (structureComplete(_str)){
        _count++;
      }
    } else {
      _count++;
    }
    _str = enumStruct();
  }
  return _count;
}
//-----------------------------------------------------------------------------
function DROID nearestDroidToBeRepaired(GROUP _group, int _x, int _y)
{
  local DROID _droid, _damagedUnit;
  local int _tmpDist;
  
  _tmpDist    = 999*TILE;
  _damagedUnit  = NULLOBJECT;
  
  initIterateGroup(_group);
  _droid = iterateGroup(_group);
  while(_droid != NULLOBJECT)
  {
  	if( _droid.health < MIN_HEALT_REPAIR_BASE  )
  	{
      if(distBetweenTwoPoints( _droid.x, _droid.y, _x, _y) < _tmpDist)
      {
    		_tmpDist      = distBetweenTwoPoints( _droid.x, _droid.y, _x, _y);
    		_damagedUnit  = _droid;
  		} //else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
  	}
  	_droid = iterateGroup(_group);
  }
  
  //check for damaged units _droid.health < 95
  if ( _damagedUnit == NULLOBJECT ){
    initIterateGroup(_group);
    _droid = iterateGroup(_group);
    while(_droid != NULLOBJECT)
    {
    	if( _droid.health < 95  )
    	{
        if(distBetweenTwoPoints( _droid.x, _droid.y, _x, _y) < _tmpDist)
        {
      		_tmpDist      = distBetweenTwoPoints( _droid.x, _droid.y, _x, _y);
      		_damagedUnit  = _droid;
    		} //else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
    	}
    	_droid = iterateGroup(_group);
    }
  }

  return _damagedUnit;
}
//-----------------------------------------------------------------------------
function DROID unitToBeRepaired(GROUP _group)
{
  local DROID _droid, _damagedUnit;
  local int _tmpDamage, _damage;
  
  _tmpDamage    = 0;
  _damagedUnit  = NULLOBJECT;
  
  initIterateGroup(_group);
  _droid = iterateGroup(_group);
  while(_droid != NULLOBJECT)
  {
    _damage = 100 - _droid.health;
  	if( _droid.health < MIN_HEALT_REPAIR_BASE and _damage >_tmpDamage )
  	{
      if(distBetweenTwoPoints( _droid.x, _droid.y, baseX, baseY) < nBaseRange)
      {
    		_tmpDamage    = _damage;
    		_damagedUnit  = _droid;
  		} //else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
  	}
  	_droid = iterateGroup(_group);
  }
  
  return _damagedUnit;
}
//-----------------------------------------------------------------------------
// check if the repair droid itself has to be repaired or not.
function DROID idleRepairDroid(int _x, int _y)
{
	local DROID _closestTruck,_tempTruck;
	local int 	_closestDist,_tempDist;

	_closestTruck = NULLOBJECT;
	_closestDist = 999*TILE;

	initIterateGroup(repairGroup);
	_tempTruck = iterateGroup(repairGroup);
	while(_tempTruck != NULLOBJECT)
	{
  	//if less then I cannot pick him up to avoid self repair
    if( _tempTruck.health > MIN_HEALT_REPAIR_BASE ) 	{
      if(_tempTruck.order != DORDER_DROIDREPAIR) {
  			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
  			if(_tempDist < _closestDist)
  			{
  				_closestDist = _tempDist;
  				_closestTruck = _tempTruck;
  			}
  		}
		}
		_tempTruck = iterateGroup(repairGroup);
	}
	return _closestTruck;
}
//-----------------------------------------------------------------------------
function void moveUnitsBetweenGRPs(GROUP _toGRP, GROUP _fromGRP, int _unitsToMove, bool _bNoTrucked)
{
  local int _c;
  local DROID _tempTruck;
  
  _c = 0;
  
	//If requested, leave trucked droids in defend group
  if (_bNoTrucked ){
    initIterateGroup(_fromGRP);
  	_tempTruck = iterateGroup(_fromGRP);
    while ( _c < _unitsToMove and _tempTruck != NULLOBJECT){
      if ( _tempTruck.propulsion != TrackedProp ){
        groupAddDroid(_toGRP, _tempTruck);
        _c++;
   		}
   		_tempTruck = iterateGroup(_fromGRP);
  	}
	}
  
	//move the remaining units
  initIterateGroup(_fromGRP);
	_tempTruck = iterateGroup(_fromGRP);
  while ( _c < _unitsToMove and _tempTruck != NULLOBJECT){
    groupAddDroid(_toGRP, _tempTruck);
    _c++;
		_tempTruck = iterateGroup(_fromGRP);
  }
  
}
//-----------------------------------------------------------------------------
function void attackedByDroid(DROID _droid)
{
  local int _nOldEnWeapDroids,_nNewAlertDistFromBase,_nOldAlertDistFromBase;
  local int _nEnWeapDroids,_nFrWeapStructs,_nFrWeapDroids,_nTotFriendlyWapons;
  local bool _bProceed;
  
  if ( _droid == NULLOBJECT ){ return; }

	_bProceed             = true;
  _nOldAlertDistFromBase = 9999*TILE;
  _nOldEnWeapDroids      = 0;
 
  if (_droid.player<0 or _droid.player>7){
    //dbg("dbg->attackedByDroid: droid.player is not in 0-7 range ("& _droid.player &") ",player);
    return;
  }
  
  //set target for VTOLs 
  if( isVtol(_droid) ){ return; }


  _nNewAlertDistFromBase = distBetweenTwoPoints(_droid.x,_droid.y,baseX,baseY);

  _nEnWeapDroids  = numEnemyWeapDroidsInRange(player, _droid.x, _droid.y, COMBAT_RANGE , false);
  _nFrWeapStructs = numFriendlyWeapStructsInRange(player, _droid.x, _droid.y, COMBAT_RANGE, false);
  _nFrWeapDroids  = tankDefGroup.members + cyborgDefGroup.members;
  _nTotFriendlyWapons = _nFrWeapStructs+_nFrWeapDroids;

  //if it is a new second alert check which one is the nearest to the base
  if (alertIsOn and alertX>0 and alertY>0){   
    _nOldAlertDistFromBase = distBetweenTwoPoints(alertX,alertY,baseX,baseY);
    _nOldEnWeapDroids      = numEnemyWeapDroidsInRange(player, alertX, alertY, COMBAT_RANGE , false);        //check if new threat is bigger then the older one
    if ( _nOldEnWeapDroids > _nEnWeapDroids ){
			_bProceed = false;
		}	
    //if new alert is within the base this has priority 1!!
    if ( _bProceed and _nNewAlertDistFromBase > nBaseRange and _nOldAlertDistFromBase < nBaseRange  ){
			_bProceed = false;
		}	
  }
  
	if(_bProceed)
	{

    //determine the ALERT level
    if ( _nEnWeapDroids >= _nTotFriendlyWapons ) {
        alertLevel = RED_ALERT;
    }
    if ( (float)_nEnWeapDroids >= (float)_nTotFriendlyWapons*0.7 and _nEnWeapDroids < _nTotFriendlyWapons ) {
        alertLevel = YELLOW_ALERT;
    }
    if ( (float)_nEnWeapDroids < (float)_nTotFriendlyWapons*0.7 ) {
        alertLevel = GREEN_ALERT;
    }

		// move all untis in tankDefGrp
		if (alertLevel == RED_ALERT){
  		if (tankGroup.members>0){
        if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , tankGroup);
        } else {
          groupAddGroup(tankDefGroup , tankGroup);
        }
        deactivateTankAttack();
      }
  		if (cyborgAttGroup.members>0){
        if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , cyborgAttGroup);
        } else {
          groupAddGroup(tankDefGroup , cyborgAttGroup);
        }
        deactivateCybAttack();
      }
  		if (helpGroup.members>0){
        //displayMsg("attackedByDroid: RED ALERT all helping units back!");
        msg("My base is in trouble recalling "& helpGroup.members &" helping units back", player, nAllyBeingHelped);
        if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , helpGroup);
        } else {
          groupAddGroup(tankDefGroup , helpGroup);
        }
        deactivateHelp();
      }
    }    
    
	
	}//endif _bProceed
}
//-----------------------------------------------------------------------------
function void attackedByStruct(STRUCTURE _struct)
{

  local int _nEnNewWeapDroids,_nOldEnWeapDroids,_nNewAlertDistFromBase,_nOldAlertDistFromBase;
  local int _nEnWeapDroids,_nFrWeapStructs,_nFrWeapDroids,_nTotFriendlyWapons;
  local bool _bProceed;
  
  if ( _struct == NULLOBJECT ){ return; }

 	boolResult = true;
  if (_struct.player<0 or _struct.player>7){
    return;
  }
 
  //set as VTOL target
  defTargetVTOL         = _struct;
  targetPlayerVTOL      = _struct.player;
  bVTOLTargetIsDerrick  = false;
   
  //// IF targetPl NOT SET - PUNISH THE OFFENDER
  _nNewAlertDistFromBase = distBetweenTwoPoints(_struct.x,_struct.y,baseX,baseY);
  _nEnWeapDroids         = numEnemyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE , false);
  _nFrWeapStructs        = numFriendlyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE, false);
  _nFrWeapDroids         = tankDefGroup.members + cyborgDefGroup.members;
  _nTotFriendlyWapons    = _nFrWeapStructs+_nFrWeapDroids;


  //if it is a new second alert check which one is the nearest to the base
  if ( alertIsOn and alertX > 0 and alertY > 0 ){   
    _nOldAlertDistFromBase = distBetweenTwoPoints(alertX,alertY,baseX,baseY);
    _nOldEnWeapDroids   = numEnemyWeapDroidsInRange(player, alertX, alertY, COMBAT_RANGE , false);        //check if new threat is bigger then the older one
    if ( _nOldEnWeapDroids > _nEnWeapDroids )
		{
			_bProceed = false;
		}	
    //if new alert is uin the base this has priority 1!!
    if ( (_nNewAlertDistFromBase > nBaseRange) and (_nOldAlertDistFromBase < nBaseRange)  )
		{
			_bProceed = false;
		}	
  }

	if(_bProceed)
	{

    //determine the ALERT level
    if ( _nEnWeapDroids >= _nTotFriendlyWapons ) {
        alertLevel = RED_ALERT;
    }
    if ( (float)_nEnWeapDroids >= (float)_nTotFriendlyWapons*0.7 and _nEnWeapDroids < _nTotFriendlyWapons ) {
        alertLevel = YELLOW_ALERT;
    }
    if ( (float)_nEnWeapDroids < (float)_nTotFriendlyWapons*0.7 ) {
        alertLevel = GREEN_ALERT;
    }

		// move all untis in tankDefGrp
		if (alertLevel == RED_ALERT){
  		if (tankGroup.members>0){
        if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , tankGroup);
        } else {
          groupAddGroup(tankDefGroup , tankGroup);
        }
        deactivateTankAttack();
      }
  		if (cyborgAttGroup.members>0){
         if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , cyborgAttGroup);
        } else {
          groupAddGroup(tankDefGroup , cyborgAttGroup);
        }
        deactivateCybAttack();
      }
  		if (helpGroup.members>0){
        msg("My base is in trouble recalling "& helpGroup.members &" helping units back", player, nAllyBeingHelped);
        if ( AIPersonality == AI_CYBORG ){
          groupAddGroup(cyborgDefGroup , helpGroup);
        } else {
          groupAddGroup(tankDefGroup , helpGroup);
        }
        deactivateHelp();
      }    
    }
	}//endif _bProceed
}
//-----------------------------------------------------------------------------
function int getNumStructNotIdle(STRUCTURESTAT _structToCheck)
{
  local STRUCTURE _struct;
  local int _tot;
  
  _tot=0;
  
	initEnumStruct(false,_structToCheck,player,player);
	_struct = enumStruct();
	while(_struct != NULLOBJECT)
	{
		if(structureComplete(_struct))
		{
			if(!structureIdle(_struct)){ _tot++; }
    }
	  _struct = enumStruct();
  }

  return _tot;
}
//-----------------------------------------------------------------------------
function int numRemainingOilRes()
{
  local FEATURE _tempOilRes;
  local int _nTot;
  _nTot=0;
  
  initGetFeature(oilRes,-1,player);
	_tempOilRes = getFeature(player);
	while(_tempOilRes != NULLOBJECT and _nTot < MAX_WHILE_LOOPS)
	{
		_nTot++;
    _tempOilRes = getFeature(player);
	}
	
  return _nTot;
}
//-----------------------------------------------------------------------------
function bool bAnyOilResLeft()
{
  local DROID _droid;
	boolResult = true;

  InitEnumDroids(player,player);
  _droid = EnumDroid();
  while ( _droid != NULLOBJECT and boolResult ){
    if (_droid != NULLOBJECT){ boolResult = false;}
    _droid = EnumDroid();
  }

  if ( _droid == NULLOBJECT ){
    return false;
  }
	
  initGetFeature(oilRes,-1,player);
	feature = getFeature(player);
  while(feature != NULLOBJECT)
	{
     if ( droidCanReach(_droid, feature.x, feature.y) ){
	     return true;
     }
     feature = getFeature(player);
	}

  return false;
} 
//-----------------------------------------------------------------------------
function int getTotDerricksMap()
{
  local int _player, _totDerricks;
  _player = 0;
  _totDerricks = 0;

  while ( _player < MAX_PLAYERS ){
    _totDerricks = _totDerricks + getNumDerricks(_player);
    _player++;
  }
  return _totDerricks;
} 

//-----------------------------------------------------------------------------
function void sendIdleBackToTheBase(int _group)
{
  local DROID _idleTruck;
  local GROUP _GRP;
  local int _tempDist;
  
  _idleTruck = NULLOBJECT;
  
  if (_group == BUILDDEF_GRP){ _GRP = buildDefGrp;  }    
  if (_group == CYBENG_GRP)  { _GRP = cybConstGrp; }    
  if (_group == BUILD_GRP)   { _GRP = buildGrp; }   
  if (_group == HARVEST_GRP) { _GRP = harvesterGroup; }

	initIterateGroup(_GRP);
	_idleTruck = iterateGroup(_GRP);
	while(_idleTruck != NULLOBJECT)
	{
    if( droidOrderIdle(_idleTruck) and _idleTruck.order != DORDER_RTB )
		{
			_tempDist = distBetweenTwoPoints(baseX, baseY, _idleTruck.x, _idleTruck.y);
			if( _tempDist > nBaseRange )
			{
        orderDroid(_idleTruck, DORDER_RTB);
			}
		}
		_idleTruck = iterateGroup(_GRP);
	}
  
  return;

}
//-----------------------------------------------------------------------------
//returns _nWhichCooord(x or y) such that they are _nDist (world coord) away from _x1/_y1 direction _x2,_y2
/*
10,10 90,90 5  
90,90 10,10 5
*/
function int  getCoordRelated(int _x1, int _y1, int _x2, int _y2, int _nWhichCooord, int _nDist)
{
  local int _xx,_yy,_return;
  local DROID _droid;

  _droid = getADroid(harvesterGroup);
  if ( _droid == NULLOBJECT ){ _droid = getADroid(buildGrp); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(buildDefGrp); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(tankDefGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(cyborgDefGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(cybConstGrp); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(tankGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(cyborgAttGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(toBeRepairedCyborgGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(toBeRepairedTankGroup); }
  if ( _droid == NULLOBJECT ){ _droid = getADroid(helpGroup); }
  if ( _droid != NULLOBJECT ){
    if (_x1 > _x2) { 
      _xx = _x1 - _nDist;// 85 = 90 -5
      if ( _xx < _x2 ) { _xx = _x1 - (_x1-_x2)/2; } 
    } else { 
      _xx = _x1 + _nDist; //15 = 10 + 5
      if ( _xx > _x2 ) { _xx = _x1 + (_x2-_x1)/2; } 
    }
    if (_y1 > _y2) { 
      _yy = _y1 - _nDist; //85 = 90 -5
      if ( _yy < _y2 ) { _yy = _y2 - (_y1-_y2)/2; } 
    } else { 
      _yy = _y1 + _nDist; //15 = 19 + 5 
      if ( _yy > _y2 ) { _yy = _y1 + (_y2-_y1)/2; } 
    }
    if ( _xx < TILE*3 ) { _xx = TILE*3; }
    if ( _yy < TILE*3 ) { _yy = TILE*3; }
    //printDebug1("getCoordRelated-1, _nDist("& _nDist/TILE &") from("& _x1/TILE  &"-"& _y1/TILE &") to("& _x2/TILE  &"-"& _y2/TILE &") result("& _xx/TILE  &"-"& _yy/TILE &")");

    if ( pickStructLocation(vtolPad, ref _xx, ref _yy, player) ){
        //printDebug1("getCoordRelated-2, _nDist("& _nDist/TILE &") from("& _x1/TILE  &"-"& _y1/TILE &") to("& _x2/TILE  &"-"& _y2/TILE &") result("& _xx/TILE  &"-"& _yy/TILE &")");
        if( droidCanReach(_droid, _xx, _yy) ){
          if( _nWhichCooord == 1){
            return _xx;
          }
          if( _nWhichCooord == 2){
            return _yy;
          }
        }
    }
  }
  return -1;
}

//-----------------------------------------------------------------------------
//   _targetPlayer == -1 as default
function BASEOBJ findEnemyOBJ(bool _mustBeHuman, int _targetPlayer)
{
	local BASEOBJ _attackObject;
	local int _targetPl,_xCoord,_yCoord;
  
  _attackObject = NULLOBJECT;
	_targetPl  = -1;
  
  //if big maps, pick up nearest enemy
  if ( _targetPlayer >= 0 ){
   //printDebug1("findEnemyOBJ: target forced to _targetPlayer("& getPlayerName(_targetPlayer) &") ");
    _targetPl = _targetPlayer;
  } else {
    if ( mapSize() > MAP_SMALL ){
      _targetPl = getNearestEnemyPlayer(_mustBeHuman);
     //printDebug1("findEnemyOBJ: target set to nearest enemy player("& getPlayerName(_targetPl) &") _mustBeHuman("& _mustBeHuman &") isHuman("& isHumanPlayer(_targetPl) &") mapSize("& mapSize() &" > "& MAP_SMALL &")");
    }
  }
  
  //target player not found!!!
  if ( _targetPl < 0 ) {
  	_targetPl = getRandomEnemyPlayer(_mustBeHuman);
    //if ( _targetPl > -1 ){
      //printDebug1("findEnemyOBJ: target set to random enemy player("& getPlayerName(_targetPl) &") _mustBeHuman("& _mustBeHuman &") isHuman("& isHumanPlayer(_targetPl) &") mapSize("& mapSize() &" > "& MAP_SMALL &")");
    //}
  }
  if ( _targetPl == -1 ){
    //printDebug1("#### findEnemyOBJ(): No enemy found _mustBeHuman("& _mustBeHuman &") _targetPlayer("& _targetPlayer &")");
    return _attackObject; //NULLOBJECT
  }
  
  _xCoord = aPl[_targetPl][X_COORD];
  _yCoord = aPl[_targetPl][Y_COORD];
  if (_xCoord>0 and _yCoord>0 ){
    _attackObject = objStrTargetInRange( _xCoord , _yCoord, 15 * TILE );
  }
  if ( _attackObject == NULLOBJECT ){
   _attackObject = skLocateEnemy(_targetPl);
  }

	return _attackObject;
}

//-----------------------------------------------------------------------------
function int gameType()
{

  if ( nHumanPlayers == 1 ){
    
    if ( nPlayersInGame == 2 ){
     return GT_2PLAYERS_1HP;
    }
    if ( nPlayersInGame == 3 or nPlayersInGame == 4){
      if ( nTeam == 2  ){
        return GT_4PLAYERS_1HP_2T;
      }
      if ( nTeam > 2  ){
        return GT_4PLAYERS_1HP_34T;
      }
    }
    if ( nPlayersInGame > 4 ){
     if ( nTeam < 4  ){
      return GT_8PLAYERS_1HP_23T;
     }
     if ( nTeam >= 4  ){
      return GT_8PLAYERS_1HP_4567T;
     }
    }
  
  } else if ( nHumanPlayers == 2 ){
    
    if ( nPlayersInGame == 3 or nPlayersInGame == 4){
      if ( nTeam == 2  ){
        return GT_4PLAYERS_2HP_2T;
      }
      if ( nTeam > 2  ){
        return GT_4PLAYERS_2HP_34T;
      }
    }
    if ( nPlayersInGame > 4 ){
     if ( nTeam < 4  ){
      return GT_8PLAYERS_2HP_23T;
     }
     if ( nTeam >= 4  ){
      return GT_8PLAYERS_2HP_4567T;
     }
    }

  } else if ( nHumanPlayers == 3 ){
    
    return GT_8PLAYERS_3HP_23T;

  } else {

    return GT_STANDARD;
  }

    return GT_STANDARD;
}
//-----------------------------------------------------------------------------
//
function int getTargetEnemy(bool _dbg)
{
  local int _nMyUnitsTot, _nMyUnitsPower, _nMyUnitsHP;
  local int _nEnUnitsTot, _nEnUnitsPower, _nEnUnitsHP;
  local int _nAvUnitsTot, _nAvUnitsPower, _nAvUnitsHP;
  local int _nTotUnitsTot, _nTotUnitsPower, _nTotUnitsHP;
  local int _player,_tempPlayer,_c2,_c3;
  local float _nMyPowerIndex,_nEnPowerIndex,_nAvPowerIndex,_nTotPowerIndex; 
  
  _tempPlayer = -1;
  
  _nMyUnitsTot    = tankDefGroup.members + cyborgDefGroup.members + cyborgAttGroup.members;
  _nMyUnitsPower  = getWeaponUnitsInfo( player, WUI_POWER);
  _nMyUnitsHP     = getWeaponUnitsInfo( player, WUI_HP);
  _nMyPowerIndex  = getPowerIndex( player );
  
  //find average values first 
  _player=0;
  while( _player < MAX_PLAYERS ){
    if ( isPlayerStillLive(_player) ){
      _nEnUnitsTot    = getWeaponUnitsInfo( _player, WUI_TOTUNITS);
      _nEnUnitsPower  = getWeaponUnitsInfo( _player, WUI_POWER);
      _nEnUnitsHP     = getWeaponUnitsInfo( _player, WUI_HP);
      _nEnPowerIndex  = getPowerIndex( _player );
      _nTotUnitsTot    = _nTotUnitsTot    + _nEnUnitsTot;
      _nTotUnitsPower  = _nTotUnitsPower  + _nEnUnitsPower;
      _nTotUnitsHP     = _nTotUnitsHP     + _nEnUnitsHP;
      _nTotPowerIndex  = _nTotPowerIndex  + _nEnPowerIndex;
    }
    _player++;
  }
  _nAvUnitsTot    = _nTotUnitsTot   / nPlayersInGame;
  _nAvUnitsPower  = _nTotUnitsPower / nPlayersInGame;
  _nAvUnitsHP     = _nTotUnitsHP    / nPlayersInGame;
  _nAvPowerIndex  = _nTotPowerIndex / (float)nPlayersInGame;

  
  //dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") avUnTot("& _nAvUnitsTot &") avCost("& _nAvUnitsPower &") avHP("& _nAvUnitsHP &") avPowInd("& _nAvPowerIndex &")",player);  
  //dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") myUnTot("& _nMyUnitsTot &") myCost("& _nMyUnitsPower &") myHP("& _nMyUnitsHP &") myPowInd("& _nMyPowerIndex &")",player);  

  //search for enemies which are too strong
  _player=0;
  while( _player < MAX_PLAYERS ){
    if ( !friendlyPlayer(_player) and isPlayerStillLive(_player) ){
      //give priority to human players ;-)
      boolResult = true;
      if ( _tempPlayer >= 0 and isHumanPlayer(_tempPlayer) ){
        boolResult = false;
      }
      if ( boolResult or _tempPlayer == -1){
        _nEnUnitsTot    = getWeaponUnitsInfo( _player, WUI_TOTUNITS);
        _nEnUnitsPower  = getWeaponUnitsInfo( _player, WUI_POWER);
        _nEnUnitsHP     = getWeaponUnitsInfo( _player, WUI_HP);
        _nEnPowerIndex  = getPowerIndex( _player );
        if ( _nEnUnitsTot   >= 2*_nAvUnitsTot ){ _tempPlayer = _player;  } 
        if ( _nEnUnitsPower >= 2*_nAvUnitsPower ){ _tempPlayer = _player;  } 
        if ( _nEnUnitsHP    >= 2*_nAvUnitsHP ){ _tempPlayer = _player;  } 
        if ( _nEnPowerIndex >= 1.4*_nAvPowerIndex ){ _tempPlayer = _player;  }
      }
    }//endif !friendlyPlayer()
    _player++;
  }
  
  //search for enemies which are too weak
  if ( _tempPlayer == -1){
    //dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") too strong enemy not found",player);  
    if ( _dbg ) {
      printDebug1("getTargetEnemy; too strong enemy not found");
    }  
    _player=0;
    while( _player < MAX_PLAYERS ){
      if ( !friendlyPlayer(_player) and isPlayerStillLive(_player) ){
        //give priority to human players ;-)
        boolResult = true;
        if ( _tempPlayer >= 0 and isHumanPlayer(_tempPlayer) ){
          boolResult = false;
        }
        if ( boolResult or _tempPlayer == -1){
          _nEnUnitsTot    = getWeaponUnitsInfo( _player, WUI_TOTUNITS);
          _nEnUnitsPower  = getWeaponUnitsInfo( _player, WUI_POWER);
          _nEnUnitsHP     = getWeaponUnitsInfo( _player, WUI_HP);
          _nEnPowerIndex  = getPowerIndex( _player );
          if ( 2*_nEnUnitsTot     < _nAvUnitsTot ){ _tempPlayer = _player;  } 
          if ( 2*_nEnUnitsPower   < _nAvUnitsPower ){ _tempPlayer = _player;  } 
          if ( 2*_nEnUnitsHP      < _nAvUnitsHP ){ _tempPlayer = _player;  } 
          if ( 1.5*_nEnPowerIndex  < _nAvPowerIndex ){ _tempPlayer = _player;  }
        }
      }//endif !friendlyPlayer()
      _player++;
    }
    if ( _tempPlayer == -1){
      if ( _dbg ) {
        printDebug1("getTargetEnemy; too weak enemy not found");
      }
    } else {
      //dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") too weak enemy found: ("& getPlayerName(_tempPlayer) &") isHuman("& isHumanPlayer(_tempPlayer)  &")",player);  
      if ( _dbg ) {
        printDebug1("getTargetEnemy; too weak enemy found: ("& getPlayerName(_tempPlayer) &") isHuman("& isHumanPlayer(_tempPlayer)  &")");  
      }
      
      //check we do not attack weak human player too often! unless this is the strong AI
      if ( isHumanPlayer(_tempPlayer) and AIstrength < 4 and nEnemyPlayers > 1 )
      {
        if (nAttHumanPlayer > nAttAIPlayer*2) {
          printDebug1("getTargetEnemy; too weak human enemy was attacked too often Hum_Pl/AI_Pl ("& nAttHumanPlayer &"/"& nAttAIPlayer &"), try to changed target to AI player");
           //get an AI enemy as target, if possible...maybe there are only enemy human players???
          _c2 = random(MAX_PLAYERS);
          _c3 = 0;
          boolResult = true;
          while( _c3 < MAX_PLAYERS and boolResult )
        	{
            if ( !isHumanPlayer(_c2) and isPlayerStillLive(_c2) and !friendlyPlayer(_c2) ){
              boolResult = false;
              _tempPlayer = _c2;	
            }
        		_c2++; _c3++;
        		if ( _c2 == 8 ){ _c2 = 0;  }
        	}
          if ( !boolResult ){
            printDebug1("getTargetEnemy; changed target to AI player: ("& getPlayerName(_tempPlayer) &") isHuman("& isHumanPlayer(_tempPlayer)  &")");
          } else {
            printDebug1("getTargetEnemy; not able to change target to AI player");
          }  
        	//if the loops ends it means there are no enemy AI left!!
        } 
        //else {
          //printDebug1("getTargetEnemy; too weak human enemy was attacked NOT too often Hum_Pl/AI_Pl ("& nAttHumanPlayer &"/"& nAttAIPlayer &"), DyDo attacks him again!!");
        //}
      }
      
    } 
  } else {
    //dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") too strong enemy found: ("& getPlayerName(_tempPlayer) &") isHuman("& isHumanPlayer(_tempPlayer)  &")",player);  
    if ( _dbg ) {
      printDebug("getTargetEnemy: pl("& getPlayerName(player) &") too strong enemy found: ("& getPlayerName(_tempPlayer) &") isHuman("& isHumanPlayer(_tempPlayer)  &")");  
    }
  } 
   
  return _tempPlayer;
}
//-----------------------------------------------------------------------------
/*
//  TankAttack/CyborgAttack events
//     --> getTargetObj
//         --> getTargetEnemy()
//         --> findEnemyOBJ()
//
*/
function BASEOBJ getTargetObj()
{
  
  local int _nGameType,nPerc_HP_Target,_targetPlayer,_rnd,_d1,_d2,_d3;
  local bool _mustBeHuman;
  local BASEOBJ oHumanDerrick1,oHumanDerrick2,oHumanDerrick3;
  
  _mustBeHuman = false;
  nPerc_HP_Target = -1;

  //search for primary enemy player target
  //if big maps or too many players and is allied with human player, 
  //   then attack nearest enemy
  if ( (!bHasHumanEnemies(player) and nPlayersInGame > 4) or mapSize() > MAP_MEDIUM ){
    _targetPlayer = getNearestEnemyPlayer(false);
    //if (_targetPlayer >= 0){  printDebug1("getTargetObj; Nearest enemy found: '"& getPlayerName(_targetPlayer) &"'"); }
  } else {
    //search for too strong or too weak enemies
    _targetPlayer = getTargetEnemy(false);
    //if (_targetPlayer >= 0){  printDebug1("getTargetObj; Very strong or weak enemy found: '"& getPlayerName(_targetPlayer) &"'");}
  }

  _nGameType = gameType();
  if ( _nGameType == GT_4PLAYERS_1HP_2T ){
    nPerc_HP_Target = 40+random(10)+AIstrength*10;
  } 
  if ( _nGameType == GT_4PLAYERS_1HP_34T ){
    nPerc_HP_Target = 30+random(20)+AIstrength*10;
  }
  if ( _nGameType == GT_4PLAYERS_2HP_2T ){
    nPerc_HP_Target = 40+random(10)+AIstrength*10;
  }
  if ( _nGameType == GT_4PLAYERS_2HP_34T ){
    nPerc_HP_Target = 30+random(20)+AIstrength*10;
  }
  if ( _nGameType == GT_8PLAYERS_1HP_23T ){
    nPerc_HP_Target = 20+random(20)+AIstrength*10;
  }
  if ( _nGameType == GT_8PLAYERS_1HP_4567T ){
    nPerc_HP_Target = 15+random(25)+AIstrength*10;
  }
  if ( _nGameType == GT_8PLAYERS_2HP_23T ){
    nPerc_HP_Target = 25+random(25)+AIstrength*10;
  }
  if ( _nGameType == GT_8PLAYERS_2HP_4567T ){
    nPerc_HP_Target = 25+random(20)+AIstrength*10;
  }
  if ( _nGameType == GT_8PLAYERS_3HP_23T ){
    nPerc_HP_Target = 25+random(20)+AIstrength*10;
  }
  if ( nPerc_HP_Target == -1 ){
    nPerc_HP_Target = 25+random(20)+AIstrength*10;
  }

  
  //select the type of target : human or AI
  _rnd = random(100);
  if ( _rnd <= nPerc_HP_Target ){ 
    _mustBeHuman = true;
  } 
  //test or debug game
  if ( bRunning or !bHasHumanEnemies(player) ){
   _mustBeHuman = false;
  }
  
  //search for AA targets
  //search for groups of AA not in enemy base, checks they are quite undefended 
  if ( !bNeedDerrick ){ 
    if ( !bAAgroupsAttacked ){ //alternate objective
      attackTankObj = getAAgroups(_mustBeHuman);
      bAAgroupsAttacked = true;
      if ( attackTankObj != NULLOBJECT ){ 
        //printDebug1("getTargetObj; attacking AA groups, player("& getPlayerName(attackTankObj.player) &") _mustBeHuman("& _mustBeHuman &")" ); 
        return attackTankObj; 
      }
    } else {
      bAAgroupsAttacked = false; //alternate objective
    }
  }
  
  //check if big map and if derricks are required
  _rnd = random(10);
  if ( bNeedDerrick  or ( _rnd < 7 and mapSize() > MAP_MEDIUM ) ){
    //dbg("dbg: getTargetObj-> pl("& getPlayerName(player) &") big map or derricks required _rnd("& _rnd &")" , player); 
    if ( AIstrength >= 4){
      //printDebug1("getTargetObj; target is human derrick, big map or derricks required AIstrength("& AIstrength &")>=4 _rnd("& _rnd &"/7) bNeedDerrick("& bNeedDerrick &") mapSize("& mapSize() &") _mustBeHuman("& _mustBeHuman &")" ); 
      oHumanDerrick1 = objHumanDerrick(false,1,10);//(bool bVTOLTarget, int _numDef, int _distInTiles)
      oHumanDerrick2 = objHumanDerrick(false,2,10);//(bool bVTOLTarget, int _numDef, int _distInTiles)
      oHumanDerrick3 = objHumanDerrick(false,3,10);//(bool bVTOLTarget, int _numDef, int _distInTiles)
      if ( oHumanDerrick1 != NULLOBJECT ){
        _d1 = distBetweenTwoPoints( oHumanDerrick1.x, oHumanDerrick1.y , baseX , baseY );
      } else { _d1 = 999999999; }
      if ( oHumanDerrick2 != NULLOBJECT ){
        _d2 = distBetweenTwoPoints( oHumanDerrick2.x, oHumanDerrick2.y , baseX , baseY );
      } else { _d2 = 999999999; }
      if ( oHumanDerrick3 != NULLOBJECT ){
        _d3 = distBetweenTwoPoints( oHumanDerrick3.x, oHumanDerrick3.y , baseX , baseY );
      } else { _d3 = 999999999; }
      
      if ( random(10) < 5 ){
        if ( _d1 < _d2 and _d1 < _d3 ){ attackTankObj = oHumanDerrick1; }
        if ( _d2 < _d1 and _d2 < _d3 ){ attackTankObj = oHumanDerrick2; }
        if ( _d3 < _d1 and _d3 < _d2 ){ attackTankObj = oHumanDerrick3; }
      } else {
        if ( _d1 < _d2 ){ attackTankObj = oHumanDerrick1; }
        if ( _d2 < _d3 ){ attackTankObj = oHumanDerrick2; }
        if ( _d3 < _d1 and _d3 < _d2 ){ attackTankObj = oHumanDerrick3; }
      }
      //printDebug1("getTargetObj; Target should be human derrick, _d1 _d2 _d3("& _d1/TILE &"-"& _d2/TILE &"-"& _d3/TILE &")" ); 
    } else {
      //printDebug1("getTargetObj; _targetPlayer forced to ("& -1 &") target is derrick, big map or derricks required _rnd("& _rnd &"/7) bNeedDerrick("& bNeedDerrick &") mapSize("& mapSize() &") _mustBeHuman("& _mustBeHuman &")" ); 
      attackTankObj = closestEnemyDerrick(_mustBeHuman , -1);
    }
  } 
  //else {
    //printDebug1("getTargetObj; target will not be a derrick; _targetPlayer("& _targetPlayer &") _rnd("& _rnd &"/7) bNeedDerrick("& bNeedDerrick &") mapSize("& mapSize() &") "); 
  //}
  
  //attack enemy base
  if ( attackTankObj == NULLOBJECT ){
    //printDebug1("getTargetObj; derrick not found, try with base _targetPlayer("& _targetPlayer &") _mustBeHuman("& _mustBeHuman &")"); 
    attackTankObj = findEnemyOBJ(_mustBeHuman,_targetPlayer);
  } 
  //else {
    //printDebug1("getTargetObj; derrick found Id("& attackTankObj.id  &") " ); 
  //}
  //attackTankObj = findEnemyOBJ(_mustBeHuman);
   
  if (attackTankObj != NULLOBJECT) {
    //dbg("dbg: getTargetObj-> pl("& getPlayerName(player)&") target found: player #("& attackTankObj.player &") human("& isHumanPlayer(attackTankObj.player) &")" , player); 
    printDebug1("getTargetObj; target found: player ("& getPlayerName(attackTankObj.player) &") human("& isHumanPlayer(attackTankObj.player) &") "); 
  } else {
    //dbg("dbg: getTargetObj-> pl("& getPlayerName(player) &") NO target found ! ####" , player); 
    printDebug1("getTargetObj; NO target found !"); 
  }
  return attackTankObj;
}
//-----------------------------------------------------------------------------
function BASEOBJ getAAgroups(bool _mustBeHuman)
{
  local int _nEnemyPlayer,_i,_nAA,_nMaxAA,_nEnWeap,_nDist,_nBestDist;
  local int _nMyUnits, _xCoord,_yCoord;
  local BASEOBJ _oAAtarget;
  local STRUCTURE _struct;
  local bool _bOK,_bOK1;
  
  _oAAtarget  = NULLOBJECT;
  _nEnemyPlayer = 0; _i = 0;
  _nMaxAA     = 0;
  
  //loop through enemy players
  while( _nEnemyPlayer < MAX_PLAYERS )
	{
	 _bOK1 = true;
   if ( !allianceExistsBetween(player,_nEnemyPlayer) ) {
	   
	   if ( _mustBeHuman and !isHumanPlayer(_nEnemyPlayer) ) { _bOK1 = false; }
      //loop through AA defences array   
      _i=0;
      while( _i < numGenAA and _bOK1)
      {

        initEnumStruct( false, vtolGenStruct[_i], _nEnemyPlayer, player);
	      _struct = enumStruct();
        
        //loop throught AA def
        while ( _struct != NULLOBJECT ){

          _bOK = false;
          
          //get tot AA in area 
          _nAA = getAA_OnTheWay(baseX, baseY, _struct.x, _struct.y, AA_THREAT_RANGE);
        
          //get tot enemy weap struct in range
          _nEnWeap = numEnemyWeapObjInRange(player, _struct.x, _struct.y, 8*TILE , false, false);
        
          //check if target is not well defended
          if ( tankGroup.members > 0 ){
            _nMyUnits = tankGroup.members*2;
            if ( _nEnWeap < _nMyUnits ){_bOK = true;}
          }
          if ( cyborgAttGroup.members > 0 ){
           _nMyUnits = cyborgAttGroup.members*2;
            if ( _nEnWeap < _nMyUnits ){ _bOK = true; }
          }
          
          if (_nMyUnits<=0){
            printDebug1("#### getAAgroups; _nMyUnits <= 0 !!! ");
            return _oAAtarget;//NULLOBJECT
          }
          
          //get nearest target
          if ( _bOK ){
          
            ///check the object is not in enemy base
            _xCoord = aPl[_nEnemyPlayer][X_COORD];
            _yCoord = aPl[_nEnemyPlayer][Y_COORD];
            if ( _yCoord > 0 and _yCoord > 0 ){
              
              _nDist = distBetweenTwoPoints( _struct.x, _struct.y ,_xCoord ,_yCoord );
              //let`s assume the enemy base range is the same as mine...
              if ( _nDist > nBaseRange ){
                if ( _nAA > _nMaxAA ){
                  _oAAtarget = _struct;
                  //printDebug1("getAAgroups; AA group target found; _nDist ("& _nDist/TILE &")>("& nBaseRange/TILE &") _nAA("& _nAA &")>("& _nMaxAA &") _nEnWeap("& _nEnWeap &")<("& _nMyUnits &"*2) enemy("& getPlayerName(_nEnemyPlayer) &") tanks("& tankGroup.members  &") cyborgs("& cyborgAttGroup.members  &")");
                  _nMaxAA = _nAA;
                }
              }
            
            }//enemy base coord found
          
          }//bOK
        
          _struct = enumStruct();
        }//loop through single AA
       
        _i++;
      } //AA struct loop
	  
    } //alliance check
    
    _nEnemyPlayer++;
  }//player loop

  //if ( _oAAtarget == NULLOBJECT ){
    //printDebug1("getAAgroups; AA target not found ");
  //} else {
    //printDebug1("getAAgroups; AA target found ");
    //printDebug1("getAAgroups; AA target found player("& getPlayerName(_oAAtarget) &") Id("& _oAAtarget.id &") x-y("& _oAAtarget.x/TILE &")-("& _oAAtarget.y/TILE &")");
  //}
  return _oAAtarget;
  
}
//-----------------------------------------------------------------------------
function bool bHasHumanEnemies(int _player)
{
  local int _c;
  _c = 0;
  while( _c < MAX_PLAYERS )
	{
	 if ( isHumanPlayer(_c) and !allianceExistsBetween(_player,_c) ) {
	   return true;
   }
	 _c++;
  }
  return false;
}
//-----------------------------------------------------------------------------
function int getRandomEnemyPlayer(bool _mustBeHuman)
{
  local int _player,_counter;
  
  _player = random(MAX_PLAYERS);
  _counter = 0;
  while( _counter < MAX_PLAYERS )
	{

    if ( _player != player ){
      boolResult = true;
      if ( _mustBeHuman and !isHumanPlayer(_player) ){
        boolResult = false;
      }
    	if( boolResult and !friendlyPlayer(_player) and isPlayerStillLive(_player)  )	{ 
        return _player;	
      }
    }
		_player++; _counter++;
		if ( _player == 8 ){ _player = 0;  }
	}
	return -1;
} 
//-----------------------------------------------------------------------------
function int getNearestEnemyPlayer(bool _humanPlayer)
{ 
  local STRUCTURE _struct;
  local int _player, _targetPlayer, _bestDist, _dist,_xCoord,_yCoord;
  
  _struct       = NULLOBJECT;
  _player       = 0;
	_targetPlayer = -1;
	_bestDist     = 9999999;

  while( _player < MAX_PLAYERS )
	{  	
    if ( _player != player ){
      boolResult = true;
      if ( _humanPlayer and !isHumanPlayer(_player) ){
        boolResult = false;
      }
      if ( !isPlayerStillLive(_player) ){
        boolResult = false;
      }
      if (!friendlyPlayer(_player) and boolResult){//OK
  
        _xCoord = aPl[_player][X_COORD];
        _yCoord = aPl[_player][Y_COORD];
        if ( _yCoord > 0 and _yCoord > 0 ){
          _dist = distBetweenTwoPoints(_xCoord,_yCoord, baseX, baseY);
          if ( _dist < _bestDist ){
            _bestDist     = _dist;
            _targetPlayer = _player;
          }
        }
        
      }//player check
    }

    _player++;
  }//while 
  return _targetPlayer; 
}

//-----------------------------------------------------------------------------
function void updatePlCoord()
{
	local int _player;

	_player = 0;
	while( _player < MAX_PLAYERS )
	{
		if( isPlayerStillLive(_player) ){
  		
		  aPl[_player][X_COORD] = getEnemy_baseCoord( _player , "X" );
		  aPl[_player][Y_COORD] = getEnemy_baseCoord( _player , "Y" );
      
      if( friendlyPlayer(_player) )
  		{ aPl[_player][IS_ENEMY] = 0;	} 
      else 
      { aPl[_player][IS_ENEMY] = 1;	}
		
    	if ( !bPositionUpdated ){
    	  aPl[_player][PL_POSITION] = getPlayerPos(_player);
    	  printDebug1("Player Map Position #("&  _player &")("& aPl[_player][PL_POSITION]   &")");
      }

    } else {
    
		  aPl[_player][X_COORD]  = -1;
		  aPl[_player][Y_COORD]  = -1;
		  aPl[_player][IS_ENEMY] = -1;
		  aPl[_player][PL_POSITION] = -1;
    
    }

		_player++;

	}
	
  bPositionUpdated = true;
  
}
//-----------------------------------------------------------------------------
function int getEnemy_baseCoord( int _player, STRING sCoord )
{
	local	STRUCTURE	_structure;
	local	int	_i,_index,_baseX,_baseY,_numBaseStructs,_numBaseStructsFound,_numDroidsFound;
  local STRUCTURESTAT _baseStructs[10];
	local DROID _droid;
	
	_i = 0;
	if ( isScavenger(_player) ){
    _numBaseStructs = nScavStruct;
    _numBaseStructs--; //do not include derricks
    while ( _i < _numBaseStructs ){ 
      _baseStructs[_i] = aScavBaseStr[_i];
      _i++;
    }
  } else {
    _numBaseStructs = numBaseStructs;
    _numBaseStructs--; //do not include derricks baseStructs[9]
    while ( _i < _numBaseStructs ){ 
      _baseStructs[_i] = baseStructs[_i];
      _i++;
    }
  }
  
  //Go through all structures or droids if no structs are found
	_index = 0;
	_numBaseStructsFound = 0;
	_numDroidsFound = 0;
	_baseX = 0;
	_baseY = 0;
	
	while(_index < _numBaseStructs)//+1 to exclude derricks!!
	{
		initEnumStruct( false, _baseStructs[_index], _player, _player);
		_structure = enumStruct();

		while(_structure != NULLOBJECT)
		{
			_baseX = _baseX + _structure.x / TILE;
			_baseY = _baseY + _structure.y / TILE;
			_numBaseStructsFound++;
			_structure = enumStruct();
		}
		_index++;
	}

	if(_numBaseStructsFound > 0)
	{
		_baseX = (_baseX / _numBaseStructsFound) * TILE;
		_baseY = (_baseY / _numBaseStructsFound) * TILE;
    //displayMsg("getEnemy_baseCoord: Base Structs tmethod #1 ok  _baseX("& _baseX/TILE &")_baseY("& _baseY/TILE &") ");
	
  } else {
    
    //method #2 - droids, maybe game started with no bases
    InitEnumDroids(_player,_player);
    _droid = EnumDroid();
    while(_droid != NULLOBJECT)
    {
			_baseX = _baseX + _droid.x / TILE;
			_baseY = _baseY + _droid.y / TILE;
			_numDroidsFound++;
      _droid = EnumDroid();
    }

  	if(_numDroidsFound > 0)
  	{
  		_baseX = (_baseX / _numDroidsFound) * TILE;
  		_baseY = (_baseY / _numDroidsFound) * TILE;
    } else {
      printDebug1("#### getEnemy_baseCoord; 2-not able to find any droid for player ("& _player &") ");
      return 0;
    } 
  
  }
  
  //let`s check...
  if ( (_baseX == 0 or _baseY == 0) and isPlayerStillLive(_player) ){
    printDebug1("#### getEnemy_baseCoord; 2-not able to find base coord for player ("& _player &")");
  }
  
  if ( sCoord == "X" or sCoord == "x" ) { 
    return _baseX; 
  } else { 
    return _baseY; 
  }
  
  return 0;
}
 

//-----------------------------------------------------------------------------
function bool friendlyPlayer(int _playerToCheck)
{
	if(allianceExistsBetween(_playerToCheck, player) or (_playerToCheck == player)){
		return true;
	}

	return false;
}
//-----------------------------------------------------------------------------
function BASEOBJ objHumanDerrick(bool bVTOLTarget, int _numDef, int _distInTiles)
{
  local BASEOBJ _objTarget;
  local int _targetPlayer,_dist,_dist2,_dist3,_tmpDist,_defences,_mapSize,_xCoord, _yCoord;
  local	STRUCTURE	_tempDerrick;
  
  _targetPlayer = 0;
  _objTarget    = NULLOBJECT;
  _dist         = 9999*TILE;
  _defences     = -1;
  
  while ( _targetPlayer < MAX_PLAYERS )
  {
    if ( _targetPlayer != player and !friendlyPlayer(_targetPlayer) and isHumanPlayer(_targetPlayer) ) 
    {
      
      initEnumStruct(false,derrick,_targetPlayer,_targetPlayer);
    	_tempDerrick = enumStruct();
    	while( _tempDerrick != NULLOBJECT ){
    	  
        boolResult = true; 

        _xCoord = aPl[_targetPlayer][X_COORD];
        _yCoord = aPl[_targetPlayer][Y_COORD];

        _tmpDist = distBetweenTwoPoints(baseX,baseY,_tempDerrick.x, _tempDerrick.y);
        _dist2  = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY);
        _dist3  = distBetweenTwoPoints(_xCoord, _yCoord, baseX, baseY);
        if ( _dist2 > _dist3 and distBetweenTwoPoints(_xCoord, _yCoord, _tempDerrick.x, _tempDerrick.y) < nDefendRange/2  )
        { 
          boolResult = false; 
        }
        if ( _dist2 < _dist3 and distBetweenTwoPoints(_xCoord, _yCoord, _tempDerrick.x, _tempDerrick.y) < nBaseRange+10*TILE )
        { 
          boolResult = false; 
        }
        
        if ( boolResult ){
          if ( bVTOLTarget ){
            _defences = getAA_OnTheWay(baseX, baseY, _tempDerrick.x, _tempDerrick.y, AA_THREAT_RANGE);
            if (_defences > _numDef) { boolResult = false; }
      	  } else {
            //if ( _tmpDist > ((mapWidth*TILE+mapHeight*TILE)/4) ) { boolResult = false; }
            _defences = numEnemyWeapDroidsInRange(player, _tempDerrick.x, _tempDerrick.y, _distInTiles*TILE , false);
            _defences = _defences + numEnemyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, _distInTiles*TILE , false);
            if (_defences > _numDef) { boolResult = false; }
          }
        }
        
        if ( boolResult and _tmpDist < _dist ){
    	    _objTarget = _tempDerrick;
    	    _dist      = _tmpDist;
        }
    	  _tempDerrick = enumStruct();
      }
      
    }
    _targetPlayer++;
  }
  
  return _objTarget;
}
//-----------------------------------------------------------------------------
function BASEOBJ objStrTargetInRange(int _xCoord,int _yCoord, int _Range)
{
  local BASEOBJ _objTarget;
  local int _x,_y,_x1,_y1;
  local int _xx, _yy, _targetPlayer;
  
	resetStructTargets();
	setStructTarIgnore(ST_WALL);
	setStructTarPref(ST_DEF_GROUND);
	setStructTarPref(ST_FACTORY);
	setStructTarPref(ST_CYBORG_FACTORY);
	setStructTarPref(ST_VTOL_FACTORY);
	setStructTarPref(ST_POWER_GEN);
	//setStructTarPref(ST_SENSOR);
	setStructTarPref(ST_RESOURCE_EXTRACTOR);
	setStructTarPref(ST_DEF_AIR);
	setStructTarPref(ST_RESEARCH);
	setStructTarPref(ST_HQ);
	setStructTarPref(ST_REARM_PAD);
	setStructTarPref(ST_SENSOR);

  _objTarget = NULLOBJECT;
  _Range =  _Range/2 ;

  _xx = (mapWidth*128)-(128*2);
  _yy = (mapHeight*128)-(128*2);
 
  _x  = min( _xCoord + _Range , _xx );
  _y  = min( _yCoord + _Range , _yy );
  _x1 = max( _xCoord - _Range , 256);
  _y1 = max( _yCoord - _Range , 256);

  _targetPlayer = 0;
  while ( _targetPlayer < MAX_PLAYERS and _objTarget == NULLOBJECT){
    if ( _targetPlayer != player and !friendlyPlayer(_targetPlayer) )
    {
      _objTarget = structTargetInArea(_targetPlayer, player, _x, _y, _x1, _y1);
      if (_objTarget != NULLOBJECT)
      {
        //displayMsg("objStrTargetInRange: dist("& distBetweenTwoPoints(_xCoord, _yCoord, _objTarget.x, _objTarget.y)/TILE &") range ("& _Range/TILE &") - ("& _xCoord/TILE &") ("& _yCoord/TILE &")  ");
        if ( distBetweenTwoPoints(_xCoord, _yCoord, _objTarget.x, _objTarget.y) > _Range ) 
        {
          _objTarget = NULLOBJECT;
        }
      }
    }
    _targetPlayer++;
  }
  return _objTarget;
}
//-----------------------------------------------------------------------------
function BASEOBJ objDroidTargetInRange(int _xCoord ,int _yCoord, int _Range, bool bIsVTOL)
{
  local BASEOBJ _objTarget;
  local DROID _droid;
  local int _x,_y,_x1,_y1;
  local int _xx, _yy, _n, _bestHitPoints;
  
  resetDroidTargets();
  setDroidTarIgnore(ST_WALL);
  if ( bIsVTOL ){
    setDroidTarPref(DT_SUPER_HEAVY); 
    setDroidTarPref(DT_HEAVY); 
    setDroidTarPref(DT_MEDIUM);
    setDroidTarPref(DT_LIGHT);
    setDroidTarPref(DT_LEGS);
    setDroidTarPref(DT_VTOL);
  }
  else//tank or cyborg
  {
    setDroidTarPref(DT_SENSOR);
    setDroidTarPref(DT_CONSTRUCT);
    setDroidTarPref(DT_COMMAND);
    setDroidTarPref(DT_REPAIR);
    setDroidTarPref(DT_WEAP_GROUND); 
    setDroidTarPref(DT_WEAP_AIR); 
    setDroidTarPref(DT_WEAP_ALL); //Ground,air,idf units
  }


  if ( targetPlayerVTOL == player ) {
    targetPlayerVTOL = -1;
  }
  
  _objTarget = NULLOBJECT;
  
  _xx = (mapWidth*128)-(128*2);
  _yy = (mapHeight*128)-(128*2);
  
  //_Range = _Range/2;
 
  _x  = min( _xCoord + _Range , _xx );
  _y  = min( _yCoord + _Range , _yy );
  _x1 = max( _xCoord - _Range , 256);
  _y1 = max( _yCoord - _Range , 256);

  if (bIsVTOL and targetPlayerVTOL > -1){
    _n=0;
    _bestHitPoints=0;
    InitEnumDroids(targetPlayerVTOL,player);
    _droid = EnumDroid();
    while(_droid != NULLOBJECT)
    {
      if (!isVtol(_droid) and distBetweenTwoPoints(_droid.x,_droid.y,_xCoord,_yCoord) < 15*TILE){
        if ( getAA_OnTheWay(baseX, baseY, _droid.x, _droid.y, AA_THREAT_RANGE)*4 < vtolGr.members ){
          if ( _droid.hitPoints > _bestHitPoints ){
           _objTarget = _droid;
           _bestHitPoints = _droid.hitPoints;
          }
        }
      }
      _n++;
      _droid = EnumDroid();
    }
  }

  if ( _objTarget == NULLOBJECT ){
    _n = 0;
    while ( _n < MAX_PLAYERS and _objTarget == NULLOBJECT){
      if ( _n != player and !friendlyPlayer(_n) )
      {
        _objTarget = droidTargetInArea(_n, player, _x, _y, _x1, _y1);
        if (_objTarget != NULLOBJECT){
          if ( isVtol(objToDroid(_objTarget)) or distBetweenTwoPoints(_xCoord, _yCoord, _objTarget.x, _objTarget.y) > _Range ) 
          {
            _objTarget = NULLOBJECT;
          }
        }
      }
      _n++;
    }
  } //else {
    //if (bIsVTOL){displayMsg("objDroidTargetInRange: ***** best target for VTOL found: Id("& _objTarget.id &") hitPoints("& _objTarget.hitPoints &")");}
  //}
  return _objTarget;
}
//-----------------------------------------------------------------------------
function void orderGroupMoveCMD(GROUP _grp, int _x, int _y)
{
  local int _c;
  local DROID _tempTruck;
  
  _c = 0;
	
  initIterateGroup(_grp);
	_tempTruck = iterateGroup(_grp);
  while ( _tempTruck != NULLOBJECT ){
    if (droidCanReach(_tempTruck,_x, _y )){
      orderDroidLoc(_tempTruck, DORDER_MOVE,_x, _y );
    }
		_tempTruck = iterateGroup(_grp);
    _c++;
  }
  return;
}

//-----------------------------------------------------------------------------
function void orderGroupScoutCMD(GROUP _grp, int _x, int _y)
{
  local int _c;
  local DROID _tempTruck;
  
  _c = 0;
	
  initIterateGroup(_grp);
	_tempTruck = iterateGroup(_grp);
  while ( _tempTruck != NULLOBJECT ){
    if ( distBetweenTwoPoints( _tempTruck.x, _tempTruck.y, _x, _y ) > 2*TILE and droidCanReach(_tempTruck,_x, _y ) ){
      orderDroidLoc(_tempTruck, DORDER_SCOUT, _x, _y );
    }
		_tempTruck = iterateGroup(_grp);
    _c++;
  }
  return;
}
//-----------------------------------------------------------------------------
function void SetDyDoPersonality(int nPersonality, int _player)
{
  local int _cc,_c,_nAddFact,_nAddCybFact,_nAddResLab,_nAddVTOL,_nDerricksPlayer,_nTeamMates;
  
  _cc=0;
  _nDerricksPlayer = nDerricksAtStart+(nFreeOilRes/nPlayersInGame);
  _nTeamMates   = getNumTeamMates();
  _nAddFact   = 0;
  _nAddResLab = 0;
  _nAddVTOL   = 0;
  _nAddCybFact= 0;

  if (_player != player){exit;}
  
  //if team has 3 members one AI should be turtle or VTOL
  //if team has 4 members one AI should be turtle, cyborg or VTOL
  // bLastMembPersIsSet is required if humPl wants to set personalities on this AI
  if ( bLastMember and !bLastMembPersIsSet ){
    bLastMembPersIsSet = true;
    if ( _nTeamMates == 2 ){
      nPersonality = 2+random(2);//2-VTOL,3-Turtle
    }
    if ( _nTeamMates == 3 ){
      nPersonality = 2+random(3);//2-VTOL,3-Turtle,4-cyborg
    }
  }
  
  //random personality
  if ( nPersonality == 0 or nPersonality > 4 ){
    _c = nPersonality;
    if ( random(100) < 80 ){//80% General 1 
      _c = 1;
    } else {//30% for General 2-3-4
      _c  = 2+random(6);
      if ( _c > 4 ){
        if ( _c == 5 ) { _c = 2;}
        if ( _c == 6 ) { _c = 3;}
        if ( _c == 7 ) { _c = 4;}
      }
    }
    AIPersonality = _c;
    _c--;
    nAI_Pers      = _c;
  } else {
    AIPersonality = nPersonality;
    nPersonality--;
    nAI_Pers      = nPersonality;
  }
  
  //update struct to be built
  if (_nDerricksPlayer < 7){
    nMapPower = VERY_LOW_POWER_MAP;     
    _nAddFact       = -2;
    _nAddCybFact    = -1;
    _nAddVTOL       = -1;
    _nAddResLab     = -1;
  } else if (_nDerricksPlayer >= 7 and _nDerricksPlayer < 10){
    nMapPower   = LOW_POWER_MAP;
    _nAddFact       = -1;
    _nAddVTOL       = -1;
  } else if (_nDerricksPlayer >= 10 and _nDerricksPlayer < 13){
    nMapPower = NORMAL_POWER_MAP;     
    nMapPower   = LOW_POWER_MAP;
  } else if (_nDerricksPlayer >= 13 and _nDerricksPlayer < 16 ){
    nMapPower = HIGH_POWER_MAP;     
    _nAddFact       = 1;
    _nAddCybFact    = 1;
    _nAddVTOL       = 1;
  } else if (_nDerricksPlayer >= 16 ){
    nMapPower = HIGH_POWER_MAP;     
    _nAddResLab     = 2;
    _nAddFact       = 2;
    _nAddCybFact    = 2;
    _nAddVTOL       = 2;
  }


  //update array
  if ( AIPersonality != AI_CYBORG ){
    strToBuild[nAI_Pers][STR_TANK_FACTORY] =_nAddFact + structsLimits[nAI_Pers][STR_TANK_FACTORY];
  }
  strToBuild[nAI_Pers][STR_RESLAB]       =_nAddResLab  + structsLimits[nAI_Pers][STR_RESLAB];
  strToBuild[nAI_Pers][STR_CYB_FACTORY]  =_nAddCybFact + structsLimits[nAI_Pers][STR_CYB_FACTORY];
  strToBuild[nAI_Pers][STR_VTOL_FACTORY] =_nAddVTOL    + structsLimits[nAI_Pers][STR_VTOL_FACTORY];

  //set to 5 if too high.
  if (strToBuild[nAI_Pers][STR_TANK_FACTORY] > 5)  {strToBuild[nAI_Pers][STR_TANK_FACTORY] = 5;}
  if (strToBuild[nAI_Pers][STR_RESLAB] > 5)        {strToBuild[nAI_Pers][STR_RESLAB] = 5;}
  if (strToBuild[nAI_Pers][STR_CYB_FACTORY] > 5)   {strToBuild[nAI_Pers][STR_CYB_FACTORY] = 5;}
  if (strToBuild[nAI_Pers][STR_VTOL_FACTORY] > 5)  {strToBuild[nAI_Pers][STR_VTOL_FACTORY] = 5;}

  //set to 1 if less then 1.
  if (strToBuild[nAI_Pers][STR_TANK_FACTORY] < 1)  {strToBuild[nAI_Pers][STR_TANK_FACTORY] = 1;}
  if (strToBuild[nAI_Pers][STR_RESLAB] < 1)        {strToBuild[nAI_Pers][STR_RESLAB] = 1;}
  if (strToBuild[nAI_Pers][STR_CYB_FACTORY] < 2)   {strToBuild[nAI_Pers][STR_CYB_FACTORY] = 2;}
  if (strToBuild[nAI_Pers][STR_VTOL_FACTORY] < 1)  {strToBuild[nAI_Pers][STR_VTOL_FACTORY] = 1;}

  if ( nResTmplPath == -1 or AIPersonality == AI_CYBORG ){
    nResTmplPath = RESTMPL_0;
  }    
  if ( AIPersonality == AI_CYBORG ){
    strToBuild[nAI_Pers][STR_VTOL_FACTORY] = 0;
  }    

  if ( IsTeamLeader() and !lPathSet ){

    //Set the research paths
    if ( nT_Game == T1_GAME and nMapPower <= NORMAL_POWER_MAP ){
      if ( random(2) == 0 ){
        nResTmplPath = RESTMPL_1;    
      } else {
        nResTmplPath = RESTMPL_2;    
      }
    } else {
      if ( nT_Game == T2_GAME and nMapPower <= LOW_POWER_MAP ){
        if ( random(2) == 0 ){
          nResTmplPath = RESTMPL_1;    
        } else {
          nResTmplPath = RESTMPL_2;    
        }
      } else {
        _c = random(3);
        if ( _c == 0 ){ nResTmplPath = RESTMPL_0;}
        if ( _c == 1 ){ nResTmplPath = RESTMPL_1;}
        if ( _c == 2 ){ nResTmplPath = RESTMPL_2;}
      }
    }
    
    if ( nResTmplPath == 0 ){   sendMsgToAllAllies("rp0",false);   }
    if ( nResTmplPath == 1 ){   sendMsgToAllAllies("rp1",false);   }
    if ( nResTmplPath == 2 ){   sendMsgToAllAllies("rp2",false);   }
    printDebug1("SetDyDoPers; player is team leader, send msg to teammates (PATH=="& nResTmplPath &") ");
    if ( nResTmplPath == 0 ){
      console("Player("& getPlayerName(player) &")("& player &") Team Leader("& IsTeamLeader() &")("& bLastMember &"): Research path set to # "& nResTmplPath &" (All technologies), AIPersonality("& AIPersonality &") !");
    }    
    if ( nResTmplPath == 1 ){
      console("Player("& getPlayerName(player) &")("& player &") Team Leader("& IsTeamLeader() &")("& bLastMember &"): Research path set to # "& nResTmplPath &" (Flamers and Rockets), AIPersonality("& AIPersonality &") !");
    }    
    if ( nResTmplPath == 2 ){
      console("Player("& getPlayerName(player) &")("& player &") Team Leader("& IsTeamLeader() &")("& bLastMember &"): Research path set to # "& nResTmplPath &" (Gunners and Cannons), AIPersonality("& AIPersonality &") !");
    }    
    SetDyDoPath();
    lPathSet = true;
  
  }
  
  //print off stats
  printDebug1("SetDyDoPers; derricks("& nDerricksAtStart &") oilRes("& nFreeOilRes &") Derr/Pl("& _nDerricksPlayer &") players("& nPlayersInGame &") TeamMates("& _nTeamMates &") mapPowerType ("& nMapPower &") Pers("& AIPersonality &")");
  printDebug1("SetDyDoPers; Standard ResLab-Fact-Cyb-VTOL("& structsLimits[nAI_Pers][STR_RESLAB] &"-"& structsLimits[nAI_Pers][STR_TANK_FACTORY] &"-"& structsLimits[nAI_Pers][STR_CYB_FACTORY] &"-"& structsLimits[nAI_Pers][STR_VTOL_FACTORY] &") ");
  printDebug1("SetDyDoPers; Selected ResLab-Fact-Cyb-VTOL("& strToBuild[nAI_Pers][STR_RESLAB] &"-"& strToBuild[nAI_Pers][STR_TANK_FACTORY] &"-"& strToBuild[nAI_Pers][STR_CYB_FACTORY] &"-"& strToBuild[nAI_Pers][STR_VTOL_FACTORY] &") mapPowerType ("& nMapPower &") _nAddFact("& _nAddFact &") _nAddCyb("& _nAddCybFact &") _nAddVTOL("& _nAddVTOL &") ");

}
//-----------------------------------------------------------------------------
function bool aiResponsibleForPlayer(int _player)
{
	if(_player == selectedPlayer or not myResponsibility(_player))
	{
		return false;
	}

	return true;
}
//-----------------------------------------------------------------------------
function void assignDroidToGrp(DROID droid)
{

/*  
buildDefGrp.members
buildGrp.members
cybConstGrp.members 
cyborgAttGroup.members
cyborgDefGroup.members
harvesterGroup.members
helpGroup.members
repairGroup.members
tankDefGroup.members
tankGroup.members
toBeRepairedCyborgGroup.members
toBeRepairedTankGroup.members
vtolGr.members
vtolAttGr.members
vtolHunterGr.members
*/
  // TANK
  if ( droid == NULLOBJECT ){ return; } 
  if ( droid.player != player ){ return; } 


  if(droid.droidType == DROID_WEAPON and droid.propulsion != cyborgPropulsion)
	{
    groupAddDroid(tankDefGroup, droid);
	}

// CYBORG-TANK REPAIR
	if(droid.droidType == DROID_REPAIR or droid.droidType == DROID_CYBORG_REPAIR)
	{
    groupAddDroid(repairGroup, droid);
	}

// VTOL/CYBORG/TANK TRUCK
	if( droid.droidType == DROID_CONSTRUCT and droid.propulsion != cyborgPropulsion )
	{
      groupAddDroid(buildGrp, droid);
  }

// CYBORG
if(droid.propulsion == cyborgPropulsion and droid.droidType != DROID_CYBORG_REPAIR)
{
	if(droid.droidType == DROID_CYBORG_CONSTRUCT)
	{
	  //displayMsg("droidBuilt: cyborg ("& droid.id &") hitPoints ("& droid.hitPoints &") power ("& calcDroidPower(droid) &") assigned to cybConstGrp");
    groupAddDroid(cybConstGrp, droid);
	} else {
    nTotCyborgBuilt++;
	  if ( AIPersonality == AI_CYBORG ){
	    //displayMsg("droidBuilt: cyborg ("& droid.id &") hitPoints ("& droid.hitPoints &") power ("& calcDroidPower(droid) &") assigned to cyborgDefGroup");
		  groupAddDroid(cyborgDefGroup, droid);
    } else {
      if (nTotCyborgBuilt > 2){
        //displayMsg("droidBuilt: ["& nTotCyborgBuilt &"] CYBORG ("& droid.id &") hitPoints ("& droid.hitPoints &") power ("& calcDroidPower(droid) &") assigned to tankDefGroup ");
				groupAddDroid(tankDefGroup, droid);
				nTotCyborgBuilt = 0;
      } else {
	      //displayMsg("droidBuilt: ["& nTotCyborgBuilt &"] cyborg ("& droid.id &") hitPoints ("& droid.hitPoints &") power ("& calcDroidPower(droid) &") assigned to cyborgDefGroup ");
		    groupAddDroid(cyborgDefGroup, droid);
      }
    }
	}
}

// VTOL
	boolResult = false;
	if((isVtol(droid)) and (droid.droidType != DROID_CONSTRUCT))
	{
		groupAddDroid(vtolGr, droid);
	}

	//debug check
  if ( !hasGroup(droid) ){
    //dbg("dbg->assignDroidToGrp: player("& getPlayerName(player) &") found a droid with no group ("& droid.id &"), force assign to tankdefGroup",player);
    groupAddDroid(tankDefGroup, droid);
  }
   
	setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
  if( droid.droidType == DROID_WEAPON or droid.droidType == DROID_CYBORG ){         
	  setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);
	  setDroidSecondary(droid,DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
	  setDroidSecondary(droid,DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS);
	}
}
//-----------------------------------------------------------------------------
/* what to stop, keep working 
[ResLab - TkFact - cybFac - VTOLFact] (Defences - RepairFac)
0- [2-2-2-1] (0-0) 
1- [3-0-0-0] (M-0)
2- [3-M-M-M] (0-0)
3- [M-1-1-0] (0-M)
4- [M-1-1-0] (0-M)
5- [M-0-0-0] (M-M)
6- [2-1-1-1] (M-M)
7- [0-0-0-0] (0-0)
nDerricksAtStart+(nFreeOilRes/nPlayersInGame)
*/
function void manageVeryLowPower()
{
  if ( nProdSelect == 0 ){//standard
    lStopResearch = false;
    if ( nWorkingFact   >= 2 ){lStopTankProduction = true; } 
    if ( nWorkingCybFac >= 2 ) {lStopCybProduction  = true; }
    if ( nWorkingVTOLFac >= 1){lStopVTOLProduction  = true; }
    lStopBuildDef            = true;
    lStopBuildDefDerricks    = true;
    lStopBuildDefGateway     = true;
    lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 1){ //ok defences and upgrades 
    lStopResearch = false;
    lStopTankProduction  = true;  
    lStopCybProduction   = true; 
    lStopVTOLProduction  = true; 
    //lStopBuildDefGateway     = true;
    //lStopBuildDef            = true;
    //lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  }
  if ( nProdSelect == 2){ //ok units production
    lStopResearch = false;
    //lStopTankProduction      = true;  
    //lStopCybProduction       = true; 
    //lStopVTOLProduction      = true; 
    lStopBuildDef            = true;
    lStopBuildDefDerricks    = true;
    lStopBuildDefGateway     = true;
    lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 3){
    //lStopResearch = true;
    if ( nWorkingFact  >= 1 ){lStopTankProduction = true; } 
    if ( nWorkingCybFac >= 1 ) {lStopCybProduction  = true; }
    lStopVTOLProduction      = true; 
    lStopBuildDef            = true;
    lStopBuildDefDerricks    = true;
    lStopBuildDefGateway     = true;
    //lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 4){
    //lStopResearch       = true;
    if ( nWorkingFact  >= 1 ){lStopTankProduction = true; } 
    if ( nWorkingCybFac >= 1 ){lStopCybProduction  = true; }
    lStopVTOLProduction      = true; 
    lStopBuildDef            = true;
    lStopBuildDefGateway     = true;
    lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 5){
    if ( nWorkingLab    >= 2){lStopResearch       = true; }
    //lStopResearch        = true;
    lStopTankProduction  = true;  
    lStopCybProduction   = true; 
    lStopVTOLProduction  = true; 
    //lStopBuildDef            = true;
    //lStopBuildDefDerricks    = true;
    //lStopBuildDefGateway     = true;
    //lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 6){
    if ( nWorkingLab    >= 2){lStopResearch       = true; }
    if ( nWorkingFact   >= 1){lStopTankProduction = true; } 
    if ( nWorkingCybFac >= 1){lStopCybProduction  = true; }
    if ( nWorkingVTOLFac >= 1){lStopVTOLProduction  = true; }
    //lStopBuildDef            = true;
    //lStopBuildDefGateway     = true;
    //lStopBuildDefDerricks    = true;
    //lStopBuildRepFacility    = true;
  } 
  if ( nProdSelect == 7){ //stop all
    lStopTankProduction      = true;  
    lStopCybProduction       = true;
    lStopVTOLProduction      = true;
    lStopResearch            = true;
    lStopBuildDef            = true;
    lStopBuildDefGateway     = true;
    lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  }

  //activate VTOL production if min droids has been reached
  if ( vtolGr.members  < MIN_VTOLS and nVTOLFactories > 0 ){
    lStopVTOLProduction = false;
    if ( (nTotCyborgs+nTotTanks) > 15 ){
      if ((gameTime - tLastTankAttack < 7*TIME_MINUTE) and (gameTime - tLastCyborgAttack < 7*TIME_MINUTE))
      {
        lStopTankProduction = true;
        lStopCybProduction  = true;
      }
    }
  }
  
  
}
//==================================================
function void manageVeryLowPower2()  //Personality General 2
{
  if ( nProdSelect < 3 ){
    if ( vtolGr.members  < MIN_VTOLS_PERS2 and nVTOLFactories > 0){
      //lStopVTOLProduction     = false;
      lStopTankProduction     = true;
      lStopCybProduction      = true;
      if ( nWorkingLab >= 2 )   {lStopResearch       = true; }
      lStopBuildDef           = true;
      lStopBuildDefDerricks   = true;
      lStopBuildRepFacility   = false;
      lStopBuildDefGateway    = true;
    } else {
      if ( nWorkingVTOLFac >= 2){lStopVTOLProduction = true; }
      if ( nWorkingFact >= 0 )  {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 0) {lStopCybProduction  = true; }
      //lStopResearch            = true; 
      lStopBuildDef            = true;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
    }    
  } 
  
  if ( nProdSelect == 3 or nProdSelect == 4 ){
    if ( vtolGr.members  < MIN_VTOLS_PERS2 and nVTOLFactories > 0 ){
      //lStopVTOLProduction = false;
      lStopTankProduction = true;
      lStopCybProduction  = true;
      //lStopResearch       = true;
      lStopBuildDef            = true;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
    } else {
      if ( nWorkingVTOLFac >= 1){lStopVTOLProduction = true; }
      if ( nWorkingFact >= 2 )  {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 2) {lStopCybProduction  = true; }
      //lStopResearch       = true;
      //lStopBuildDef            = false;
      //lStopBuildDefDerricks    = false;
      //lStopBuildRepFacility    = false;
      //lStopBuildDefGateway     = false;
    }
  }
  
  if ( nProdSelect == 5 ){
    if ( vtolGr.members  < MIN_VTOLS_PERS2 and nVTOLFactories > 0 ){
      //lStopVTOLProduction    = false;
      lStopTankProduction      = true;
      lStopCybProduction       = true;
      if ( nWorkingLab >= 3 )   {lStopResearch       = true; }
      lStopBuildDef            = true;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
    } else {
      if ( nWorkingVTOLFac >= 1){lStopVTOLProduction = true; }
      if ( nWorkingFact >= 2 )  {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 2) {lStopCybProduction  = true; }
      if ( nWorkingLab >= 3 )   {lStopResearch       = true; }
      //lStopBuildDef            = false;
      //lStopBuildDefDerricks    = false;
      //lStopBuildRepFacility    = false;
      //lStopBuildDefGateway     = false;
    }
  }

  if ( nProdSelect == 6 ){
    if ( vtolGr.members  < MIN_VTOLS_PERS2 and nVTOLFactories > 0 ){
      //lStopVTOLProduction = false;
      lStopTankProduction      = true;
      lStopCybProduction       = true;
      if ( nWorkingLab >= 3 )   {lStopResearch       = true; }
      lStopBuildDef            = true;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
    } else {
      if ( nWorkingVTOLFac >= 2){lStopVTOLProduction = true; }
      if ( nWorkingFact >= 1 )  {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 1) {lStopCybProduction  = true; }
      if ( nWorkingLab >= 2 )   {lStopResearch       = true; }
      //lStopBuildDef            = false;
      //lStopBuildDefDerricks    = false;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
    }
  }

  if ( nProdSelect == 7){
    lStopTankProduction      = true;  
    lStopCybProduction       = true;
    lStopVTOLProduction      = true;
    lStopResearch            = true;
    lStopBuildDef            = true;
    lStopBuildDefGateway     = true;
    lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  }
  
  if ( gameTime > TIME_START_VTOLRESEARCH ){
    if ( !skVtolEnableCheck(player) ){
        lStopResearch  = false; 
    }
  }

  //concentrate on VTOL production if min VTOL has not been reached
  if ( vtolGr.members  < MIN_VTOLS_PERS2 and nVTOLFactories > 0 and ( (nTotCyborgs+nTotTanks) > MIN_TOT_UNITS) ){
    lStopVTOLProduction   = false;
    lStopTankProduction   = true;
    lStopCybProduction    = true;
    lStopBuildDefGateway  = true;
    lStopBuildDef         = true;
    lStopBuildDefDerricks = true;
  }

}
//==================================================
function void manageVeryLowPower3()  //Personality General 3 - Turtle AI
{
  
  if ( nProdSelect < 3 ){
      if ( nWorkingVTOLFac>= 0) {lStopVTOLProduction = true; }
      if ( nWorkingFact   >= 1) {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 1) {lStopCybProduction  = true; }
      lStopResearch            = false; 
      lStopBuildDef            = false;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = false;
  } 
  if ( nProdSelect >= 3 and nProdSelect < 6 ){
      if ( nWorkingVTOLFac>= 0) {lStopVTOLProduction = true; }
      if ( nWorkingFact   >= 2) {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 2) {lStopCybProduction  = true; }
      lStopResearch            = false; 
      lStopBuildDef            = false;
      lStopBuildDefDerricks    = false;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = false;
  } 
  if ( nProdSelect == 6 ){
      if ( nWorkingVTOLFac>= 1) {lStopVTOLProduction = true; }
      if ( nWorkingFact   >= 1) {lStopTankProduction = true; } 
      if ( nWorkingCybFac >= 1) {lStopCybProduction  = true; }
      lStopResearch            = false; 
      lStopBuildDef            = false;
      lStopBuildDefDerricks    = false;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = false;
  } 

  if ( nProdSelect == 7){
    lStopTankProduction      = true;  
    lStopCybProduction       = true;
    lStopVTOLProduction      = true;
    lStopResearch            = true;
    lStopBuildDef            = true;
    lStopBuildDefGateway     = true;
    lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  }

  //reduce droids production
  if ( nTotTanks >= 20 and gameTime > 15*TIME_MINUTE ){
    if ( nWorkingFact >= 1) {lStopTankProduction = true; } 
    if ( nWorkingCybFac >= 1) {lStopCybProduction  = true; }
  }  

  //activate VTOL production if min droids has been reached
  if ( vtolGr.members  < MIN_VTOLS and nVTOLFactories > 0 and ( (nTotCyborgs+nTotTanks) > MIN_TOT_UNITS) ){
    lStopVTOLProduction = false;
    lStopTankProduction = true;
    lStopCybProduction  = true;
  }
}

//==================================================
function void manageVeryLowPower4()  //Personality General 4
{
  if ( nProdSelect < 3 ){
      if ( nWorkingVTOLFac>= 1) {lStopVTOLProduction = true; }
      lStopTankProduction = false; 
      if ( nWorkingCybFac >= 2) {lStopCybProduction  = true; }
      //lStopResearch       = true; 
      lStopBuildDef            = false;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
  } 
  if ( nProdSelect >= 3 and nProdSelect < 6 ){
      if ( nWorkingVTOLFac>= 0) {lStopVTOLProduction = true; }
      lStopTankProduction = false; 
      if ( nWorkingCybFac >= 3) {lStopCybProduction  = true; }
      if ( nWorkingLab    >= 4) {lStopResearch       = true; }
      lStopBuildDef            = false;
      lStopBuildDefDerricks    = false;
      lStopBuildRepFacility    = false;
      lStopBuildDefGateway     = false;
  } 
  if ( nProdSelect == 6 ){
      if ( nWorkingVTOLFac>= 0) {lStopVTOLProduction = true; }
      lStopTankProduction = false; 
      lStopCybProduction  = false;
      if ( nWorkingLab    >= 2) {lStopResearch       = true; }
      lStopBuildDef            = true;
      lStopBuildDefDerricks    = true;
      lStopBuildRepFacility    = true;
      lStopBuildDefGateway     = true;
  } 

  if ( nProdSelect == 7){
    lStopTankProduction      = true;  
    lStopCybProduction       = true;
    lStopVTOLProduction      = true;
    lStopResearch            = true;
    lStopBuildDef            = true;
    lStopBuildDefGateway     = true;
    lStopBuildDefDerricks    = true;
    lStopBuildRepFacility    = true;
  }

  //activate VTOL production if min droids has been reached
  if ( vtolGr.members  < MIN_VTOLS and nVTOLFactories > 0 and ( (nTotCyborgs+nTotTanks) > MIN_TOT_UNITS) ){
    lStopVTOLProduction = false;
    lStopTankProduction = true;
    lStopCybProduction  = true;
  }

}


//-----------------------------------------------------------------------------
function STRUCTURE getVTOLstructTarget()
{
  local int _aa, _player, _bestAA, _ii, _dist, _bestDist, _tempHealth; 
  local STRUCTURE _struct, _structTarget;
  
  _structTarget = NULLOBJECT;    
  _aa=0;
  _bestAA=999;
  _bestDist=999999;
  _ii = 0;

  while ( _ii < numStructs){
    
    initEnumStruct(false,structs[_ii],targetPlayerVTOL,targetPlayerVTOL);
  	_struct = enumStruct();
  	while(_struct != NULLOBJECT)
  	{

      _aa = getAA_OnTheWay(baseX, baseY, _struct.x, _struct.y, AA_THREAT_RANGE);
      _dist = distBetweenTwoPoints(baseX,baseY,_struct.x,_struct.y);

      if ( _aa*4 < vtolGr.members ){ 
        if ( _aa < _bestAA  ){ 
          _bestAA = _aa; _structTarget = _struct; _tempHealth = _struct.health; _dist = _bestDist; 
        } else {
          //if same AA attack most damaged one
          if ( _aa == _bestAA  ){
            if ( _struct.health < _tempHealth ){ 
              _tempHealth = _struct.health; _structTarget = _struct; _dist = _bestDist; 
            } else {
              //if same AA and same damage attack nearest one !!!
              if ( _struct.health == _tempHealth ){ 
                if ( _dist < _bestDist ){ _tempHealth = _struct.health; _structTarget = _struct; _dist = _bestDist; }
              }
            }
          } 
          
        }
      }
      _struct = enumStruct();
    }
    
    _ii++;
  }
  //if (_structTarget != NULLOBJECT ){
    //dbg("getVTOLstructTarget: strct ("& _structTarget.id &") health("& _structTarget.health  &") AA("& _bestAA &") _bestDist("& _bestDist/TILE &")",player);
  //}
  return _structTarget;
}

//-----------------------------------------------------------------------------
function int numEnemyAAInRange(int _x, int _y, int _range)
{
	local int _enemy,_numAA;

	_numAA = 0;
	_enemy = 0;
	while(_enemy < MAX_PLAYERS)
	{
		if(!friendlyPlayer(_enemy))
		{
      if ( AIstrength > 3){
			 _numAA = _numAA + numAAinRange(_enemy, _enemy, _x, _y, _range);
			} else {
			 _numAA = _numAA + numAAinRange(_enemy, player, _x, _y, _range);
      }
		}
		_enemy++;
	}

	return _numAA;
}
//-----------------------------------------------------------------------------
function void updatePlayersStats()
{
  local int _pl2,_pl3,_player,_dist,_bestDist;


  nPlayersInGame   = 0;
  nEnemyPlayers    = 0;
  nHumanPlayers    = 0;
  nLastEnemyPlayer = -1;
  _pl2           = 0;
  _pl3           = 0;
  bLastMember    = true;
  _bestDist = 9999999;
  
  while ( _pl2 < MAX_PLAYERS ){ 
    
    if ( isPlayerStillLive(_pl2)){  
      if ( isHumanPlayer(_pl2) ){ nHumanPlayers++; }
      
      if ( !isScavenger(_pl2) ){
        nPlayersInGame++;
      } 
      
      if ( friendlyPlayer(_pl2) and _pl2 != player ){
        nTeamMates++;
      }
       
      if ( !friendlyPlayer(_pl2) ){ 
        
        _dist = distBetweenTwoPoints(baseX,baseY,aPl[_pl2][X_COORD],aPl[_pl2][Y_COORD]);
        if ( _dist < _bestDist ){
          nNearestEnemy = _pl2;
          _bestDist = _dist;
        }
        
        //printDebug1("updatePlayersStats; enemy player found _pl2("& getPlayerName(_pl2) &" #("& _pl2 &") ");
        nEnemyPlayers++; 
        nLastEnemyPlayer = _pl2; 
      } else {
        //bLastMember
        if ( player < _pl2 and player != _pl2){
          bLastMember = false;
        }
      }
      aPlayers[PLAYER_NUMBER][_pl3] = _pl2;
      _pl3++;
    
    }
    
    _pl2++;
  }
  
  if ( _bestDist < 45*TILE ){
    bEnemyIsNear = true;
  } else {
    bEnemyIsNear = false;
  }
  
  if ( nEnemyPlayers == 1 and isHumanPlayer(nLastEnemyPlayer) ) {
    bIsEnemyHumanOnly = true;
  } else {
    bIsEnemyHumanOnly = false;
  }
  //reset teams, just in case alliances changed.
  _player   = 0;
  while (_player < MAX_PLAYERS){
    aPlayers[TEAM_NUMBER][_player] = -1;
    _player++;
  }
  
  _player   = 0;
  _pl2  = 0;
  nTeam   = 0;
  while (_player < MAX_PLAYERS){
    if ( aPlayers[TEAM_NUMBER][_player] < 0 and isPlayerStillLive(_player) ){

      //assign a team to the player
      nTeam++;
      aPlayers[TEAM_NUMBER][_player] = nTeam;
      
      //loop
      _pl2 = 0;
      while (_pl2 < MAX_PLAYERS){
        if ( allianceExistsBetween(_player,_pl2) and _player != _pl2 and isPlayerStillLive(_pl2) ){
         if ( aPlayers[TEAM_NUMBER][_pl2] < 0  ){
            aPlayers[TEAM_NUMBER][_pl2] = aPlayers[TEAM_NUMBER][_player];
          } 
         }
        _pl2++;
      }
    }
    _player++;
  }

  _player=0;
  while( _player < MAX_PLAYERS ){
    if ( isPlayerStillLive(_player) ){
      aStat[OC_DERRICKS][_player]   = getNumDerricks(_player);
      aStat[OC_RESLABS][_player]    = numStructsByType( resLab, _player, false );
      aStat[OC_CYBORGS][_player]    = getDroidsInfo(_player, OC_CYBORGS);
      aStat[OC_TANKS][_player]      = getDroidsInfo(_player, OC_TANKS);
      aStat[OC_VTOLS][_player]      = getDroidsInfo(_player, OC_VTOLS);
      aStat[OC_CYB_POWER][_player]  = getDroidsInfo(_player, OC_CYB_POWER);
      aStat[OC_TK_POWER][_player]   = getDroidsInfo(_player, OC_TK_POWER);
      aStat[OC_VTOL_POWER][_player] = getDroidsInfo(_player, OC_VTOL_POWER);
      aStat[OC_CYB_HP][_player]     = getDroidsInfo(_player, OC_CYB_HP);
      aStat[OC_TK_HP][_player]      = getDroidsInfo(_player, OC_TK_HP);
      aStat[OC_VTOL_HP][_player]    = getDroidsInfo(_player, OC_VTOL_HP);
    }
    _player++;
  }

}

//-----------------------------------------------------------------------------
//not used
function int getTeamNumber(int _player)
{
  return aPlayers[TEAM_NUMBER][_player];
}
//-----------------------------------------------------------------------------
function int getDroidsInfo(int _player, int _choice)
{
	local DROID _droid;
	local GROUP _grp[8];
  local int _cyb, _tk, _vtol, _powCYB, _powTK, _powVTOL, _hpCYB, _hpTK, _hpVTOL;
	
	_tk=0; _cyb=0; _vtol=0; _powCYB=0; _powTK=0; _powVTOL=0;
	_hpCYB=0; _hpTK=0; _hpVTOL=0;
  
  
  InitEnumDroids(_player,_player);
  _droid = EnumDroid();
  while(_droid != NULLOBJECT)
  {
	  if( !isVtol(_droid) ){
    	if(_droid.droidType == DROID_WEAPON and _droid.propulsion != cyborgPropulsion ){
        _powTK = _powTK + calcDroidPower(_droid);
        _hpTK = _hpTK + _droid.hitPoints;
        _tk++;
      }
    	if(_droid.propulsion == cyborgPropulsion and _droid.droidType != DROID_CYBORG_CONSTRUCT ){
        _powCYB = _powCYB + calcDroidPower(_droid);
        _hpCYB = _hpCYB + _droid.hitPoints;
        _cyb++;
      }
    } else {
      _powVTOL = _powVTOL + calcDroidPower(_droid);
      _hpVTOL = _hpVTOL + _droid.hitPoints;
      _vtol++;
    }
    //power cost
    _droid = EnumDroid();
  }

  if ( _choice == OC_CYBORGS )    { return _cyb; }
  if ( _choice == OC_TANKS )      { return _tk; }
  if ( _choice == OC_VTOLS )      { return _vtol; }
  if ( _choice == OC_CYB_POWER )  { return _powCYB; }
  if ( _choice == OC_TK_POWER )   { return _powTK; }
  if ( _choice == OC_VTOL_POWER ) { return _powVTOL; }
  if ( _choice == OC_CYB_HP )     { return _hpCYB; }
  if ( _choice == OC_TK_HP )      { return _hpTK; }
  if ( _choice == OC_VTOL_HP )    { return _hpVTOL; }

  return -1;
}

//-----------------------------------------
function void deactivateHelp()
{
  
  nAllyBeingHelped = -1;
	tHelpAction      = -1;
	nHelpX           = -1;
	nHelpY           = -1;
	objTargetHelpTeam = NULLOBJECT;
  if ( helpGroup.members > 0){
  	if ( AIPersonality == AI_CYBORG ){
      groupAddGroup(cyborgDefGroup, helpGroup);
      orderGroup(cyborgDefGroup, DORDER_RTB);
    } else {
      groupAddGroup(tankDefGroup, helpGroup);
      orderGroup(tankDefGroup, DORDER_RTB);
    }
  }
  setEventTrigger(manageHelpTeam,inactive);
}
//-----------------------------------------------------------------------------
function bool bHelpingAnyAlly()
{
  if ( nAllyBeingHelped == -1 ){
    return false;
  }
  return true;
}
//-----------------------------------------------------------------------------
function bool canHelpAlly(int _sender)
{
  local int _tank, _cyb, _dist;

  
  _dist = 128;
  
  //check Distance
  if ( beaconX[_sender] >= 0 and beaconY[_sender] >= 0 ){
    _dist = distBetweenTwoPoints(baseX,baseY,beaconX[_sender],beaconY[_sender]);
    if ( mapSize() == MAP_BIG ){
      if ( _dist > MAX_HELP_DISTANCE+30  ) {
    	  //printDebug1("canHelpAlly; beacon is too far away ("& _dist/TILE &") _sender("& _sender &") mapSize()("& mapSize() &") ");
        return false;
      }
    } else {
      if ( _dist > MAX_HELP_DISTANCE  ) {
    	  //printDebug1("canHelpAlly; beacon is too far away ("& _dist/TILE &") _sender("& _sender &") mapSize()("& mapSize() &") ");
        return false;
      }
    }
  }
  
  _tank = tankDefGroup.members - minDefDroids[nAI_Pers][MINDEF_TANKS];
  _cyb  = cyborgDefGroup.members - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
  
  if ( alertLevel == RED_ALERT ){
  	printDebug1("canHelpAlly; red alert; dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > ("& MIN_HELPING_UNITS &") ?, alert ("& alertIsOn &") alertLevel ("& alertLevel &") _sender("& _sender &") ");
    return false;
  }
  if ( _tank +_cyb < MIN_HELPING_UNITS ){
  	printDebug1("canHelpAlly; not enoug units; dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > ("& MIN_HELPING_UNITS &") ?, alert ("& alertIsOn &") alertLevel ("& alertLevel &") _sender("& _sender &") ");
    return false;
  }
  
  //printDebug1("canHelpAlly; __OK__ dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > ("& MIN_HELPING_UNITS &") ?, alert ("& alertIsOn &") alertLevel ("& alertLevel &") _sender("& _sender &") ");
  return true;
}

//-----------------------------------------------------------------------------
function void helpAlly(int _ally){

  local int _tank, _cyb;

  _tank = tankDefGroup.members - minDefDroids[nAI_Pers][MINDEF_TANKS];
  _cyb  = cyborgDefGroup.members - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
  
	printDebug1("helpAlly; has tk("& tankDefGroup.members &"/"& _tank &") cyb("& cyborgDefGroup.members &"/"& _cyb &") availabe for help, alert ("& alertIsOn &") alertLevel ("& alertLevel &")" );
  if ( _tank > MAX_HELPING_UNITS ){ _tank = MAX_HELPING_UNITS; }
  if ( _cyb  > MAX_HELPING_UNITS ){ _cyb  = MAX_HELPING_UNITS; }

  moveUnitsBetweenGRPs(helpGroup, tankDefGroup, _tank, true);
  moveUnitsBetweenGRPs(helpGroup, cyborgDefGroup, _cyb, false);

  tLastHelp        = gameTime;
	nHelpX           = beaconX[_ally];
	nHelpY           = beaconY[_ally];
  nAllyBeingHelped =  _ally;

	//helping droids never repair themselves
  initIterateGroup(helpGroup);		
	droid = iterateGroup(helpGroup);
	while( droid != NULLOBJECT)
  { 
    setDroidSecondary(droid,DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
	  droid = iterateGroup(helpGroup);
  }
  
  msg("Sending "& helpGroup.members &" units to beacon point coord: "& (nHelpX/TILE) &"-"& (nHelpY/TILE), player, _ally);
  //printDebug1("helpAlly; Sending "& helpGroup.members &" units to beacon point coord: "& (nHelpX/TILE) &"-"& (nHelpY/TILE) &" helping ("& getPlayerName(_ally) &")" );
  
  orderGroupMoveCMD(helpGroup, nHelpX, nHelpY);
  setEventTrigger(manageHelpTeam,manageHelpTeamTr);
  
}

//======================================================================
//
//             DyDo Communcation Functions & Events
//
//======================================================================
event consoleEv(consoleTr)  //(CALL_CONSOLE, ref sender, ref message);
{
  //console(getPlayerName(player) & " console sender ("& sender &") message ("& message &")");
  local string _strAIDesc,_sResPath;
  
  if ( !isPlayerStillLive(player) ){ exit; }
  
  if( message == "are you dydo?" or message == "are you DyDo?" or message == "who are you?" )
	{
    //boolResult=true;
    if ( AIPersonality == AI_STANDARD){ _strAIDesc = "Standard AI"; }
    if ( AIPersonality == AI_VTOL)    { _strAIDesc = "VTOL AI"; }
    if ( AIPersonality == AI_TURTLE)  { _strAIDesc = "Turtle AI"; }
    if ( AIPersonality == AI_CYBORG)  { _strAIDesc = "Cyborg AI"; }
  
  
    if ( nResTmplPath == 0 ) { _sResPath = "All Weapons"; }
    if ( nResTmplPath == 1 ) { _sResPath = "Flamers and Rockets"; }
    if ( nResTmplPath == 2 ) { _sResPath = "Gunners and Cannons"; }

    if ( sender == player ){                                                         
      if ( bRunning ){                                                         
		    msg( DYDOBP_RELEASE &", player "& player &", " & _strAIDesc & " ["& AIstrength &"] '"& _sResPath &"' ",player, sender);
		  }
    } else {
    
      if(allianceExistsBetween(_sender,player) ){
        if (sender != player){
  		    msg( DYDOBP_RELEASE &", player "& player &", " & _strAIDesc & " ["& AIstrength &"] '"& _sResPath &"' (ally)",player, sender);
        }		
      } else {
  		  msg( DYDOBP_RELEASE &", player "& player &", " & _strAIDesc & " ["& AIstrength &"] '"& _sResPath &"' (enemy)",player, sender);
      }
      
    }
    
	}


  if(allianceExistsBetween(_sender,player) and isHumanPlayer(_sender) ){
    if ( message == "set rp0" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_0;
      SetDyDoPath();
      //printDebug1("msg from TeamLeader: PATH == "& nResTmplPath &" (all technologies), AIPersonality("& AIPersonality &") !");    
      console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (all technologies), AIPersonality("& AIPersonality &") !");    
    }
    if ( message == "set rp1" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_1;
      SetDyDoPath();
      //printDebug1("msg from TeamLeader: PATH == "& nResTmplPath &" (Flamers and Rockets), AIPersonality("& AIPersonality &") !");    
      console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (Flamers and Rockets), AIPersonality("& AIPersonality &") !");    
    }
    if ( message == "set rp2" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_2;
      SetDyDoPath();
      //printDebug1("msg from TeamLeader: PATH == "& nResTmplPath &" (Gunners and Cannons), AIPersonality("& AIPersonality &") !");    
      console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (Gunners and Cannons), AIPersonality("& AIPersonality &") !");    
    }
  }

  if ( message == "/set pow500" ){
    addPower(500,player);  
    console("Player("& getPlayerName(player) &")("& player &"): got +500 power !");    
  }
  if ( message == "/set pow1000" ){
    addPower(1000,player);  
    console("Player("& getPlayerName(player) &")("& player &"): got +1000 power !");    
  }
  if ( message == "/set pow5000" ){
    addPower(5000,player);  
    console("Player("& getPlayerName(player) &")("& player &"): got +5000 power !");    
  }

  if ( message == "/set rp0" ){
    lPathSet = true;
    nResTmplPath = RESTMPL_0;
    SetDyDoPath();
    console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (all technologies), AIPersonality("& AIPersonality &") !");    
  }
  if ( message == "/set rp1" ){
    lPathSet = true;
    nResTmplPath = RESTMPL_1;
    SetDyDoPath();
    console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (Flamers and Rockets), AIPersonality("& AIPersonality &") !");    
  }
  if ( message == "/set rp2" ){
    lPathSet = true;
    nResTmplPath = RESTMPL_2;
    SetDyDoPath();
    console("Player("& getPlayerName(player) &")("& player &"): Research path set to # "& nResTmplPath &" (Gunners and Cannons), AIPersonality("& AIPersonality &") !");    
  }

  if ( message == "/dbg0 on" and player == 0 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg1 on" and player == 1 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg2 on" and player == 2 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg3 on" and player == 3 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }
  
  if ( message == "/dbg4 on" and player == 4 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg5 on" and player == 5 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg6 on" and player == 6 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg7 on" and player == 7 ) {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }

  if ( message == "/dbg on") {
		msg("Debug turned on", player, sender);
    dbgMsgOn(player, true);
  }
  
  if (message == "/dbg off" )	{
		msg("Debug turned off", player, sender);
    dbgMsgOn(player, false);
  }

  if (message == "/stats" )	{
    count = getTargetEnemy(false);
  }

  if (message == "/set level 1" )	{
    AIstrength = 1;
    console(getPlayerName(player) & " strenght has been set to "& AIstrength );
  }
  if (message == "/set level 2" )	{
    AIstrength = 2;
    console(getPlayerName(player) & " strenght has been set to "& AIstrength );
  }
  if (message == "/set level 3" )	{
    AIstrength = 3;
    console(getPlayerName(player) & " strenght has been set to "& AIstrength );
  }
  if (message == "/set level 4" )	{
    AIstrength = 4;
    console(getPlayerName(player) & " strenght has been set to "& AIstrength );
  }
  if (message == "/set level 5" )	{
    AIstrength = 5;
    console(getPlayerName(player) & " strenght has been set to "& AIstrength );
  }

  
  if ( gameTime < 2*TIME_MINUTE ){
    if(message == "/set dydo gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,player);	
      console(getPlayerName(player) & " is now DyDo Standard AI"); 
    }
    if(message == "/set dydo gen2" ) { 
      SetDyDoPersonality(AI_VTOL,player);	
      console(getPlayerName(player) & " is now DyDo VTOL AI"); 
    }
    if(message == "/set dydo gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,player);	
      console(getPlayerName(player) & " is now DyDo Turtle AI"); 
    }
    if(message == "/set dydo gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,player);	
      SetDyDoPath();
      console(getPlayerName(player) & " is now DyDo Cyborg AI"); 
    }

    if(message == "/set dydo random" ) { 
      SetDyDoPersonality(0,player);
      if (AIPersonality == AI_CYBORG){
        SetDyDoPath();
      }	
      console(getPlayerName(player) & " is now DyDo random AI"); 
    }

    if(message == "/set player0 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,0);	
      if ( player==3 ){console( getPlayerName(0) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player1 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,1);	
      if ( player==3 ){console( getPlayerName(1) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player2 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,2);	
      if ( player==3 ){console( getPlayerName(2) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player3 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,3);	
      if ( player==3 ){console( getPlayerName(3) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player4 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,4);	
      if ( player==4 ){console( getPlayerName(4) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player5 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,5);	
      if ( player==5 ){console( getPlayerName(5) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player6 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,6);	
      if ( player==6 ){console( getPlayerName(6) & " is now DyDo Standard AI"); } 
    }
    if(message == "/set player7 gen1" ) { 
      SetDyDoPersonality(AI_STANDARD,7);	
      if ( player==7 ){console( getPlayerName(7) & " is now DyDo Standard AI"); } 
    }

    if(message == "/set player0 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,0);	
      if ( player==0 ){console( getPlayerName(0) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player1 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,1);	
      if ( player==1 ){console( getPlayerName(1) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player2 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,2);	
      if ( player==2 ){console( getPlayerName(2) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player3 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,3);	
      if ( player==3 ){console( getPlayerName(3) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player4 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,4);	
      if ( player==4 ){console( getPlayerName(4) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player5 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,5);	
      if ( player==5 ){console( getPlayerName(5) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player6 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,6);	
      if ( player==6 ){console( getPlayerName(6) & " is now DyDo VTOL AI"); } 
    }
    if(message == "/set player7 gen2" ) { 
      SetDyDoPersonality(AI_VTOL,7);	
      if ( player==7 ){console( getPlayerName(7) & " is now DyDo VTOL AI"); } 
    }

    if(message == "/set player0 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,0);	
      if ( player==0 ){console( getPlayerName(0) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player1 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,1);	
      if ( player==1 ){console( getPlayerName(1) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player2 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,2);	
      if ( player==2 ){console( getPlayerName(2) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player3 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,3);	
      if ( player==3 ){console( getPlayerName(3) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player4 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,4);	
      if ( player==4 ){console( getPlayerName(4) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player5 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,5);	
      if ( player==5 ){console( getPlayerName(5) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player6 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,6);	
      if ( player==6 ){console( getPlayerName(6) & " is now DyDo Turtle AI"); } 
    }
    if(message == "/set player7 gen3" ) { 
      SetDyDoPersonality(AI_TURTLE,7);	
      if ( player==7 ){console( getPlayerName(7) & " is now DyDo Turtle AI"); } 
    }

    if(message == "/set player0 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,0);	
      SetDyDoPath();
      if ( player==0 ){console( getPlayerName(0) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player1 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,1);	
      SetDyDoPath();
      if ( player==1 ){console( getPlayerName(1) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player2 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,2);	
      SetDyDoPath();
      if ( player==2 ){console( getPlayerName(2) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player3 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,3);	
      SetDyDoPath();
      if ( player==3 ){console( getPlayerName(3) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player4 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,4);	
      SetDyDoPath();
      if ( player==4 ){console( getPlayerName(4) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player5 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,5);	
      SetDyDoPath();
      if ( player==5 ){console( getPlayerName(5) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player6 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,6);	
      SetDyDoPath();
      if ( player==6 ){console( getPlayerName(6) & " is now DyDo Cyborg AI"); } 
    }
    if(message == "/set player7 gen4" ) { 
      SetDyDoPersonality(AI_CYBORG,7);	
      SetDyDoPath();
      if ( player==7 ){console( getPlayerName(7) & " is now DyDo Cyborg AI"); } 
    }
	}
	
  if(message == "/ag on" && (sender == player))
	{
		if(myResponsibility(player))
		{
			if(!bRunning)		//make sure current machine is responsible for this AI and it's not already active
			{
				console(getPlayerName(player) & " is now active");
        bRunning = true;
				activateAI();
			}
		}
	}

  if(message == "/ag off" && (sender == player))
	{
		if(myResponsibility(player))
		{
			if(bRunning)
			{
				console(getPlayerName(player) & " AI has been deactivated");
        bRunning = false;
				shutDownThisAI();
			}
		}
	}

}
//========================================================================
/* Deal with beacons */
//(CALL_BEACON, player, ref sender, ref x, ref y, ref message);
event beaconEv(beaconTr)
{
	local	int			_players;
	local	string	_processedString;

  updateBeacons();
  
	beaconX[sender] = x;
	beaconY[sender] = y;
	tBeacon[sender] = gameTime / 10;

	processCommand(message, sender, TRUE);

}

//-----------------------------------------------------------------------------
function bool haveAnyBeacon()
{
	local int _c;
  _c = 0;
  while ( _c < MAX_PLAYERS ){
    if((tBeacon[_c] > 0) and (not beaconTimeout(_c)))
		{
			return true;	//have beacon for this player
		}
		_c++;
	}

	return false;
}
//-----------------------------------------------------------------------------
function bool haveBeacon(int _player)
{
		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
		{
			return true;	//have beacon for this player
		}

		return false;
}
//-----------------------------------------------------------------------------
function bool beaconTimeout(int _player)
{
		if((tBeacon[_player] > 0) and (( tBeacon[_player] + tBeaconTimeout) < GAME_TIME_IN_SECS))	//not too long ago
		{
			return true;	//this beacon is still 'fresh'
		}

		return false;
}
//-----------------------------------------------------------------------------
function void updateBeacons()
{
	local int _c;
  _c = 0;
	while(_c < MAX_PLAYERS)
	{
		if(beaconTimeout(_c))	//last beacon timed out
		{
			tBeacon[_c] = -1;
			beaconX[_c] = -1;
			beaconY[_c] = -1;
		}
		_c = _c + 1;
	}
}
//-----------------------------------------------------------------------------
/* Deal with a chat message */
//(CALL_AI_MSG, player, ref sender, ref message);
event multiMsgEv(multiMsgTr)
{
	/*
  if( !aiResponsibleForPlayer(player) )
	{
		setEventTrigger(multiMsgEv, inactive);
	}	else	{
	*/
  	if( sender == player or !allianceExistsBetween(sender,player) ){	exit;	}
  	processCommand(message, sender, false);
	//}
}
//-----------------------------------------------------------------------------
function void processCommand(string _message, int _sender, bool _bBlipMessage)
{

	//go,/stop,/status
  local	int _numMsgs, _curMsg, _tk, _cyb, _player;
	local	string	_msg, _processedString;
  local int _tDG, _bg, _hg, _cAt, _tg, _bdg, _cG, _ccG, _rg, _HelpG,_nBigHelpDroids;
	local string _strTeams, _sWallDef, _sDef, _sRes, _sRes2, _str0, _str1, _str2, _str3, _str4;
                             
	/* Extract semantic information */
	_curMsg = 0;
	_numMsgs = processChatMsg(_message); 

  //boolResult=false;
  //dbg("processCommand A: player("& getPlayerName(player) &") num messages("& _numMsgs &") _message(" & _message & ") from " & _sender, player);
  

  //if (_message == "/debug_on" or _message == "/debug_on_player0" and player == 0 or   _message == "/debug_on_player1" and player == 1 or   _message == "/debug_on_player2" and player == 2 or   _message == "/debug_on_player3" and player == 3 or   _message == "/debug_on_player4" and player == 4 or _message == "/debug_on_player5" and player == 5 or _message == "/debug_on_player6" and player == 6 or _message == "/debug_on_player7" and player == 7  )	

 	if(!allianceExistsBetween(_sender,player) ){ return; }

  if ( !lPathSet ){//necessary due to a wz bug which send messages multiple times...
    if ( _message == "rp0" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_0;
      SetDyDoPath();
      console("Player("& getPlayerName(player) &")("& player &") TL ("& IsTeamLeader() &"), Research path set to # "& nResTmplPath &", research all techs !");    
    }
    if ( _message == "rp1" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_1;
      SetDyDoPath();
      console("Player("& getPlayerName(player) &")("& player &") TL ("& IsTeamLeader() &"), Research path set to # "& nResTmplPath &" research flamers and rockets !");    
    }
    if ( _message == "rp2" ){
      lPathSet = true;
      nResTmplPath = RESTMPL_2;
      SetDyDoPath();
      console("Player("& getPlayerName(player) &")("& player &") TL ("& IsTeamLeader() &"), Research path set to # "& nResTmplPath &" research Gunners and cannons !");    
    }
  }


  if ( _message == "needbighelp" ){
    //dbg("BIGHELP; request received from ("& _sender &") canhelp("& canHelpAlly(_sender)  &") nProd2("& nProd2 &")<1",player);
    if ( nBigHelp_ok < 2 ){
    
    _nBigHelpDroids = canBigHelpAlly(_sender);
    if ( _nBigHelpDroids > -1 ){
      nBigHelp_ok++;
      //int takeOverDroidsInAreaExp(int fromPlayer, int toPlayer, int x1, int y1, int x2, int y2, int level, int max)
      //count = takeOverDroidsInAreaExp(player, _sender, 0, 0, mapWidth*TILE,mapHeight*TILE, 9999999, MIN_HELPING_UNITS );
      
      _tk = tankDefGroup.members - minDefDroids[nAI_Pers][MINDEF_TANKS];
      _cyb = cyborgDefGroup.members - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
 
      
      count = 0; count2 = 0; 
      while ( count < _nBigHelpDroids and count2 < _tk ){
        droid  = getADroid(tankDefGroup);
        if ( droid != NULLOBJECT ){
          count2++;
          droid2 = takeOverSingleDroid(droid, _sender);
        }
        count++;
      }
      if ( count2 < _nBigHelpDroids ){
        count = 0; count3 = 0;
        while ( count < _nBigHelpDroids and count3 < _cyb and count2 < _nBigHelpDroids )
        {
          droid  = getADroid(cyborgDefGroup);
          if ( droid != NULLOBJECT ){
            count3++;
            count2++;
            droid2 = takeOverSingleDroid(droid, _sender);
          }
          count++;
        }
      }
      
      //dbg("BIGHELP; player has given ("& count2 &")("& count3 &")/("& count &") units to player ("& _sender &") ",player);
      msg("player has given ("& count2 &")/("& _nBigHelpDroids &") units",player,_sender);
      //printDebug1("BIGHELP; player has given ("& count2 &")("& count3 &")/("& _nBigHelpDroids &") units to player ("& _sender &") ");
    
    } else {
      
      //check if already helping this player in which case move my units to him
      if ( nAllyBeingHelped == _sender and helpGroup.members > 0 ){
        
        count = 0;
        while ( count < helpGroup.members ){
          droid  = getADroid(helpGroup);
          if ( droid != NULLOBJECT ){
            droid2 = takeOverSingleDroid(droid, _sender);
          }
          count++;
        }
        msg("I have given you ("& count &") units",player,_sender);
        //printDebug1("BIGHELP;has given ("& getPlayerName(_sender) &") '"& count &"' units");
        
      } else {

        msg("Sorry, I am in trouble or not have enough units",player,_sender);
        //printDebug1("BIGHELP; is in trouble or not have enough units to send");
      }
    }
    }
  
  }
  


  while(_curMsg < _numMsgs )
	{
		
    
    if(chatCmdIsPlayerAddressed(_curMsg, player))//not AIV func
		{
      
      if ( _message == "stop" or _message == "Stop" ){
        _msg = "xxx";
      } else {
        _msg = getChatCmdDescription(_curMsg);
      }

 			//dbg("Player ("& player &") addressed with : ("& _msg &")", player);
      if( _msg == "help" or _msg == "help me" or _msg == "go!" or _msg == "go" ) //go
    	{
        
        boolResult=true;
    		if(not haveBeacon(_sender))
    		{
    			msg("Drop a beacon please (Alt+H), I need to know where to send the units", player, _sender);
          return;
    		} else {
    			
          //dbg("dbg: Got a beacon on: "& (beaconX[_sender]/TILE) &"-"& (beaconY[_sender]/TILE), player);
    			if ( nAllyBeingHelped == -1 ){
    				if ( canHelpAlly(_sender) ){//nAllyBeingHelped
    				 helpAlly(_sender);
            } else{
    				 msg("I am sorry. I have not enough units to send or I am in trouble", player, _sender);
            }
          } else {
      			if ( nAllyBeingHelped == _sender ){
              msg(getPlayerName(nAllyBeingHelped) & ", I am coming!" , player, _sender);
            } else {
              msg("I am sorry but I am already helping player '"& getPlayerName(nAllyBeingHelped) &"' ", player, _sender);
            }
          }
        }

      } else if (_msg == "status?" or _msg == "Status?" or _msg == "status") {

        boolResult=true;
       //dbg("Got a status request :" & _msg, _sender );
    	 notifyStatus(1, _sender);
    	
      } else if ( _msg == "xxx" ) {

        boolResult=true;
        if ( !bHelpingAnyAlly() ){
    			  msg("There is nothing to stop!", player, _sender);
        } else {
    	    //dbg("dbg: i'm addressed with stop", player);
          if ( nAllyBeingHelped == _sender ){
            deactivateHelp();
    			  msg("Action stopped!", player, _sender);
    			}
        }
      
      } else if (_msg == "power?" or _msg == "power")	{

       boolResult=true;
		   msg("I have ("& playerPower(player) &") power available", player, _sender);
    
      } 
          
    } //if(chatCmdIsPlayerAddressed(_curMsg, player))/
   _curMsg++;
  }
  
}
//-----------------------------------------------------------------------------
function void notifyAll(STRING _cstr)
{
	local int _player;

	_player = 0;
	while(_player < MAX_PLAYERS )
	{
		if ( player != _player ){
      msg(_cstr, player, _player);
    }
		_player++;		
	}
  
}
//-----------------------------------------------------------------------------
function void notifyStatus(int _choice, int _player)
{

  //nTotTanks 	    = tankGroup.members+tankDefGroup.members+toBeRepairedTankGroup.members+helpGroup.members;
  //nTotCyborgs     = cyborgDefGroup.members + cyborgAttGroup.members + toBeRepairedCyborgGroup.members;
  local int _f,_c,_r,_v,_h,_l,_cc;
  
  _f = nFactories;
	_r = nResLabs;
	_c = nCybFact;
	_v = nVTOLFactories;
	_h = numStructsByType(playerHQ, player, false);
	_l = numStructsByType(lassat, player, false);
	_cc = numStructsByType(derrick, player, false);

  msg("Player #("& player &") colour("& getPlayerName(player) &") Game Time("& gameTime/10/60 &" min) Map Size("& mapWidth &"-"& mapHeight &") Defend Range("& nDefendRange/TILE &") Under attack("& alertIsOn &")", player, _player);
  msg("Power:"& playerPower(player) &" Derricks:"& _cc &"  Min base structures buit:"& lMinBaseStructBuilt &" alert is on("& alertIsOn &") alert level("& alertLevel &")", player, _player);
  msg("Droids: Tot("& nTotTanks+nTotCyborgs &") Defending("& tankDefGroup.members+cyborgDefGroup.members &") Attacking("& tankGroup.members+cyborgAttGroup.members &") Helping("& helpGroup.members &") To be Repaired("& toBeRepairedCyborgGroup.members+toBeRepairedTankGroup.members &") ", player, _player);
  msg("Structs: Factories("& _f &") ResLabs("& _r &") CybFactories("& _c &") VTOLFactories("& _v &") Lassat("& _l &") HQ("& _h &") ", player, _player);
  msg("Team1 attack active("& bTankAttIsOn &") Team 1 target player ("& targetPlayerTank &") Team 2 attack active("& bCybAttIsOn &") Team 2 target player("& targetPlayerCyb &") ", player, _player);
  msg("Have a beacon("& haveAnyBeacon() &") Player Helped("& nAllyBeingHelped &") Helping Droids("& helpGroup.members &")", player, _player);
  
}

//-----------------------------------------------------------------------------
function bool isPlayerStillLive(int _player)
{
  if ( anyDroidsLeft(_player) or anyFactoriesLeft(_player) ){
    return true;
  } 
  return false;
}
//-----------------------------------------------------------------------------
function void checkIfDroidIsStuck(GROUP _group)
{
  
  //displayMsg("checkIfDroidIsStuck: time("& gameTime &")");
  local int _x,_y,_dist,_rnd;
  //Search for stucked droids
	initIterateGroup(_group);
	droid = iterateGroup(_group);
	while(droid != NULLOBJECT)
	{
		if(!droidOrderIdle(droid)){
		
		  if ( !hasCoordStored(droid) ){
        //displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") store coord in x("& droid.x/TILE &") y("& droid.y/TILE &") buildx("& droid.orderx/TILE &") buildx("& droid.ordery/TILE &") time("& gameTime &")");
		    storeDroidCoord(droid);
      } else {
        
        if ( coordChanged(droid) ){
          _dist = distBetweenTwoPoints(droid.x,droid.y,droid.orderx,droid.ordery);
          //displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") MOVES dist("& _dist/TILE &") pos("& droid.x/TILE &"-"& droid.y/TILE &") build("& droid.orderx/TILE &"-"& droid.ordery/TILE &") time("& gameTime &")");
		      updateDroidCoord(droid);
        
        } else {
          _dist = distBetweenTwoPoints(droid.x,droid.y,droid.orderx,droid.ordery);
          if ( _dist < 3*TILE ){
            //displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") BUILDS dist("& _dist/TILE &")  pos("& droid.x/TILE &"-"& droid.y/TILE &") buildx("& droid.orderx/TILE &"-"& droid.ordery/TILE &") time("& gameTime &")");
            cleanDroidPos(droid.id);//this is a necessary hack to avoid wrong stuck
          } else {
            if (  incrementDroidCounter(droid.id) ){
              printDebug1("checkIfDroidIsStuck: droid ("& droid.id &") IS *****STUCK******* dist("& _dist/TILE &") pos("& droid.x/TILE &"-"& droid.y/TILE &") buildx("& droid.orderx/TILE &"-"& droid.ordery/TILE &") time("& gameTime &")");
              orderDroid(droid, DORDER_RUN);
              /*
              _rnd = random(4);
              if ( _rnd == 0 ){ _x = droid.x + 4*TILE; _y=droid.y + 4*TILE; }
              if ( _rnd == 1 ){ _x = droid.x - 4*TILE; _y=droid.y + 4*TILE; }
              if ( _rnd == 2 ){ _x = droid.x + 4*TILE; _y=droid.y - 4*TILE; }
              if ( _rnd == 3 ){ _x = droid.x - 4*TILE; _y=droid.y - 4*TILE; }
              if ( _x < 0 ) { _x = 2*TILE; }
              if ( _y < 0 ) { _y = 2*TILE; }
              if ( _x > mapWidth*TILE ) { _x = mapWidth*TILE-(2*TILE); }
              if ( _y > mapHeight*TILE ) { _y = mapHeight*TILE-(2*TILE); }
              if( !droidCanReach(droid, _x ,_y) ){
                if ( pickStructLocation(powGen, ref _x, ref _y, player) ){
                  //dbg("dbg->checkIfDroidIsStuck: 1-Moving droid ("& droid.id &") to("& _x/TILE &"-"& _y/TILE &") time("& gameTime &")",player);
                  orderDroidLoc(droid, DORDER_MOVE, _x, _y);
                }
              } else {
                //dbg("dbg->checkIfDroidIsStuck: 2-Moving droid ("& droid.id &") to("& _x/TILE &"-"& _y/TILE &") time("& gameTime &")",player);
                orderDroidLoc(droid, DORDER_MOVE, _x, _y);
              }
              */
              
            } //else { displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") is possibly **STUCK** dist("& _dist/TILE &") pos("& droid.x/TILE &"-"& droid.y/TILE &") buildx("& droid.orderx/TILE &"-"& droid.ordery/TILE &") time("& gameTime &")");       }

          }
        
        }
      }
		  
		} else {
      //displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") is idle in x("& droid.x/TILE &") y("& droid.y/TILE &") time("& gameTime &")");
		  cleanDroidPos(droid.id);//put all to -1
    }
		droid = iterateGroup(_group);
	}
 return;
}
//-----------------------------------------------------------------------------
function bool incrementDroidCounter(int droid_id)
{
  local int _c;
  _c = 0;
  while ( _c < num_aDroid )
  {
    if (aDroid_Id[_c] == droid_id ){
      aDroid_counter[_c] = aDroid_counter[_c] + 1;
      if ( aDroid_counter[_c] > 1 ){ return true; } else { return false;}
    }
    _c++;
  }
  
  //dbg("dbg->incrementDroidCounter: Error! droid ("& droid_id &") not found",player);
  return false;
}
//-----------------------------------------------------------------------------
function void cleanDroidCoordArray()
{
  local int _c;
  _c = 0;
  while ( _c < num_aDroid )
  {

  	boolResult = false;
    initIterateGroup(buildGrp);
  	droid = iterateGroup(buildGrp);
  	while(droid != NULLOBJECT)
  	{
      if ( aDroid_Id[_c] == droid.id ){
        boolResult = true;
      }
  		droid = iterateGroup(buildGrp);
  	}
    
    initIterateGroup(buildDefGrp);
  	droid = iterateGroup(buildDefGrp);
  	while(droid != NULLOBJECT)
  	{
      if ( aDroid_Id[_c] == droid.id ){
        boolResult = true;
      }
  		droid = iterateGroup(buildDefGrp);
  	}
    
    initIterateGroup(harvesterGroup);
  	droid = iterateGroup(harvesterGroup);
  	while(droid != NULLOBJECT)
  	{
      if ( aDroid_Id[_c] == droid.id ){
        boolResult = true;
      }
  		droid = iterateGroup(harvesterGroup);
  	}

    if ( !boolResult ){
      cleanDroidPos(aDroid_Id[_c]);
    }
    
    _c++;
  }

 
 return;
}
//-----------------------------------------------------------------------------
function void cleanDroidPos(int _droidId)
{
  local int _c;
  _c = 0;
  while ( _c < num_aDroid )
  {
    if ( aDroid_Id[_c] == _droidId ){
      aDroid_Id[_c] = -1;
      aDroid_X[_c]  = -1;
      aDroid_Y[_c]  = -1;
      aDroid_counter[_c] = 0;
    }
    _c++;
  }
}

//-----------------------------------------------------------------------------
function void storeDroidCoord(DROID _droid)
{
  local int _c;
  _c = getFreePosDroid();
  if ( _c == -1 ){ _c = 49-random(10); } //hack
  aDroid_Id[_c] = droid.id;
  aDroid_X[_c]  = droid.x;
  aDroid_Y[_c]  = droid.y;
}
//-----------------------------------------------------------------------------
function void updateDroidCoord(DROID _droid)
{
  local int _c;
  _c = 0;
  while ( count < num_aDroid )
  {
    if ( aDroid_Id[_c] == _droid.id ){
      aDroid_Id[_c] = droid.id;
      aDroid_X[_c]  = droid.x;
      aDroid_Y[_c]  = droid.y;
      return;
    }
    _c++;
  }
  //it is ok if the droid has not been found because positions are resetted 
  //for droid not idle
  storeDroidCoord(_droid);
  return;
}

//-----------------------------------------------------------------------------
function bool coordChanged(DROID _droid)
{
  local int _c,_c2;
  _c = 0;
  while ( _c < num_aDroid )
  {
    if ( aDroid_Id[_c] == _droid.id ){
      _c2 = distBetweenTwoPoints(_droid.x,_droid.y,aDroid_X[_c],aDroid_Y[_c]);
      if ( _c2 > 2*TILE ){
        //displayMsg("coordChanged: TRUE droid ("& droid.id &") _c2("& _c2 &")>("& 2*TILE &") ");
        return true;
      } else {
        //displayMsg("coordChanged: FALSE droid ("& droid.id &") _c2("& _c2 &")>("& 2*TILE &") ");
        return false;
      }
    }
    _c++;
  }
  //dbg("dbg->coordChanged: Error! droid ("& _droid.id &") not found",player);
  return true;
}
//-----------------------------------------------------------------------------
function bool hasCoordStored(DROID _droid)
{
  local int _c;
  _c = 0;
  while ( _c < num_aDroid )
  {
    if ( aDroid_Id[_c] == _droid.id ){
      return true;  
    }
    _c++;
  }
  return false;
}
//-----------------------------------------------------------------------------
function int getFreePosDroid()
{
  local int _c;
  _c = 0;
  while ( _c < num_aDroid )
  {
    if ( aDroid_Id[_c] == -1 ){  return _c;  }
    _c++;
  }
  //dbg("dbg->getFreePosDroid: player("& player &") free pos not found!! ("& _c &")",player);
  return -1;
}
//--------------------------------------------------------------------
function int numStructinRange(STRUCTURESTAT _struct, int _player, int _xCoord, int _yCoord, int _Range)
{
  local int _nTot;
	local	STRUCTURE	_structure;

  _nTot = 0;
  
  initEnumStruct(false,_struct,_player,_player);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
    if ( distBetweenTwoPoints(_xCoord,_yCoord,_structure.x,_structure.y) <= _Range )  { _nTot++; }
    _structure = enumStruct();
  }
  
  return _nTot;
  
}
//--------------------------------------------------------------------
function void printDebug( STRING _message )
{
 if ( _DEBUG ){
  debug( GAME_TIME_IN_MIN &"min; "& getPlayerName(player) &" #"& player &" ["& AIPersonality &"-"& AIstrength &"-"& nResTmplPath &"] ;0 ;" & _message);
 }
}
//--------------------------------------------------------------------
function void printDebug1( STRING _message )
{
 if ( _DEBUG1 ){
  debug( GAME_TIME_IN_MIN &"min; "& getPlayerName(player) &" #"& player &" ["& AIPersonality &"-"& AIstrength &"-"& nResTmplPath &"] ;1 ;" & _message);
 }
}
//--------------------------------------------------------------------
// form alliances between AIs
function bool createAIalliance(int _player1, int _player2)
{

  if (!isPlayerStillLive(_player1) or !isPlayerStillLive(_player2)){
    //dbg("dbg->createAIalliance: cannot ally as one or both players are not live",player);
    return false;
  }

	if( isHumanPlayer(_player1) or isHumanPlayer(_player1)  ) {
    //dbg("dbg->createAIalliance: cannot ally as one or both players are human",player);
    return false;
  }
  
	if( allianceExistsBetween(_player1, _player2) ){
    //dbg("dbg->createAIalliance: players are already allied",player);
	  return false;
  }
  
  createAlliance(_player1,_player2);

  notifyAll("Alliance created between AIs: '"& getPlayerName(_player1) &"' '"& getPlayerName(_player2) &"'");
  printDebug1("createAIalliance; Alliance created between AIs '"& getPlayerName(_player1) &"' '"& getPlayerName(_player2) &"'");
  
  return true;
}
//--------------------------------------------------------------------
function STRUCTURESTAT getDefStruct(bool _mustBeWallDef)
{
  
  local STRUCTURESTAT _defStructure;
  local int _nDef,_n,_rnd,_enPlayer,_count,_nAP,_nAR,_nAT;
  local bool  _bProceed,_bAP,_bAR,_bAT;

  _bProceed = true;  
  
  buildX = -1;
  buildY = -1;
  
  _bAP = false;
  _bAR = false;
  _bAT = false;
  
  
  _rnd = 99;
  
  //if hard points are avail reduce standard to 25%
  if ( pickWallDefQueueDepth == 0 ){ _rnd = random(100); }
  if ( pickWallDefQueueDepth == 1 ){ _rnd = _rnd+25; }
  //Force to wall defences
  if ( _mustBeWallDef or pickWallDefQueueDepth > 1 ){ _rnd = 99; }
     
   //=========== STANDARD DEFENCES ==================================
  if ( pickWallDefQueueDepth == 0 or _rnd < 25 ){
  
    _n     = -1;

    _nAP = -1;
    _nAT = -1;
    _nAR = -1;
 
    //AP
    if (isStructureAvailable(defStructs[0],player)){ _n = 0; }
    if (isStructureAvailable(defStructs[1],player)){ _n = 1; }
    if (isStructureAvailable(defStructs[2],player)){ _n = 2; }
    if (isStructureAvailable(defStructs[3],player)){ _n = 3; }
    if (isStructureAvailable(defStructs[4],player)){ _n = 4; }
    if (isStructureAvailable(defStructs[5],player)){ _n = 5; }
    if ( _n > -1 ){ _bAP = true; _nAP = _n; }
    
    //AT
    if (isStructureAvailable(defStructs[6],player)) { _n = 6; }
    if (isStructureAvailable(defStructs[7],player)) { _n = 7; }
    if (isStructureAvailable(defStructs[8],player)) { _n = 8; }
    if (isStructureAvailable(defStructs[9],player)) { _n = 9; }
    if (isStructureAvailable(defStructs[10],player)){ _n = 10; }
    if (isStructureAvailable(defStructs[11],player)){ _n = 11; }
    if ( _n > 5 ){ _bAT = true; _nAT = _n; }

    //AR
    if (isStructureAvailable(defStructs[12],player)){ _n = 12; }
    if (isStructureAvailable(defStructs[13],player)){ _n = 13; }
    if (isStructureAvailable(defStructs[14],player)){ _n = 14; }
    if (isStructureAvailable(defStructs[15],player)){ _n = 15; }
    if (isStructureAvailable(defStructs[16],player)){ _n = 16; }
    if ( _n > 11 ){ _bAR = true; _nAR = _n; }

    //get right counter
    if ( nStdDef == 0 and !_bAP ){ nStdDef++; }
    if ( nStdDef == 1 and !_bAT ){ nStdDef++; }
    if ( nStdDef == 2 and !_bAR ){  
      nStdDef = 0; 
      if ( nStdDef == 0 and !_bAP ){ nStdDef++; }
      if ( nStdDef == 1 and !_bAT ){ 
        nStdDef++; 
        printDebug1("#### getDefStruct(): (1) no std def struct found? nStdDef("& nStdDef &") _rnd("& _rnd &") wallDepth("& pickWallDefQueueDepth &")");
        return _defStructure;      
      }
    }

    if ( _nAP > -1 and _nAT > -1 and _nAR > -1 ){
      if ( nStdDef == 0 ){  _defStructure = defStructs[_nAP]; }
      if ( nStdDef == 1 ){  _defStructure = defStructs[_nAT]; }
      if ( nStdDef == 2 ){  _defStructure = defStructs[_nAR]; }
    } else {
      if ( _nAP > -1 and _nAT > -1 ){
        if ( nStdDef == 0 ){  _defStructure = defStructs[_nAP]; }
        if ( nStdDef == 1 ){  _defStructure = defStructs[_nAT]; }
      }
      if ( _nAP > -1 and _nAR > -1 ){
        if ( nStdDef == 0 ){  _defStructure = defStructs[_nAP]; }
        if ( nStdDef == 2 ){  _defStructure = defStructs[_nAR]; }
      }
      if ( _nAR > -1 and _nAT > -1 ){
        if ( nStdDef == 1 ){  _defStructure = defStructs[_nAT]; }
        if ( nStdDef == 2 ){  _defStructure = defStructs[_nAR]; }
      }
      if ( _nAP > -1 ){
        if ( nStdDef == 0 ){  _defStructure = defStructs[_nAP]; }
      }
      if ( _nAT > -1 ){
        if ( nStdDef == 1 ){  _defStructure = defStructs[_nAT]; }
      }
      if ( _nAR > -1 ){
        if ( nStdDef == 2 ){  _defStructure = defStructs[_nAR]; }
      }
      if ( _nAR < 0 and _nAP < 0 and _nAT < 0  ) {
        printDebug1("#### getDefStruct(): no standard def struct found? nStdDef("& nStdDef &") wallDepth("& pickWallDefQueueDepth &")");
      }
    }

    nStdDef++;
    if ( nStdDef > 2 ) { nStdDef = 0; }
    
  //=========== WALL DEFENCES ==================================
  } else { 
  	
    _n     = -1;

    _nAP = -1;
    _nAT = -1;
    _nAR = -1;

    //AP
    if (isStructureAvailable(wallWeaps[0],player)){ _n = 0; }
    if (isStructureAvailable(wallWeaps[1],player)){ _n = 1; }
    if (isStructureAvailable(wallWeaps[2],player)){ _n = 2; }
    if (isStructureAvailable(wallWeaps[3],player)){ _n = 3; }
    if ( _n > -1 ){ _bAP = true; _nAP = _n; }
    
    //AR
    if (isStructureAvailable(wallWeaps[4],player)){ _n = 4; }
    if (isStructureAvailable(wallWeaps[5],player)){ _n = 5; }
    if (isStructureAvailable(wallWeaps[6],player)) { _n = 6; }
    if (isStructureAvailable(wallWeaps[7],player)) { _n = 7; }
    if (isStructureAvailable(wallWeaps[8],player)) { _n = 8; }
    if (isStructureAvailable(wallWeaps[9],player)) { _n = 9; }
    if (isStructureAvailable(wallWeaps[10],player)){ _n = 10; }
    if ( _n > 3 ){ _bAR = true; _nAR = _n; }

    //AT
    if (isStructureAvailable(wallWeaps[11],player)){ _n = 11; }
    if (isStructureAvailable(wallWeaps[12],player)){ _n = 12; }
    if (isStructureAvailable(wallWeaps[13],player)){ _n = 13; }
    if (isStructureAvailable(wallWeaps[14],player)){ _n = 14; }
    if ( _n > 10 ){ _bAT = true; _nAT = _n; }

    //get right counter
    if ( nWallDef == 0 and !_bAP ){ nWallDef++; }
    if ( nWallDef == 1 and !_bAR ){ nWallDef++; }
    if ( nWallDef == 2 and !_bAT ){  
      nWallDef = 0; 
      if ( nWallDef == 0 and !_bAP ){ nWallDef++; }
      if ( nWallDef == 1 and !_bAR ){ 
        nWallDef++; 
        printDebug1("#### getDefStruct(): (1) no WALL def struct found? nWallDef("& nWallDef &")");
        return _defStructure;      
      }
    }

    if ( _nAP > -1 and _nAT > -1 and _nAR > -1 ){
      if ( nWallDef == 0 ){  _defStructure = wallWeaps[_nAP]; }
      if ( nWallDef == 1 ){ _defStructure = wallWeaps[_nAT]; }
      if ( nWallDef == 2 ){ _defStructure = wallWeaps[_nAR]; }
    } else {
      if ( _nAP > -1 and _nAT > -1 ){
        if ( nWallDef == 0 ){  _defStructure = wallWeaps[_nAP]; }
        if ( nWallDef == 2 ){  _defStructure = wallWeaps[_nAT]; }
      }
      if ( _nAP > -1 and _nAR > -1 ){
        if ( nWallDef == 0 ){  _defStructure = wallWeaps[_nAP]; }
        if ( nWallDef == 1 ){  _defStructure = wallWeaps[_nAR]; }
      }
      if ( _nAR > -1 and _nAT > -1 ){
        if ( nWallDef == 1 ){  _defStructure = wallWeaps[_nAR]; }
        if ( nWallDef == 2 ){  _defStructure = wallWeaps[_nAT]; }
      }
      if ( _nAP > -1 ){
        if ( nWallDef == 0 ){  _defStructure = wallWeaps[_nAP]; }
      }
      if ( _nAT > -1 ){
        if ( nWallDef == 1 ){  _defStructure = wallWeaps[_nAR]; }
      }
      if ( _nAR > -1 ){
        if ( nWallDef == 2 ){  _defStructure = wallWeaps[_nAT]; }
      }
      if ( _nAR < 0 and _nAP < 0 and _nAT < 0  ) {
        printDebug1("#### getDefStruct(): no WALL def struct found? nWallDef("& nWallDef &")");
      } //else {
        //printDebug1("DefStruct():  WALL def struct found: _nAT("& _nAT &")_nAP("& _nAP &")_nAR("& _nAR &") nWallDef["& nWallDef &"]");
      //}
    }
  
    nWallDef++;
    if ( nWallDef > 2 ) { nWallDef = 0; }
  }
  

  return _defStructure;
}
//-----------------------------------------------------------------------------
//only droids with order != build are taken into account
function DROID closestDroidCanBuild(GROUP _group, int _x, int _y)
{
	local DROID _closestTruck,_tempTruck;
	local int 	_closestDist,_tempDist;

	_closestTruck = NULLOBJECT;
	_closestDist = 999*TILE;

  if (_group.members == 0){ return _closestTruck; }

	initIterateGroup(_group);
	_tempTruck = iterateGroup(_group);
	while(_tempTruck != NULLOBJECT)
	{
    boolResult = true;
    if( _tempTruck.order != DORDER_BUILD and _tempTruck.order != DORDER_RTR  )
		{
			if ( _group != buildDefGrp ){
			 if (_tempTruck.order == DORDER_REPAIR){
			   boolResult = false;
       }
      }
      if ( boolResult ){
        _tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
  			if(_tempDist < _closestDist)
  			{
  				_closestDist  = _tempDist;
  				_closestTruck = _tempTruck;
  			}
			}
		}
		_tempTruck = iterateGroup(_group);
	}
	return _closestTruck;
}
//-----------------------------------------------------------------------------
function DROID closestIdleDroid(GROUP _group, int _x, int _y)
{
	local DROID _closestTruck,_tempTruck;
	local int 	_closestDist,_tempDist;

	_closestTruck = NULLOBJECT;
	_closestDist = 999*TILE;

  if (_group.members == 0){ return _closestTruck; }

	initIterateGroup(_group);
	_tempTruck = iterateGroup(_group);
	while(_tempTruck != NULLOBJECT)
	{
    if( droidOrderIdle(_tempTruck) )
		{
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
			if(_tempDist < _closestDist)
			{
				_closestDist = _tempDist;
				_closestTruck = _tempTruck;
			}
		}
		_tempTruck = iterateGroup(_group);
	}
	return _closestTruck;
}
//------------------------------------------------------------------------
function  bool buildHeavyTank( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _pos, _nChoice,_nTmpl,_nBestTmpl;
  local int _tmpl[20];
  
  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++ ;
  }
  
  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  _nBestTmpl = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){ _tmpl[_n] = 46; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){ _tmpl[_n] = 45; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _tmpl[_n] = 44; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){ _tmpl[_n] = 21; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ){  _tmpl[_n] = 9; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ){  _tmpl[_n] = 8; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ){  _tmpl[_n] = 3; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ){  _tmpl[_n] = 2; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){ _tmpl[_n] = 48; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[47]) ){ _tmpl[_n] = 47; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){ _tmpl[_n] = 23; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){ _tmpl[_n] = 22; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){ _tmpl[_n] = 11; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){ _tmpl[_n] = 10; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ) { _tmpl[_n] = 5; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ) { _tmpl[_n] = 4; _n++; }
  }
  
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){ _tmpl[_n] = 43; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[42]) ){ _tmpl[_n] = 42; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[41]) ){ _tmpl[_n] = 41; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){ _tmpl[_n] = 40; _n++; }     
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){ _tmpl[_n] = 36; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){ _tmpl[_n] = 35; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){ _tmpl[_n] = 34; _n++; }      
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){ _tmpl[_n] = 20; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){ _tmpl[_n] = 19; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){ _tmpl[_n] = 18; _n++; }     
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ) { _tmpl[_n] = 7; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ) { _tmpl[_n] = 6; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ) { _tmpl[_n] = 1; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ) { _tmpl[_n] = 0; _n++; }
  }

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildHeavyTank;  error ! no templates found _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR) structCapacity("& skGetFactoryCapacity(_struct) &") _n("& _n &") == 0 !!! ");
    return false;  
  }
  _nTmpl = _tmpl[_nBestTmpl];

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  
  //____phyton_____
  if ( ( _nTmpl == 40 and skCanBuildTemplate(player,_struct, tmpl0[41] ) ) or (_nTmpl == 41 and skCanBuildTemplate(player,_struct, tmpl0[40]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 41;//set Sk-PythonHvCanTrack
    } else {
      _nChoice= 40;//set SK-Python-Hover-Hcannon
    }
  }
  if ( (_nTmpl == 44 or _nTmpl == 45 or _nTmpl == 46) and (skCanBuildTemplate(player,_struct, tmpl0[44]) and skCanBuildTemplate(player,_struct, tmpl0[45]) and skCanBuildTemplate(player,_struct, tmpl0[46]) ) ){  
    if ( random(10) < 5 ){
        _nChoice= 46;//set PythonHoverInferno
    } else {
      if ( random(10) < 7 ){
        _nChoice= 44;//set PhytonHTrackAssGun
      } else {
        _nChoice= 45;//set PhytonHoverAssGun
      }
    }
  } else {
    if ( ( _nTmpl == 44 and skCanBuildTemplate(player,_struct, tmpl0[45] ) ) or (_nTmpl == 45 and skCanBuildTemplate(player,_struct, tmpl0[44]) ) ){
      if ( random(10) < 6 ){
        _nChoice= 44;//set PhytonHTrackAssGun
      } else {
        _nChoice= 45;//set PhytonHoverAssGun
      }
    }
  }

  //____Mantis_____
  if ( _nTmpl == 34 ){
    if ( skCanBuildTemplate(player,_struct, tmpl0[36]) and skCanBuildTemplate(player,_struct, tmpl0[35]) )
    {
      if ( random(10) < 6 ){
        _nChoice= 34;//set SK-Mantis-Hover-Hcannon
      } else {
        if ( random(10) < 5 ){
          _nChoice= 36;//set MantisHoverAC
        } else {
          _nChoice= 35;//set SK-Mantis-Hover-HVC
        }
      }
    }
  }
  if ( ( _nTmpl == 35 and skCanBuildTemplate(player,_struct, tmpl0[36] ) ) or (_nTmpl == 36 and skCanBuildTemplate(player,_struct, tmpl0[35] ) ) ){
    if ( random(10) < 5 ){
      _nChoice= 36;//set MantisHoverAC
    } else {
      _nChoice= 35;//set SK-Mantis-Hover-HVC
    }
  }

  //____phyton_____Mantis_____
  if (  _nTmpl == 34 or _nTmpl == 35 or _nTmpl == 36 ){ //Any Mantis
    if ( skCanBuildTemplate(player,_struct, tmpl0[40] ) and skCanBuildTemplate(player,_struct, tmpl0[41] ) )
    {
      if ( random(10) < 5 ){//50% build Phyton
        if ( random(10) < 6 ){
          _nChoice= 41;//Sk-PythonHvCanTrack
        } else {
          _nChoice= 40;//SK-Python-Hover-Hcannon
        }
      }
    }
  }

  //_____Tiger____
  if ( ( _nTmpl == 22 and skCanBuildTemplate(player,_struct, tmpl0[23] ) ) or (_nTmpl == 23 and skCanBuildTemplate(player,_struct, tmpl0[22] ) ) ){
    if ( random(10) < 6 ){
      _nChoice= 22;//set SK-Tiger-Track-TK
    } else {
      _nChoice= 23;//set SK-Tiger-Hover-TK
    }
  }
  if ( ( _nTmpl == 19 and skCanBuildTemplate(player,_struct, tmpl0[20] ) ) or ( _nTmpl == 20 and skCanBuildTemplate(player,_struct, tmpl0[19] )) ){
    if ( random(10) < 6 ){
      _nChoice= 19;// "TigerHoverRailGun" 
    } else {
      _nChoice= 20;//"SK-Tiger-Track-ASCannon"
    }
  }
  if (  ( _nTmpl == 18 and skCanBuildTemplate(player,_struct, tmpl0[19] ) ) or ( _nTmpl == 19 and skCanBuildTemplate(player,_struct, tmpl0[18] )) ){
    if ( random(10) < 6 ){
      _nChoice= 18;//set SK-Tiger-Track-Hcannon
    } else {
      _nChoice= 19;//set TigerHoverRailGun
    }
  }
  

  //_____Vengeance____
  if ( ( _nTmpl == 6 and skCanBuildTemplate(player,_struct, tmpl0[7] ) ) or (_nTmpl == 7 and skCanBuildTemplate(player,_struct, tmpl0[6]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 6;//set SK-Veng-Track-Gauss
    } else {
      _nChoice= 7;//set SK-Veng-Hover-Gauss
    }
  }
  if ( ( _nTmpl == 8 and skCanBuildTemplate(player,_struct, tmpl0[9] ) ) or (_nTmpl == 9 and skCanBuildTemplate(player,_struct, tmpl0[8]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 8;//set SK-Veng-Track-HvyLaser
    } else {
      _nChoice= 9;//set SK-Veng-Hover-PulseLsr
    }
  }
  if ( ( _nTmpl == 10 and skCanBuildTemplate(player,_struct, tmpl0[11] ) ) or (_nTmpl == 11 and skCanBuildTemplate(player,_struct, tmpl0[10]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 10;//set SK-Veng-Track-Scourge
    } else {
      _nChoice= 11;//set SK-Veng-Hover-Scourge
    }
  }

  //_____Wyvern____
  if ( ( _nTmpl == 0 and skCanBuildTemplate(player,_struct, tmpl0[1] ) ) or (_nTmpl == 1 and skCanBuildTemplate(player,_struct, tmpl0[0]) )){
    if ( random(10) < 5 ){
      _nChoice= 0;//set WyvernPlasmaCTracks
    } else {
      _nChoice= 1;//set WyvernGaussTracks
    }
  }
  if ( ( _nTmpl == 2 and skCanBuildTemplate(player,_struct, tmpl0[3] ) ) or (_nTmpl == 3 and skCanBuildTemplate(player,_struct, tmpl0[2]) )){
    if ( random(10) < 5 ){
      _nChoice= 2;//set WyvernHvLaserTracks
    } else {
      _nChoice= 3;//set WyvernPulseTracks
    }
  }
  if ( ( _nTmpl == 4 and skCanBuildTemplate(player,_struct, tmpl0[5] ) ) or (_nTmpl == 5 and skCanBuildTemplate(player,_struct, tmpl0[4]) )){
    if ( random(10) < 5 ){
      _nChoice= 4;//set WyvernScourgeTracks
    } else {
      _nChoice= 5;//set WyvernScourgeTracks
    }
  }

  //dbg("buildHeavyTank:  _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
  //if ( _n == 0 ){ 
    //printDebug1("#### buildHeavyTank;  error ! structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _n("& _n &") == 0 !!! ");
    //return false;  
  //}
  
  if ( _nChoice < 0 ){ _nChoice = _tmpl[_nBestTmpl];  }
  //printDebug1("buildHeavyTank;  _nChoice("& _nChoice &") _nBestTmpl("& _nBestTmpl &") ");
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //dbg("buildHeavyTank: build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    printDebug1("buildHeavyTank; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    //dbg("#### buildHeavyTank: could not build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    printDebug1("#### buildHeavyTank; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
}
//------------------------------------------------------------------------
function  bool buildMediumTank( int _nWeapon, STRUCTURE _struct )
{
  
  local int _nTmpl, _n, _pos, _nChoice, _nBestTmpl;
  local int _tmpl[20];
  
  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++;
  }
  
  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  _nBestTmpl = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[53]) ){ _tmpl[_n] = 53; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){ _tmpl[_n] = 50; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){ _tmpl[_n] = 49; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){ _tmpl[_n] = 38; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){ _tmpl[_n] = 27; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){ _tmpl[_n] = 26; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){ _tmpl[_n] = 15; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){ _tmpl[_n] = 14; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[56]) ){ _tmpl[_n] = 56; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[55]) ){ _tmpl[_n] = 55; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[54]) ){ _tmpl[_n] = 54; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){ _tmpl[_n] = 39; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){ _tmpl[_n] = 29; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){ _tmpl[_n] = 28; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){ _tmpl[_n] = 17; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){ _tmpl[_n] = 16; _n++; }
  }
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[52]) ){ _tmpl[_n] = 52; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){ _tmpl[_n] = 51; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){ _tmpl[_n] = 37; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){ _tmpl[_n] = 25; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){ _tmpl[_n] = 24; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){ _tmpl[_n] = 13; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){ _tmpl[_n] = 12; _n++; }
  }

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildMediumTank;  error ! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }
  _nTmpl = _tmpl[_nBestTmpl];

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  //____cobra_____
  if ( ( _nTmpl == 49 and skCanBuildTemplate(player,_struct, tmpl0[50] ) ) or (_nTmpl == 50 and skCanBuildTemplate(player,_struct, tmpl0[49]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 49;//set CobraInfernoHover
    } else {
      _nChoice = 50;//set CobraInfernoHTracks
    }
  }
  if ( ( _nTmpl == 51 and skCanBuildTemplate(player,_struct, tmpl0[52]) ) or (_nTmpl == 52 and skCanBuildTemplate(player,_struct, tmpl0[51]) ) ){
    if ( random(10) < 7 ){
      _nChoice = 51;//set SK-Cobra-Track-HVC 
    } else {
      _nChoice = 52;//set CobraMedCnHTrks
    }
  }

  //____Cobra - Scorpion_____
  if (  _nTmpl == 39 ){ //SK-Scorp-Hover-Lancer
    if ( skCanBuildTemplate(player,_struct, tmpl0[54]) ){
      if ( random(10) < 6 ){
        _nChoice = 54;//set CobraLtA-Thalftrack 
      }
    }
  }
  if (  _nTmpl == 38 ){ //ScorpHTrackHMG
    if ( skCanBuildTemplate(player,_struct, tmpl0[53]) ){
      if ( random(10) < 6 ){
        _nChoice = 53;//set CobraHMGHalfTrack
      }
    }
    if ( random(10) < 5 ){
      if ( skCanBuildTemplate(player,_struct, tmpl0[50])  ){
        if ( random(10) < 6 ){
          _nChoice = 50;//set CobraInfernoHTracks
        }
      }
    }   
  }

  //____Panther_____
  if ( ( _nTmpl == 28 and skCanBuildTemplate(player,_struct, tmpl0[29]) ) or (_nTmpl == 29 and skCanBuildTemplate(player,_struct, tmpl0[28]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 29;//set SK-Panther-Hover-TK
    } else {
      _nChoice = 28;//set SK-Panther-Track-TK
    }
  }
  if ( ( _nTmpl == 26 and skCanBuildTemplate(player,_struct, tmpl0[27]) ) or (_nTmpl == 27 and skCanBuildTemplate(player,_struct, tmpl0[26]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 27;//set PantherHoverPulseLas
    } else {
      _nChoice = 26;//set SK-Panther-Htrk-ASGun
    }
  }
  if ( ( _nTmpl == 24 and skCanBuildTemplate(player,_struct, tmpl0[25]) ) or (_nTmpl == 25 and skCanBuildTemplate(player,_struct, tmpl0[24]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 25;//set SK-Panther-Hover-HVC
    } else {
      _nChoice = 24;//set SK-Panther-Track-HVC
    }
  }

  //____Retrebution_____
  if ( ( _nTmpl == 16 and skCanBuildTemplate(player,_struct, tmpl0[17]) ) or (_nTmpl == 17 and skCanBuildTemplate(player,_struct, tmpl0[16]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 17;//set SK-Retre-Hover-Scourge
    } else {
      _nChoice = 16;//set SK-Retre-Track-Scourge
    }
  }
  if ( ( _nTmpl == 14 and skCanBuildTemplate(player,_struct, tmpl0[15]) ) or (_nTmpl == 15 and skCanBuildTemplate(player,_struct, tmpl0[14]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 15;//set RetreHoverFlashLight
    } else {
      _nChoice = 14;//set SK-Retre-Track-PulseLsr
    }
  }
  if ( ( _nTmpl == 12 and skCanBuildTemplate(player,_struct, tmpl0[13]) ) or (_nTmpl == 13 and skCanBuildTemplate(player,_struct, tmpl0[12]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 13;//set SK-Retre-Hover-RailGun
    } else {
      _nChoice = 12;//set SK-Retre-Track-RailGun
    }
  }
  
    //dbg("buildMediumTank: _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
  //if ( _n == 0 ){ 
    //printDebug1("#### buildMediumTank;  error ! structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _n("& _n &") == 0 !!! ");
    //return false;  
  //}
  
  if ( _nChoice < 0 ){ _nChoice = _tmpl[_nBestTmpl];  }
  //printDebug1("buildMediumTank;  _nChoice("& _nChoice &") _nBestTmpl("& _nBestTmpl &") ");
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //dbg("buildMediumTank: build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    //printDebug1("buildMediumTank; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildMediumTank; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//------------------------------------------------------------------------
function  bool buildLightTank( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _nChoice,_nBestTmpl;
  local int _tmpl[15];
  
  _n = 0;
  while ( _n < 15 ){
    _tmpl[_n] = -1;
    _n++ ;
  }
  
  _n         = 0;
  _nChoice   = -1;
  _nBestTmpl = -1;

  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[62]) ){ _tmpl[_n] = 62; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[61]) ){ _tmpl[_n] = 61; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[60]) ){ _tmpl[_n] = 60; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){ _tmpl[_n] = 33; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){ _tmpl[_n] = 32; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[58]) ){ _tmpl[_n] = 58; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[57]) ){ _tmpl[_n] = 57; _n++; }
  }
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[59]) ){ _tmpl[_n] = 59; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){ _tmpl[_n] = 31; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){ _tmpl[_n] = 30; _n++; }
  }

  if ( _n > 0 ){
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildLightTank;  error ! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }

  //dbg("buildLightTank:  _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
  
  _nChoice = _tmpl[_nBestTmpl];
  //printDebug1("buildLightTank;  _n("& _n &") _nBestTmpl("& _nBestTmpl &") ");

  if ( ( _nChoice == 58 and skCanBuildTemplate(player,_struct, tmpl0[57]) or _nChoice == 57 and skCanBuildTemplate(player,_struct, tmpl0[58]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 57;//set ViperMRLHalfTracks
    } else {
      _nChoice = 58;//set ViperPODHalfTracks
    }
  }

  if ( _nChoice < 0 ){
    printDebug1("#### buildLightTank;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") _nBestTmpl("& _nBestTmpl &") _nChoice("& _nChoice &") !!! ");
    return false;  
  }
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //printDebug1("buildLightTank; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildLightTank; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//---------------------------------------------------------------------------
function  int checkBestBody(int _nBody, int _nWeapon, STRUCTURE _struct )
{
  local int _i;
  local string _sBody,_sWeapon;
  
  _i = 0;
  if ( _nBody == BODY_HEAVY ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[42]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[41]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[47]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_MEDIUM ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[53]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[52]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[56]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[55]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[54]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_LIGHT ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[62]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[61]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[60]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[59]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[58]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[57]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_LIGHT ) { _sBody = "Light"; }
  if ( _nBody == BODY_MEDIUM ){ _sBody = "Medium"; }
  if ( _nBody == BODY_HEAVY ) { _sBody = "Heavy"; }
  if ( _nWeapon == WEAPON_AP ){ _sWeapon = "AP"; }
  if ( _nWeapon == WEAPON_AT ){ _sWeapon = "AT"; }
  if ( _nWeapon == WEAPON_AR ){ _sWeapon = "AR"; }
  //printDebug1("checkBestBody; num tmpl found='"& _i &"' Body='"& _sBody &"' Weapon='"& _sWeapon &"' structCapacity("& skGetFactoryCapacity(_struct) &")");
  return _i;
}
//------------------------------------------------------------------------
function  bool buildHeavyTank1( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _pos, _nChoice,_nTmpl,_nBestTmpl;
  local int _tmpl[20];
  
  if ( _nWeapon == WEAPON_AR ){
    printDebug1("#### buildHeavyTank1: _nWeapon == WEAPON_AR ??");
    return false;
  }

  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++ ;
  }
  
  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  _nBestTmpl = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){ _tmpl[_n] = 37; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){ _tmpl[_n] = 36; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){ _tmpl[_n] = 33; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){ _tmpl[_n] = 22; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){ _tmpl[_n] = 21; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){ _tmpl[_n] = 20; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ) { _tmpl[_n] = 6; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ) { _tmpl[_n] = 5; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ) { _tmpl[_n] = 4; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ) { _tmpl[_n] = 1; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ) { _tmpl[_n] = 0; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[41]) ){ _tmpl[_n] = 41; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){ _tmpl[_n] = 40; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){ _tmpl[_n] = 39; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){ _tmpl[_n] = 38; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){ _tmpl[_n] = 32; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){ _tmpl[_n] = 31; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){ _tmpl[_n] = 30; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){ _tmpl[_n] = 29; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){ _tmpl[_n] = 19; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){ _tmpl[_n] = 18; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){ _tmpl[_n] = 17; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){ _tmpl[_n] = 16; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ){ _tmpl[_n] = 9; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ){ _tmpl[_n] = 8; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ){ _tmpl[_n] = 7; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ){ _tmpl[_n] = 3; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ){ _tmpl[_n] = 2; _n++; }
  }
  

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildHeavyTank1;  error ! no templates found _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR) structCapacity("& skGetFactoryCapacity(_struct) &") _n("& _n &") == 0 !!! ");
    return false;  
  }

  _nTmpl = _tmpl[_nBestTmpl];

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  //____phyton_____
  if ( ( _nTmpl == 40 and skCanBuildTemplate(player,_struct, tmpl0[41] ) ) or (_nTmpl == 41 and skCanBuildTemplate(player,_struct, tmpl0[40]) ) ){
    if ( random(10) < 4 ){
      _nChoice= 41;//set SK-Python-Hover-Lancer
    } else {
      _nChoice= 40;//set A-Python-Trk-Lancer
    }
  }

  //____Mantis_____
  if ( ( _nTmpl == 30 and skCanBuildTemplate(player,_struct, tmpl0[31] ) ) or (_nTmpl == 31 and skCanBuildTemplate(player,_struct, tmpl0[30]) ) ){
    if ( random(10) < 4 ){
      _nChoice= 31;//set TK-Mantis-H
    } else {
      _nChoice= 30;//set MantisTKTracks
    }
  }

  //____phyton_____Mantis_____
  // See if it is the case to build phyton template even if Mantis is available
  if (  _nTmpl == 32 ){ //Lancer
    if ( skCanBuildTemplate(player,_struct, tmpl0[40] ) and skCanBuildTemplate(player,_struct, tmpl0[41] ) )
    {
      if ( random(10) < 5 ){//50% build Phyton
        if ( random(10) < 6 ){
          _nChoice= 41;//SK-Python-Hover-Lancer
        } else {
          _nChoice= 40;//A-Python-Trk-Lancer
        }
      }
    }
  }
  if (  _nTmpl == 30 or _nTmpl == 30 ){  //TK
    if ( skCanBuildTemplate(player,_struct, tmpl0[39] ) )
    {
      if ( random(10) < 6 ){
        _nChoice= 39;//PythonTKTracks
      }
    }
  }
  if (  _nTmpl == 29 ){  //Scourge
    if ( skCanBuildTemplate(player,_struct, tmpl0[38] ) )
    {
      if ( random(10) < 6 ){
        _nChoice= 38;//PythonScourgeTracks
      }
    }
  }
  if (  _nTmpl == 33 ){  //Pulse
    if ( skCanBuildTemplate(player,_struct, tmpl0[36] ) )
    {
      if ( random(10) < 6 ){
        _nChoice= 36;//PythonPulseTracks
      }
    }
  }


  //_____Tiger____
  if ( ( _nTmpl == 22 and skCanBuildTemplate(player,_struct, tmpl0[23] ) ) or (_nTmpl == 23 and skCanBuildTemplate(player,_struct, tmpl0[22] ) ) ){
    if ( random(10) < 6 ){
      _nChoice= 22;//set SK-Tiger-Track-TK
    } else {
      _nChoice= 23;//set SK-Tiger-Hover-TK
    }
  }
  if ( ( _nTmpl == 19 and skCanBuildTemplate(player,_struct, tmpl0[20] ) ) or ( _nTmpl == 20 and skCanBuildTemplate(player,_struct, tmpl0[19] )) ){
    if ( random(10) < 6 ){
      _nChoice= 19;// "TigerHoverRailGun" 
    } else {
      _nChoice= 20;//"SK-Tiger-Track-ASCannon"
    }
  }
  if (  ( _nTmpl == 18 and skCanBuildTemplate(player,_struct, tmpl0[19] ) ) or ( _nTmpl == 19 and skCanBuildTemplate(player,_struct, tmpl0[18] )) ){
    if ( random(10) < 6 ){
      _nChoice= 18;//set SK-Tiger-Track-Hcannon
    } else {
      _nChoice= 19;//set TigerHoverRailGun
    }
  }
  
  //_____Vengeance____
  if ( ( _nTmpl == 6 and skCanBuildTemplate(player,_struct, tmpl0[7] ) ) or (_nTmpl == 7 and skCanBuildTemplate(player,_struct, tmpl0[6]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 6;//set SK-Veng-Track-Gauss
    } else {
      _nChoice= 7;//set SK-Veng-Hover-Gauss
    }
  }
  if ( ( _nTmpl == 8 and skCanBuildTemplate(player,_struct, tmpl0[9] ) ) or (_nTmpl == 9 and skCanBuildTemplate(player,_struct, tmpl0[8]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 8;//set SK-Veng-Track-HvyLaser
    } else {
      _nChoice= 9;//set SK-Veng-Hover-PulseLsr
    }
  }
  if ( ( _nTmpl == 10 and skCanBuildTemplate(player,_struct, tmpl0[11] ) ) or (_nTmpl == 11 and skCanBuildTemplate(player,_struct, tmpl0[10]) ) ){
    if ( random(10) < 6 ){
      _nChoice= 10;//set SK-Veng-Track-Scourge
    } else {
      _nChoice= 11;//set SK-Veng-Hover-Scourge
    }
  }

  //_____Wyvern____
  if ( ( _nTmpl == 0 and skCanBuildTemplate(player,_struct, tmpl0[1] ) ) or (_nTmpl == 1 and skCanBuildTemplate(player,_struct, tmpl0[0]) )){
    if ( random(10) < 5 ){
      _nChoice= 0;//set WyvernPlasmaCTracks
    } else {
      _nChoice= 1;//set WyvernGaussTracks
    }
  }
  if ( ( _nTmpl == 2 and skCanBuildTemplate(player,_struct, tmpl0[3] ) ) or (_nTmpl == 3 and skCanBuildTemplate(player,_struct, tmpl0[2]) )){
    if ( random(10) < 5 ){
      _nChoice= 2;//set WyvernHvLaserTracks
    } else {
      _nChoice= 3;//set WyvernPulseTracks
    }
  }
  if ( ( _nTmpl == 4 and skCanBuildTemplate(player,_struct, tmpl0[5] ) ) or (_nTmpl == 5 and skCanBuildTemplate(player,_struct, tmpl0[4]) )){
    if ( random(10) < 5 ){
      _nChoice= 4;//set WyvernScourgeTracks
    } else {
      _nChoice= 5;//set WyvernScourgeTracks
    }
  }
  
  if ( _nChoice < 0 ){ _nChoice = _tmpl[_nBestTmpl];  }
  //printDebug1("buildHeavyTank1;  _nChoice("& _nChoice &") _nBestTmpl("& _nBestTmpl &") ");
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //dbg("buildHeavyTank: build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    //printDebug1("buildHeavyTank1; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    //dbg("#### buildHeavyTank: could not build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    printDebug1("#### buildHeavyTank1; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
}
//------------------------------------------------------------------------
function  bool buildHeavyTank2( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _pos, _nChoice,_nTmpl,_nBestTmpl;
  local int _tmpl[20];
  
  if ( _nWeapon == WEAPON_AT ){
    printDebug1("#### buildHeavyTank2: _nWeapon == WEAPON_AT ??");
    return false;
  }

  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++ ;
  }

  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[54]) ){  _tmpl[_n] = 54; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[53]) ){  _tmpl[_n] = 53; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){  _tmpl[_n] = 43; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){  _tmpl[_n] = 29; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){  _tmpl[_n] = 28; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){  _tmpl[_n] = 27; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){  _tmpl[_n] = 11; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){  _tmpl[_n] = 10; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ) {  _tmpl[_n] = 9; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ) {  _tmpl[_n] = 3; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ) {  _tmpl[_n] = 2; _n++; }
  }
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[52]) ){  _tmpl[_n] = 52; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){  _tmpl[_n] = 51; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){  _tmpl[_n] = 50; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){  _tmpl[_n] = 49; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){  _tmpl[_n] = 48; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[47]) ){  _tmpl[_n] = 47; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){  _tmpl[_n] = 42; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){  _tmpl[_n] = 41; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){  _tmpl[_n] = 40; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){  _tmpl[_n] = 39; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){  _tmpl[_n] = 26; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){  _tmpl[_n] = 25; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){  _tmpl[_n] = 24; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){  _tmpl[_n] = 23; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){  _tmpl[_n] = 22; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){  _tmpl[_n] = 21; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){  _tmpl[_n] = 20; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ) {  _tmpl[_n] = 8; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ) {  _tmpl[_n] = 7; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ) {  _tmpl[_n] = 6; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ) {  _tmpl[_n] = 5; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ) {  _tmpl[_n] = 4; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ) {  _tmpl[_n] = 1; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ) {  _tmpl[_n] = 0; _n++; }
  }
  

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildHeavyTank2;  error ! no templates found _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR) structCapacity("& skGetFactoryCapacity(_struct) &") _n("& _n &") == 0 !!! ");
    return false;  
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  _nTmpl = _tmpl[_nBestTmpl];

  //_____Cobra____
  if ( ( _nTmpl == 59 and skCanBuildTemplate(player,_struct, tmpl0[58] ) ) or (_nTmpl == 58 and skCanBuildTemplate(player,_struct, tmpl0[59]) )){
    if ( random(10) < 6 ){
      _nChoice= 59;//CobraHMGHalfTrack
    } else {
      _nChoice= 58;//SK-Cobra-Hover-HMG
    }
  }
  if ( ( _nTmpl == 56 and skCanBuildTemplate(player,_struct, tmpl0[57] ) ) or (_nTmpl == 57 and skCanBuildTemplate(player,_struct, tmpl0[56]) )){
    if ( random(10) < 6 ){
      _nChoice= 57;//CobraMedCnHTrks
    } else {
      _nChoice= 56;//A-Cobra-Hover-MC
    }
  }

  //_____Phyton____
  if ( ( _nTmpl == 53 and skCanBuildTemplate(player,_struct, tmpl0[54] ) ) or (_nTmpl == 54 and skCanBuildTemplate(player,_struct, tmpl0[53]) )){
    if ( random(10) < 6 ){
      _nChoice= 53;//PhytonHTrackAssGun
    } else {
      _nChoice= 54;//PhytonHoverAssGun
    }
  }
  if ( ( _nTmpl == 51 and skCanBuildTemplate(player,_struct, tmpl0[52] ) ) or (_nTmpl == 52 and skCanBuildTemplate(player,_struct, tmpl0[51]) )){
    if ( random(10) < 6 ){
      _nChoice= 52;//PythonMedCanTracks
    } else {
      _nChoice= 51;//SK-Python-Hover-Mcannon
    }
  }
  if ( ( _nTmpl == 49 and skCanBuildTemplate(player,_struct, tmpl0[50] ) ) or (_nTmpl == 50 and skCanBuildTemplate(player,_struct, tmpl0[49]) )){
    if ( random(10) < 6 ){
      _nChoice= 50;//P0cam3PyHPVcanTrk
    } else {
      _nChoice= 49;//PythonHoverHVC
    }
  }
  if ( ( _nTmpl == 47 and skCanBuildTemplate(player,_struct, tmpl0[48] ) ) or (_nTmpl == 48 and skCanBuildTemplate(player,_struct, tmpl0[47]) )){
    if ( random(10) < 6 ){
      _nChoice= 48;//SK-Python-Track-Hcannon
    } else {
      _nChoice= 47;//SK-Python-Hover-Hcannon
    }
  }

  //_____Mantis____
  if ( ( _nTmpl == 41 and skCanBuildTemplate(player,_struct, tmpl0[42] ) ) or (_nTmpl == 42 and skCanBuildTemplate(player,_struct, tmpl0[41]) )){
    if ( random(10) < 3 ){
      _nChoice= 42;//MantisHoverAC
    } else {
      _nChoice= 41;//SK-Mantis-Hover-HVC
    }
  }

  //____phyton_____Mantis_____
  // See if it is the case to build phyton template even if Mantis is available
  if (  _nTmpl == 41 or _nTmpl == 42 ){ //HVC
    if ( skCanBuildTemplate(player,_struct, tmpl0[49] ) and skCanBuildTemplate(player,_struct, tmpl0[50] ) )
    {
      if ( random(10) < 5 ){//50% build Phyton
        if ( random(10) < 6 ){
          _nChoice= 50;//P0cam3PyHPVcanTrk
        } else {
          _nChoice= 49;//PythonHoverHVC
        }
      }
    }
  }
  if (  _nTmpl == 40 ){  //heavy cannon
    if ( skCanBuildTemplate(player,_struct, tmpl0[47] ) and skCanBuildTemplate(player,_struct, tmpl0[48] ) )
    {
      if ( random(10) < 5 ){
        if ( random(10) < 6 ){
          _nChoice= 48;//SK-Python-Track-Hcannon
        } else {
          _nChoice= 47;//SK-Python-Hover-Hcannon
        }
      }
    }
  }


    //____Phyton_____Mantis_____
  if ( _nTmpl == 39 or _nTmpl == 40 or _nTmpl == 41 or _nTmpl == 42 or _nTmpl == 43)
  {
    if ( random(10) < 6 ){//Phyton
      if ( _nWeapon == WEAPON_AP ){
        if ( skCanBuildTemplate(player,_struct, tmpl0[53]) or skCanBuildTemplate(player,_struct, tmpl0[54]) )
        {
          if ( random(10) < 5 ){
            _nChoice= 54;//set SK-Python-Hover-Lancer
          } else {
            _nChoice= 53;//set A-Python-Trk-Lancer
          }
        }
      }
    } else { //Mantis
      printDebug1("buildHeavyTank2; Mantis available, do not build Phyton, build Mantis _nTmpl("& _nTmpl &") == 0 !!! ");
    }
  }
 
  //_____Leopard____
  if ( ( _nTmpl == 36 and skCanBuildTemplate(player,_struct, tmpl0[35] ) ) or (_nTmpl == 35 and skCanBuildTemplate(player,_struct, tmpl0[36]) )){
    if ( random(10) < 3 ){
      _nChoice= 36;//SK-Leopard-Hover-Needle
    } else {
      _nChoice= 35;//SK-Leopard-HTrack-Needle
    }
  }
  
    
  //_____Panther____
  if ( ( _nTmpl == 31 and skCanBuildTemplate(player,_struct, tmpl0[32] ) ) or (_nTmpl == 32 and skCanBuildTemplate(player,_struct, tmpl0[31]) )){
    if ( random(10) < 4 ){
      _nChoice= 32;//SK-Panther-Hover-HVC
    } else {
      _nChoice= 31;//SK-Panther-Track-HVC
    }
  }

  //_____Tiger____
  if ( ( _nTmpl == 29 and skCanBuildTemplate(player,_struct, tmpl0[28] ) ) or (_nTmpl == 28 and skCanBuildTemplate(player,_struct, tmpl0[29]) )){
    if ( random(10) < 4 ){
      _nChoice= 29;//TigerHoverPulseLas
    } else {
      _nChoice= 28;//TigerPulseTracks
    }
  }
  if ( ( _nTmpl == 26 and skCanBuildTemplate(player,_struct, tmpl0[25] ) ) or (_nTmpl == 25 and skCanBuildTemplate(player,_struct, tmpl0[26]) )){
    if ( random(10) < 6 ){
      _nChoice= 26;//SK-Tiger-Track-ASCannon
    } else {
      _nChoice= 25;//SK-Tiger-Hover-ASCannon
    }
  }
  if ( ( _nTmpl == 21 and skCanBuildTemplate(player,_struct, tmpl0[20] ) ) or (_nTmpl == 20 and skCanBuildTemplate(player,_struct, tmpl0[21]) )){
    if ( random(10) < 6 ){
      _nChoice= 21;//SK-Tiger-Track-Gauss
    } else {
      _nChoice= 20;//SK-Tiger-Hover-Gauss
    }
  }

  //_____Retribution____
  if ( ( _nTmpl == 12 and skCanBuildTemplate(player,_struct, tmpl0[13] ) ) or (_nTmpl == 13 and skCanBuildTemplate(player,_struct, tmpl0[12]) )){
    if ( random(10) < 6 ){
      _nChoice= 13;//set SK-Retre-Track-RailGun
    } else {
      _nChoice= 12;//set SK-Retre-Hover-RailGun
    }
  }
  if ( ( _nTmpl == 18 and skCanBuildTemplate(player,_struct, tmpl0[17] ) ) or (_nTmpl == 17 and skCanBuildTemplate(player,_struct, tmpl0[18]) )){
    if ( random(10) < 4 ){
      _nChoice= 18;//set RetreHoverFlashLight
    } else {
      _nChoice= 17;//set SK-Retre-Track-FlashLight
    }
  }
  if ( ( _nTmpl == 16 and skCanBuildTemplate(player,_struct, tmpl0[15] ) ) or (_nTmpl == 15 and skCanBuildTemplate(player,_struct, tmpl0[16]) )){
    if ( random(10) < 6 ){
      _nChoice= 16;//set SK-Retre-Track-PulseLsr
    } else {
      _nChoice= 15;//set NX-M-PulseLas-Hover
    }
  }
  
  //_____Vengeance____
  if ( ( _nTmpl == 11 and skCanBuildTemplate(player,_struct, tmpl0[10] ) ) or (_nTmpl == 10 and skCanBuildTemplate(player,_struct, tmpl0[11]) )){
    if ( random(10) < 4 ){
      _nChoice= 11;//set SK-Veng-Hover-PulseLsr
    } else {
      _nChoice= 10;//set SK-Veng-Track-PulseLsr
    }
  }
  if ( ( _nTmpl == 4 and skCanBuildTemplate(player,_struct, tmpl0[5] ) ) or (_nTmpl == 5 and skCanBuildTemplate(player,_struct, tmpl0[4]) )){
    if ( random(10) < 4 ){
      _nChoice= 5;//set SK-Veng-Hover-Gauss
    } else {
      _nChoice= 4;//set SK-Veng-Track-Gauss
    }
  }

  //_____Wyvern____
  if ( ( _nTmpl == 0 and skCanBuildTemplate(player,_struct, tmpl0[1] ) ) or (_nTmpl == 1 and skCanBuildTemplate(player,_struct, tmpl0[0]) )){
    if ( random(10) < 5 ){
      _nChoice= 1;//set WyvernPlasmaCTracks
    } else {
      _nChoice= 0;//set WyvernGaussTracks
    }
  }
   
  if ( _nChoice < 0 ){ _nChoice = _tmpl[_nBestTmpl];  }
  //printDebug1("buildHeavyTank2;  _nChoice("& _nChoice &") _nTmpl("& _nTmpl &") ");
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //dbg("buildHeavyTank: build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    //printDebug1("buildHeavyTank2; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    //dbg("#### buildHeavyTank: could not build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    printDebug1("#### buildHeavyTank2; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nTmpl("& _nTmpl &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
}
//------------------------------------------------------------------------
function  bool buildMediumTank1( int _nWeapon, STRUCTURE _struct )
{
  
  local int _nTmpl, _n, _pos, _nChoice, _nBestTmpl;
  local int _tmpl[20];
  
  if ( _nWeapon == WEAPON_AR ){
    printDebug1("#### buildMediumTank1: _nWeapon == WEAPON_AR ??");
    return false;
  }

  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++;
  }
  
  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  _nBestTmpl = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _tmpl[_n] = 44; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){ _tmpl[_n] = 43; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[42]) ){ _tmpl[_n] = 42; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){ _tmpl[_n] = 27; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){ _tmpl[_n] = 26; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){ _tmpl[_n] = 13; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){ _tmpl[_n] = 12; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){ _tmpl[_n] = 11; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){ _tmpl[_n] = 10; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){ _tmpl[_n] = 46; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){ _tmpl[_n] = 45; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _tmpl[_n] = 44; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){ _tmpl[_n] = 35; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){ _tmpl[_n] = 34; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){ _tmpl[_n] = 25; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){ _tmpl[_n] = 24; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){ _tmpl[_n] = 23; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){ _tmpl[_n] = 15; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){ _tmpl[_n] = 14; _n++; }
  }

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildMediumTank1;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }
  _nTmpl = _tmpl[_nBestTmpl];

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  
  //____Cobra_____
  if ( ( _nTmpl == 47 and skCanBuildTemplate(player,_struct, tmpl0[46] ) ) or (_nTmpl == 46 and skCanBuildTemplate(player,_struct, tmpl0[47]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 47;//CobraMRLHalftrack
    } else {
      _nChoice = 46;//CobraPODHTracks
    }
  }
  if ( ( _nTmpl == 43 and skCanBuildTemplate(player,_struct, tmpl0[42]) ) or (_nTmpl == 42 and skCanBuildTemplate(player,_struct, tmpl0[43]) ) ){
    if ( random(10) < 7 ){
      _nChoice = 43;//CobraInfernoHTracks 
    } else {
      _nChoice = 42;//CobraInfernoHover
    }
  }
  
  //____Cobra - Scorpion_____
  if (  _nTmpl == 34 or _nTmpl == 35 ){ //Lancer Hover - Lancer Track
    if ( skCanBuildTemplate(player,_struct, tmpl0[44]) ){
      if ( random(10) < 6 ){ 
        _nChoice = 45;//CobraLtA-Thalftrack
      }
    }
  }

  //____Panther_____
  if ( ( _nTmpl == 23 and skCanBuildTemplate(player,_struct, tmpl0[24]) ) or (_nTmpl == 24 and skCanBuildTemplate(player,_struct, tmpl0[23]) ) ){
    if ( random(10) < 5 ){
      _nChoice = 24;//set SK-Panther-Hover-TK
    } else {
      _nChoice = 23;//set SK-Panther-Track-TK
    }
  }

  //____Retrebution_____
  if ( ( _nTmpl == 14 and skCanBuildTemplate(player,_struct, tmpl0[15]) ) or (_nTmpl == 15 and skCanBuildTemplate(player,_struct, tmpl0[14]) ) ){
    if ( random(10) < 5 ){
      _nChoice = 15;//set SK-Retre-Hover-Scourge
    } else {
      _nChoice = 14;//set SK-Retre-Track-Scourge
    }
  }
  if ( ( _nTmpl == 11 and skCanBuildTemplate(player,_struct, tmpl0[10]) ) or (_nTmpl == 10 and skCanBuildTemplate(player,_struct, tmpl0[11]) ) ){
    if ( random(10) < 5 ){
      _nChoice = 11;//set SK-Retre-Track-PulseLsr
    } else {
      _nChoice = 10;//set SNX-M-PulseLas-Hover
    }
  }

    
  if ( _nChoice < 0 ){ _nChoice = _nTmpl;  }
  //printDebug1("buildMediumTank1;  _nChoice("& _nChoice &") _nTmpl("& _nTmpl &") ");
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //dbg("buildMediumTank: build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")",player);
    printDebug1("buildMediumTank1; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildMediumTank1; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nTmpl("& _nTmpl &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//------------------------------------------------------------------------
function  bool buildMediumTank2( int _nWeapon, STRUCTURE _struct )
{
  
  local int _nTmpl, _n, _pos, _nChoice,_nBestTmpl;
  local int _tmpl[20];
  
  if ( _nWeapon == WEAPON_AT ){
    printDebug1("#### buildMediumTank2: _nWeapon == WEAPON_AT ??");
     return false;
  }

  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++ ;
  }

  _n         = 0;
  _pos       = -1;
  _nChoice   = -1;
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[59]) ){  _tmpl[_n] = 59; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[58]) ){  _tmpl[_n] = 58; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){  _tmpl[_n] = 46; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){  _tmpl[_n] = 45; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){  _tmpl[_n] = 34; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){  _tmpl[_n] = 33; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){  _tmpl[_n] = 18; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){  _tmpl[_n] = 17; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){  _tmpl[_n] = 16; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){  _tmpl[_n] = 15; _n++; }
  }
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[57]) ){  _tmpl[_n] = 57; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[56]) ){  _tmpl[_n] = 56; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[55]) ){  _tmpl[_n] = 55; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){  _tmpl[_n] = 44; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){  _tmpl[_n] = 32; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){  _tmpl[_n] = 31; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){  _tmpl[_n] = 30; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){  _tmpl[_n] = 14; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){  _tmpl[_n] = 13; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){  _tmpl[_n] = 12; _n++; }
  }

  if ( _n > 0 ){ 
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildMediumTank2;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }
  _nTmpl = _tmpl[_nBestTmpl];

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //further checks to ensure not only the last available template is built
  
  //printDebug1("buildMediumTank2;  _nBestTmpl("& _nBestTmpl &") _nTmpl("& _nTmpl &") ");

  //____Cobra_____
  if ( ( _nTmpl == 59 and skCanBuildTemplate(player,_struct, tmpl0[58] ) ) or (_nTmpl == 58 and skCanBuildTemplate(player,_struct, tmpl0[59]) ) ){
    if ( random(10) < 6 ){
      _nChoice = 59;//CobraHMGHalfTrack
    } else {
      _nChoice = 58;//SK-Cobra-Hover-HMG
    }
  }
  if ( ( _nTmpl == 57 and skCanBuildTemplate(player,_struct, tmpl0[56] ) ) or (_nTmpl == 56 and skCanBuildTemplate(player,_struct, tmpl0[57]) ) ){
    if ( random(10) < 6 ){
      _nChoice = 57;//CobraMedCnHTrks
    } else {
      _nChoice = 56;//A-Cobra-Hover-MC
    }
  }
 
  //____Cobra - Scorpion_____
  if (  _nTmpl == 46 ){ //ScorpHTrackHMG
    if ( skCanBuildTemplate(player,_struct, tmpl0[59]) ){
      if ( random(10) < 6 ){ 
        _nChoice = 59;//CobraHMGHalfTrack
      }
    }
  }
   if (  _nTmpl == 44 ){ //SK-Scorp-Hover-Mcannon
    if ( skCanBuildTemplate(player,_struct, tmpl0[57]) ){
      if ( random(10) < 6 ){ 
        _nChoice = 57;//CobraMedCnHTrks
      }
    }
    //Force to HVC on Cobra if possible
    if ( skCanBuildTemplate(player,_struct, tmpl0[55]) ){
      _nChoice = 55;//SK-Cobra-Track-HVC
    }
  }

  //____Panther_____
  if ( ( _nTmpl == 31 and skCanBuildTemplate(player,_struct, tmpl0[32] ) ) or (_nTmpl == 32 and skCanBuildTemplate(player,_struct, tmpl0[31]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 32;//SK-Panther-Hover-HVC
    } else {
      _nChoice = 31;//SK-Panther-Track-HVC
    }
  }

  //____Retre_____
  if ( ( _nTmpl == 18 and skCanBuildTemplate(player,_struct, tmpl0[17] ) ) or (_nTmpl == 17 and skCanBuildTemplate(player,_struct, tmpl0[18]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 18;//RetreHoverFlashLight
    } else {
      _nChoice = 17;//SK-Retre-Track-FlashLight
    }
  }
  if ( ( _nTmpl == 16 and skCanBuildTemplate(player,_struct, tmpl0[15] ) ) or (_nTmpl == 15 and skCanBuildTemplate(player,_struct, tmpl0[16]) ) ){
    if ( random(10) < 6 ){
      _nChoice = 16;//SK-Retre-Track-PulseLsr
    } else {
      _nChoice = 15;//NX-M-PulseLas-Hover
    }
  }
  if ( ( _nTmpl == 13 and skCanBuildTemplate(player,_struct, tmpl0[12] ) ) or (_nTmpl == 12 and skCanBuildTemplate(player,_struct, tmpl0[13]) ) ){
    if ( random(10) < 6 ){
      _nChoice = 13;//SK-Retre-Track-RailGun
    } else {
      _nChoice = 12;//SK-Retre-Hover-RailGun
    }
  }
    
  if ( _nChoice < 0 ){ _nChoice = _tmpl[_nBestTmpl];  }
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //printDebug1("buildMediumTank2; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildMediumTank2; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _pos("& _pos &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//------------------------------------------------------------------------
function  bool buildLightTank1( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _nChoice,_nBestTmpl;
  local int _tmpl[15];
  
  if ( _nWeapon == WEAPON_AR ){
    printDebug1("#### buildLightTank1: _nWeapon == WEAPON_AR ??");
    return false;
  }

  _n = 0;
  while ( _n < 15 ){
    _tmpl[_n] = -1;
    _n++ ;
  }
  
  _n         = 0;
  _nChoice   = -1;
  _nBestTmpl = -1;

  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){ _tmpl[_n] = 51; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){ _tmpl[_n] = 50; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){ _tmpl[_n] = 28; _n++; }
  }
  if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){ _tmpl[_n] = 49; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){ _tmpl[_n] = 48; _n++; }
  }

  if ( _n > 0 ){
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildLightTank1;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }

  _nChoice = _tmpl[_nBestTmpl];
  //printDebug1("buildLightTank1; A _n("& _n &") _nBestTmpl("& _nBestTmpl &") _nChoice("& _nChoice &")");

  if ( ( _nChoice == 48 and skCanBuildTemplate(player,_struct, tmpl0[47]) or _nChoice == 47 and skCanBuildTemplate(player,_struct, tmpl0[48]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 47;//set ViperMRLHalfTracks
    } else {
      _nChoice = 48;//set ViperPODHalfTracks
    }
  }

  if ( _nChoice < 0 ){
    printDebug1("#### buildLightTank1;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") _nBestTmpl("& _nBestTmpl &") _nChoice("& _nChoice &") !!! ");
    return false;  
  }
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //printDebug1("buildLightTank1; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildLightTank1; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//------------------------------------------------------------------------
function  bool buildLightTank2( int _nWeapon, STRUCTURE _struct )
{
  
  local int _n, _nChoice,_nBestTmpl;
  local int _tmpl[20];

  if ( _nWeapon == WEAPON_AT ){
    printDebug1("#### buildLightTank2: _nWeapon == WEAPON_AT ??");
    return false;
  }

  _n = 0;
  while ( _n < 20 ){
    _tmpl[_n] = -1;
    _n++ ;
  }

  _n         = 0;
  _nChoice   = -1; 
  
  if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[63]) ){  _tmpl[_n] = 63; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[62]) ){  _tmpl[_n] = 62; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[61]) ){  _tmpl[_n] = 61; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){  _tmpl[_n] = 38; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){  _tmpl[_n] = 37; _n++; }
  }
  if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[60]) ){  _tmpl[_n] = 60; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){  _tmpl[_n] = 36; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){  _tmpl[_n] = 35; _n++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){  _tmpl[_n] = 19; _n++; }
  }

  if ( _n > 0 ){
    _n--; 
    _nBestTmpl = _n; 
  } else { 
    printDebug1("#### buildLightTank2;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") == 0 !!! ");
    return false;  
  }

  _nChoice = _tmpl[_nBestTmpl];
  //printDebug1("buildLightTank2;  _n("& _n &") _nChoice("& _nChoice &") ");

  if ( ( _nChoice == 36 and skCanBuildTemplate(player,_struct, tmpl0[35]) or _nChoice == 35 and skCanBuildTemplate(player,_struct, tmpl0[36]) ) ){
    if ( random(10) < 4 ){
      _nChoice = 36;//set SK-Leopard-Hover-Needle
    } else {
      _nChoice = 35;//set SK-Leopard-Htrk-Needle
    }
  }

  if ( _nChoice < 0 ){
    printDebug1("#### buildLightTank2;  error! no templates found structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &")(0=AR,1=AT,2=AR)  _n("& _n &") _nChoice("& _nChoice &") !!! ");
    return false;  
  }
  
  if( skCanBuildTemplate( player , _struct , tmpl0[_nChoice]) ){
    //printDebug1("buildLightTank2; build template _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    buildDroid( tmpl0[_nChoice] , _struct, player, 1);
    return true;  
  } else {
    printDebug1("#### buildLightTank2; could not build template structCapacity("& skGetFactoryCapacity(_struct) &") _nWeapon("& _nWeapon &") _nChoice("& _nChoice &") _n("& _n &")");
    return false;  
  }
  return false;
  
}
//---------------------------------------------------------------------------
function  int checkBestBody1(int _nBody, int _nWeapon, STRUCTURE _struct )
{
  local int _i;
  local string _sBody,_sWeapon;

  if ( _nWeapon == WEAPON_AR ){
    printDebug1("#### checkBestBody1: _nWeapon == WEAPON_AR ??");
    exit;
  }
  
  _i = 0;
  if ( _nBody == BODY_HEAVY ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[41]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ){ _i++; }
    }
  }
  
  if ( _nBody == BODY_MEDIUM ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[42]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[47]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){ _i++; }
    }
  }
  
  if ( _nBody == BODY_LIGHT ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AT ){
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_LIGHT ) { _sBody = "Light"; }
  if ( _nBody == BODY_MEDIUM ){ _sBody = "Medium"; }
  if ( _nBody == BODY_HEAVY ) { _sBody = "Heavy"; }
  if ( _nWeapon == WEAPON_AP ){ _sWeapon = "AP"; }
  if ( _nWeapon == WEAPON_AT ){ _sWeapon = "AT"; }
  if ( _nWeapon == WEAPON_AR ){ _sWeapon = "AR"; }
  //printDebug1("checkBestBody1; num tmpl found='"& _i &"' Body='"& _sBody &"' Weapon='"& _sWeapon &"' structCapacity("& skGetFactoryCapacity(_struct) &")");
  return _i;
}
//---------------------------------------------------------------------------
function  int checkBestBody2(int _nBody, int _nWeapon, STRUCTURE _struct )
{
  local int _i;
  local string _sBody,_sWeapon;
  
  _i = 0;
  if ( _nBody == BODY_HEAVY ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[54]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[53]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[43]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[29]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[28]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[27]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[11]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[10]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[9]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[3]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[2]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[52]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[51]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[50]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[49]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[48]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[47]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[42]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[41]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[40]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[39]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[26]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[25]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[24]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[23]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[22]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[21]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[20]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[8]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[7]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[6]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[5]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[4]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[1]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[0]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_MEDIUM ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[59]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[58]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[46]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[45]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[34]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[33]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[18]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[17]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[16]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[15]) ){ _i++; }
     }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[57]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[56]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[55]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[44]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[32]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[31]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[30]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[14]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[13]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[12]) ){ _i++; }
    }
  }
  if ( _nBody == BODY_LIGHT ){
    if ( _nWeapon == WEAPON_AP ){
      if( skCanBuildTemplate(player,_struct, tmpl0[63]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[62]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[61]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[38]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[37]) ){ _i++; }
    }
    if ( _nWeapon == WEAPON_AR ){
      if( skCanBuildTemplate(player,_struct, tmpl0[60]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[36]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[35]) ){ _i++; }
      if( skCanBuildTemplate(player,_struct, tmpl0[19]) ){ _i++; }
     }
  }
  if ( _nBody == BODY_LIGHT ) { _sBody = "Light"; }
  if ( _nBody == BODY_MEDIUM ){ _sBody = "Medium"; }
  if ( _nBody == BODY_HEAVY ) { _sBody = "Heavy"; }
  if ( _nWeapon == WEAPON_AP ){ _sWeapon = "AP"; }
  if ( _nWeapon == WEAPON_AT ){ _sWeapon = "AT"; }
  if ( _nWeapon == WEAPON_AR ){ _sWeapon = "AR"; }
  
  //printDebug1("checkBestBody2 (OK); num tmpl found='"& _i &"' Body='"& _sBody &"' Weapon='"& _sWeapon &"' structCapacity("& skGetFactoryCapacity(_struct) &") ");
  return _i;
}
//---------------------------------------------------------------------------
function bool isScavenger( int _player )
{
  if ( bScavAreActive ){
    if ( _player == 7){
      return true;
    }
  }
  return false;
}
//---------------------------------------------------------------------------
//develop
function void vtolAttack(BASEOBJ oTarget)
{
  local int _i,_n,_nCheck,_nFound,_dist,_tot,_nLoop,_aa;
  local DROID _droid;
	local	STRUCTURE	_tempDef;
	local bool _bWallDefFound;
  
  //excetute this for the whole group anyway to be use all VTOLs are used
  //  in case no other targets are in range

  if ( vtolGr.members > 4 ){
    //check for any AA strucutre of interest in range of the target
    _nFound = 0;
    _i      = 0;
    _aa     = 0;
    _n      = numGenAA;
    _n--;
    while (_n >= 0 and _i < 3){
      //all structs, also those not visible to this AI
      initEnumStruct(false,vtolGenStruct[_n],oTarget.player,oTarget.player); 
    	_tempDef = enumStruct();
    	while(_tempDef != NULLOBJECT and _i < 3)
    	{
        _dist = distBetweenTwoPoints(_tempDef.x, _tempDef.y, oTarget.x, oTarget.y);
        if ( _dist < 10 * TILE ){
          oTargetVTOLAtt[_i] = _tempDef;
          _i++;
          _nFound++;
          _aa++;
         } 
     		_tempDef = enumStruct();
     	}//while
     	_n--;
    }//end while  _n < numGenAA
    
    //search for wall def
    _bWallDefFound =false;
    if ( _nFound < 3){
      _n = numWallWeaps;
      _n--;
      while (_n >= 0 and _i < 3){
        //all structs, also those not visible to this AI
        initEnumStruct(false,wallWeaps[_n],oTarget.player,oTarget.player); 
      	_tempDef = enumStruct();
      	while(_tempDef != NULLOBJECT and _i < 3)
      	{
          _dist = distBetweenTwoPoints(_tempDef.x, _tempDef.y, oTarget.x, oTarget.y);
          if ( _dist < 10 * TILE ){
            oTargetVTOLAtt[_i]   = _tempDef;
            _i++;
            _nFound++;
            _bWallDefFound = true;
          } 
       		_tempDef = enumStruct();
       	}//while
       	_n--;
      }//end while  _n < numGenAA
    }
    
    //search for standard def
    if ( _nFound < 3){
      _n = numDefStructs;
      _n--;
      while (_n >= 0 and _i < 3){
        initEnumStruct(false,defStructs[_n],oTarget.player,oTarget.player); //all structs, also those not visible to this AI
      	_tempDef = enumStruct();
      	while(_tempDef != NULLOBJECT and _i < 3)
      	{
          _dist = distBetweenTwoPoints(_tempDef.x, _tempDef.y, oTarget.x, oTarget.y);
          if ( _dist < 10 * TILE){
            oTargetVTOLAtt[_i]   = _tempDef;
            _i++;
            _nFound++;
          } 
       		_tempDef = enumStruct();
       	}//while
       	_n--;
      }//end while  _n < numGenAA
    }

    //Attack the targets, assign at least 3 droids to each target
    if ( _bWallDefFound ){
      _nLoop = 4;
    } else {
      _nLoop = 3;
    }
    
    _i=0;
  	_n=0;
  	_tot = 0;
  	_nCheck = 0;
    initIterateGroup(vtolGr);
  	_droid = iterateGroup(vtolGr);
  	while(_droid != NULLOBJECT)
  	{
      if ( _n == _nLoop ){ _i++; _n=0;}//change the target
  	  if ( _i == _nLoop ){ _i=0;}
      if ( _nCheck < 3 ){ //attack the target with the first 3 VTOLs
        if ( oTarget != NULLOBJECT ){
          orderDroidObj( _droid, DORDER_ATTACK, oTarget );
          _nCheck++;
        } 
      } else {
        //Attack structs around target
        if ( oTargetVTOLAtt[_i] != NULLOBJECT ){
          orderDroidObj( _droid, DORDER_ATTACK, oTargetVTOLAtt[_i] );
          _n++;
        } else {
          if ( oTarget != NULLOBJECT ){
            orderDroidObj( _droid, DORDER_ATTACK, oTarget );
            _n++;
            _nCheck++;
          }
        }
      }
      _droid = iterateGroup(vtolGr);
      _tot++;
    }
    printDebug1("vtolAttack: VTOLs ("& vtolGr.members &")>4 struct found ("& _nFound &") OBJ target attacked ("& _nCheck &")/("& _tot &") _aa("& _aa &")");
    //dbg("vtolAttack: VTOLs ("& vtolGr.members &") struct found ("& _nFound &") attacked ("& _nCheck &")("& _tot &")",player);
  } else {
    //dbg("vtolAttack: not enough VTOLs ("& vtolGr.members &") attacking main target only!",player);
    if ( friendlyPlayer(oTarget.player) ){ printDebug1("#### vtolAttack: oTarget.player was friendly player pl#("& oTarget.player &")");   }
    orderGroupObj( vtolGr, DORDER_ATTACK, oTarget );
    printDebug1("vtolAttack: VTOLs ("& vtolGr.members &")<=4 start group attack to oTarget  pl("& oTarget.player &") ");
  }
  
  return;
}
//---------------------------------------------------------------------------
function STRUCTURE getEnemyDefStruct(GROUP _group,int _range)
{
  local int _n,_dist,_player,_healt,_bestHealt;
  local STRUCTURE _target,_tempDef;
  
  _target = NULLOBJECT;
  
  //search for standard def
  _n = numDefStructs;
  _n--;
  _bestHealt = 100;
  _player = 0;
  while ( _player < MAX_PLAYERS ){ 
    if ( isPlayerStillLive(_player) and !friendlyPlayer(_player) ){

      while (_n >= 0){
        initEnumStruct(false,defStructs[_n],_player,_player); //all structs, also those not visible to this AI
      	_tempDef = enumStruct();
      	while(_tempDef != NULLOBJECT)
      	{
          _dist = distBetweenTwoPoints(_tempDef.x, _tempDef.y, _group.x, _group.y);
          if ( _dist <= _range and _tempDef.health < _bestHealt and wallWeaps[_n] != wall ){
            _target    = _tempDef;
            _bestHealt = _tempDef.health;
          } 
       		_tempDef = enumStruct();
       	}//while
       	_n--;
      }//end while
    
    }
    _player++;
  } //end loop players

  if ( _target != NULLOBJECT ){
    return _target;
  }
  
  //search for wall def
  _n = numWallWeaps;
  _n--;
  _bestHealt = 100;
  _player = 0;
  while ( _player < MAX_PLAYERS ){ 
    if ( isPlayerStillLive(_player) and !friendlyPlayer(_player) ){

      while (_n >= 0){
        initEnumStruct(false,wallWeaps[_n],_player,_player); //all structs, also those not visible to this AI
      	_tempDef = enumStruct();
      	while(_tempDef != NULLOBJECT)
      	{
          _dist = distBetweenTwoPoints(_tempDef.x, _tempDef.y, _group.x, _group.y);
          if ( _dist <= _range and _tempDef.health < _bestHealt and wallWeaps[_n] != wall ){
            _target    = _tempDef;
            _bestHealt = _tempDef.health;
          } 
       		_tempDef = enumStruct();
       	}//while
       	_n--;
      }//end while
    
    }
    _player++;
  } //end loop players 
  
  return _target; 

}
//---------------------------------------------------------------------------
function int numDroidsBuilding(GROUP _group, int _x, int _y)
{
  local int _numTrucks;
  local DROID _tempTruck;
  
  _numTrucks = 0;
  
  if (_group.members == 0){ return 0; }

	initIterateGroup(_group);
	_tempTruck = iterateGroup(_group);
	while(_tempTruck != NULLOBJECT)
	{
    if( _tempTruck.orderx == _x and _tempTruck.ordery == _y )
		{
      _numTrucks++;
		}
		_tempTruck = iterateGroup(_group);
	}
  return _numTrucks;
}
//-----------------------------------------------------------------------------
function DROID getNearestIdleDroid(int _x, int _y) // MOLIMOLI
{
	local DROID _aDroid_1,_aDroid_2,_aDroid_3;
	local int 	_nDist_1,_nDist_2,_nDist_3;
  
  _aDroid_1 = closestIdleDroid(buildGrp,_x,_y);
  _aDroid_2 = closestIdleDroid(buildDefGrp,_x,_y);
  _aDroid_3 = closestIdleDroid(cybConstGrp,_x,_y);

  _nDist_1 = 999999;  
  _nDist_2 = 999999;  
  _nDist_3 = 999999;  
  
  if ( _aDroid_1 != NULLOBJECT ) { 
    _nDist_1 = distBetweenTwoPoints(_x, _y, _aDroid_1.x, _aDroid_1.y); 
  }
  if ( _aDroid_2 != NULLOBJECT ) { 
    _nDist_2 = distBetweenTwoPoints(_x, _y, _aDroid_2.x, _aDroid_2.y); 
  }
  if ( _aDroid_3 != NULLOBJECT ) { 
    _nDist_3 = distBetweenTwoPoints(_x, _y, _aDroid_3.x, _aDroid_3.y); 
  }

  if ( _nDist_1 <= _nDist_2 and _nDist_1 <= _nDist_3) { return _aDroid_1; } 
  if ( _nDist_2 <= _nDist_1 and _nDist_2 <= _nDist_3) { return _aDroid_2; } 
  if ( _nDist_3 <= _nDist_1 and _nDist_3 <= _nDist_2) { return _aDroid_3; } 

  
  return NULLOBJECT;
}

//-----------------------------------------------------------------------------
function bool IsTeamLeader()
{
  local int _player;
  
  _player=0;
  
  //necessary when autogame is on
  if ( isHumanPlayer(player) ){
    return true;
  }

  while (_player < MAX_PLAYERS){
    
    if ( isPlayerStillLive(_player) ){
      if ( allianceExistsBetween(_player,player)  )
      {
        if ( isHumanPlayer(_player) ){ return false; }
        if ( _player < player ){ return false; }
      }
    }

    _player++;
  }
  
  return true;
  
}
//-----------------------------------------------------------------------------
function void SetDyDoPath()
{


  local int _cc;

  _cc=0;

  //____________________General 4____________________________
  if ( AIPersonality == AI_CYBORG){    
    
    printDebug1("SetDyDoPath(): Setting research paths to Cyborg AI");
    
    _cc=0;
    //Cheap Researches
    while ( _cc < numCheapResGen4[0] ){
      researchCheap[0][_cc] = general4Cheap[0][_cc];
      _cc++;
    }
    
    _cc=0;
    //Standard Researches
    while ( _cc < numResGen4[0] ){
      research[0][_cc] = general4[0][_cc];
      _cc++;
    }
    
    _cc=0;
    //Standard Researches
    while ( _cc < numResGen4[1] ){
      research[1][_cc] = general4[1][_cc];
      _cc++;
    }
    numRes[0] = numResGen4[0];  
    numRes[1] = numResGen4[1];  

    //VTOL researches
    _cc=0;
    while ( _cc < numResGen4[9] ){
      research[9][_cc] = general4[9][_cc];
      _cc++;
    }
    numRes[9] = numResGen4[9];  

  } else {      


    //_____________________ Set the Templates & researches for path1_________________   
    if ( nResTmplPath == RESTMPL_1 ){  //Flamers and Rockets  
      
      printDebug1("SetDyDoPath; Setting research paths to #1 Flamers and Rockets");
      // --- CHEAP RESEARCHES ----
      //do not research cannon stuffs, force to mortars
      researchCheap[0][17] = researchCheap[0][13]; 
      researchCheap[0][18] = researchCheap[0][13]; 
      
      // --- Standard RESEARCHES ----
      _cc=0;
      while ( _cc < numPath1[0] ){
        research[0][_cc] = resPath1[0][_cc];
        _cc++;
      }
      _cc=0;
      while ( _cc < numPath1[1] ){
        research[1][_cc] = resPath1[1][_cc];
        _cc++;
      }
      numRes[0] = numPath1[0];  
      numRes[1] = numPath1[1];
      
      // ---- VTOL Researches ----
      _cc=0;
      numRes[9] = numPath1[9];
      while ( _cc < numPath1[9] ){
        research[9][_cc] = resPath1[9][_cc];
        _cc++;
      }
  
      // --- TEMPLATES ----
      _cc=0;
      while ( _cc < numTmpl_01 ){
        tmpl0[_cc] = tmpl_p1[_cc];
        _cc++;
      }
      while ( _cc < numTmpls ){
        tmpl0[_cc] = tmpl_p1[0];
        _cc++;
      }
      
      
       
    }  
  
    if ( nResTmplPath == RESTMPL_2 ){ //MG and Cannons   
      
      printDebug1("SetDyDoPath; Setting research paths to #2 MG and Cannons ");
      // --- Standard RESEARCHES ----
      //do not research Inferno and Rockets stuffs, force to HMG
      researchCheap[0][7]  = researchCheap[0][16]; 
      researchCheap[0][14] = researchCheap[0][16]; 
  
      _cc=0;
      while ( _cc < numPath2[0] ){
        research[0][_cc] = resPath2[0][_cc];
        _cc++;
      }
      _cc=0;
      while ( _cc < numPath2[1] ){
        research[1][_cc] = resPath2[1][_cc];
        _cc++;
      }
      numRes[0] = numPath2[0];  
      numRes[1] = numPath2[1];
      
      // ---- VTOL Researches ----
      numRes[9] = numPath2[9];
      _cc=0;
      while ( _cc < numPath2[9] ){
        research[9][_cc] = resPath2[9][_cc];
        _cc++;
      }
      //adjust for this research path
    	research[9][9] = 	research[9][10];//force to heap bomb bay
     	research[9][16]= 	research[9][10];//force to heap bomb bay
  
      // --- TEMPLATES ----
      _cc=0;
      while ( _cc < numTmpl_02 ){
        tmpl0[_cc] = tmpl_p2[_cc];
        _cc++;
      }
      while ( _cc < numTmpls ){
        tmpl0[_cc] = tmpl_p2[0];
        _cc++;
      }
       
    } 
  } 

  printDebug1("SetDyDoPath; nResTmplPath ("& nResTmplPath &"); AIPersonality("& AIPersonality &")");
}


//-----------------------------------------------------------------------------
function int getNumTeamMates()
{
  local int _player, _nTeamMates;
  
  _nTeamMates = 0;
  _player = 0;
  
  while (_player < MAX_PLAYERS){
    if ( allianceExistsBetween(_player,player) and _player != player and isPlayerStillLive(_player) )
    {
      _nTeamMates++;
    }
    _player++;
  }
  return _nTeamMates;
}
//----------------------------------------------------
function DROID getNearestEnemyCmd(int _player)
{
  local DROID _droid,_cmd;
  local int _n, _bestDist;
  
  _n = 0;
  _bestDist = 9999999;
  _cmd = NULLOBJECT;
  
  InitEnumDroids(_player,_player);
  _droid = EnumDroid();
  while(_droid != NULLOBJECT and _n < MAX_WHILE_LOOPS)
  {
    if ( _droid.weapon == Commander1 or _droid.weapon == Commander2 or _droid.weapon == Commander3 or _droid.weapon == Commander4 )
    {
      if ( distBetweenTwoPoints(_droid.x ,_droid.y ,baseX ,baseY) < _bestDist ){
        _cmd      = _droid;
        _bestDist = distBetweenTwoPoints(_droid.x ,_droid.y ,baseX ,baseY);
      }
    }
    _droid = EnumDroid();
    _n++;
  }
  return _cmd;
}
//-----------------------------------------------------------------------------
function int canBigHelpAlly(int _sender)
{
  local int _tank, _cyb, _dist, _nMaxUnitsToSend;

  
  _dist = -1;
  _tank = tankDefGroup.members - minDefDroids[nAI_Pers][MINDEF_TANKS];
  _cyb  = cyborgDefGroup.members - minDefDroids[nAI_Pers][MINDEF_CYBORGS];
  
  //check Distance
  if ( aPl[_sender][X_COORD] >= 0 and aPl[_sender][Y_COORD] >= 0 ){
    _dist = distBetweenTwoPoints(baseX,baseY,aPl[_sender][X_COORD],aPl[_sender][Y_COORD]);
    
    //default these units will probably never reach the _sender base...
    _nMaxUnitsToSend = 5;
    
    //these units will probably never reach the _sender base
    if ( _dist < nDefendRange*2 ) {
  	  _nMaxUnitsToSend = MIN_HELPING_UNITS;
    } 
    //really near to the _sender base
    if ( _dist < nDefendRange ) {
  	  _nMaxUnitsToSend = _tank+_cyb;
    }
  }
  
  if ( _tank+_cyb < _nMaxUnitsToSend ){ _nMaxUnitsToSend = _tank+_cyb; }
  
  
  if ( _dist == -1 ){ 
    printDebug1("#### canHelpAlly; _dist is == to -1 ??");
    return -1; 
  }
  
  
  if ( alertLevel == RED_ALERT ){
  	printDebug1("canHelpAlly; red alert; dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > 5 ?, alert ("& alertIsOn &") alertLevel ("& alertLevel &") _sender("& _sender &") ");
    return -1;
  }
  if ( _tank +_cyb < 5 ){
  	printDebug1("canHelpAlly; not enoug units; dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > 5 ?, alert _sender("& _sender &") ");
    return -1;
  }
  
  printDebug1("canHelpAlly; __OK__ dist("& _dist/TILE &") tk ("& _tank &") + cyb ("& _cyb &") > 5 ?, alert ("& alertIsOn &") alertLevel ("& alertLevel &") _sender("& _sender &") ");
  return _nMaxUnitsToSend;
}
//-----------------------------------------------------------------------------
// return the player position on the map
// 8players = 1-2-3-4-5-6-7-8
function int getPlayerPos(int _player)
{
  
  local int _w,_h;
  
  _w = mapWidth*TILE;
  _h = mapHeight*TILE;
  
  //Pos1 top left Corner
  if ( aPl[_player][X_COORD] < _w/3 and aPl[_player][Y_COORD] < _h/3 )
  {
    return 0;
  } else {
    //top right corner
    if ( aPl[_player][X_COORD] > _w-_w/3 and aPl[_player][Y_COORD] < _h/3 )
    {
      return 2;
    } else {
      //bottom right corner
      if ( aPl[_player][X_COORD] > _w-_w/3 and aPl[_player][Y_COORD] > _h-_h/3 )
      {
        return 4;
      } else {
        //bottom left corner
        if ( aPl[_player][X_COORD] < _w/3 and aPl[_player][Y_COORD] > _h-_h/3 )
        {
          return 6;
        } else {
          //Top middle
          if ( (aPl[_player][X_COORD] < _w-(_w/3) and aPl[_player][X_COORD] > _w/3) and ( aPl[_player][Y_COORD] < _h/3 ) )
          {
            return 1;
          } else {
            //Right middle
            if ( (aPl[_player][X_COORD] > _w-_w/3 ) and ( aPl[_player][Y_COORD] < _h-(_h/3) and aPl[_player][Y_COORD] > _h/3 ) )
            {
              return 3;
            } else {
              //Bottom middle
              if ( (aPl[_player][X_COORD] < _w-(_w/3) and aPl[_player][X_COORD] > _w/3) and ( aPl[_player][Y_COORD] > _h-_h/3 ) )
              {
                return 5;
              } else {
                //left middle
                if ( (aPl[_player][X_COORD] < _w/3 ) and ( aPl[_player][Y_COORD] < _h-(_h/3) and aPl[_player][Y_COORD] > _h/3 ) )
                {
                  return 7;
                } else {
                  printDebug1("#### getPlayerPos: 1 - position not found for player: ("& _player &")");
                  return -1;
                }
              }
            }
          }
        }
      }
    }
  
  
  }

  printDebug1("#### getPlayerPos: 2 - position not found for player: ("& _player &")");
  return -1;
}
//--------------------------------------------------------------------
function void buildAAdef(DROID _droid)
{
	local	int		_numAAdefInRange, _rnd, _aa, _cc, _nBestAADef;
  
  eventCheckTime[27] = gameTime;

  if ( gameTime < 4*TIME_MINUTE ){ exit; }
  
  if( _droid == NULLOBJECT ){ exit; }
  if (!researchFinished(HurricaneAASite,player)){ exit; }

  if ( !bAttackedByVTOL ){
    if ( numAAinBase >= 3 ){ exit; }
    if ( gameTime - tLastAAbuilt < 1*TIME_MINUTE ){ exit; }
  }
  
  //dbg("buildAAdef: lMinBaseStr("& lMinBaseStructBuilt &") _aa("& numAAinBase &") baseRange("& nBaseRange/TILE &") attbyVTOL("& bAttackedByVTOL &") time ("& gameTime - tLastAAbuilt&")",player);

  if (bIsEnemyHumanOnly){
    if ( aStat[OC_VTOLS][nLastEnemyPlayer] == 0 and numAAinBase >= 3 ){
      exit;
    } 
    if ( aStat[OC_VTOLS][nLastEnemyPlayer]*3 < numAAinBase ){
      exit;
    } 
  }

  
  if ( AIPersonality != AI_TURTLE ){

    if ( researchFinished(HurricaneAASite,player) ) { _aa = MIN_AA_INBASERANGE; }
    if ( researchFinished(SunburstAAsite,player) )  { _aa = MIN_AA_INBASERANGE+4; }
    if ( researchFinished(WhirlwindAASite,player) ) { _aa = MIN_AA_INBASERANGE+4; }
    if ( numAAinBase >= _aa ) { exit; }

  }  else {

    if ( researchFinished(HurricaneAASite,player) ) { _aa = MIN_AA_INBASERANGE; }
    if ( researchFinished(SunburstAAsite,player) )  { _aa = MIN_AA_INBASERANGE+6; }
    if ( researchFinished(WhirlwindAASite,player) ) { _aa = MIN_AA_INBASERANGE+6; }
    if ( numAAinBase >= _aa ) { exit; }

  }
  
  //do not build too many hurricane...at beginning of in T2 games
  if ( nT_Game >= T2_GAME and gameTime < 20 * TIME_MINUTE)
  { _aa--;_aa--;_aa--; }

  if ( numAAinBase < 3 ){

    if ( baseX > mapWidth/2*TILE ){ buildX = baseX - nBaseRange/2;}
    if ( baseX < mapWidth/2*TILE ){ buildX = baseX + nBaseRange/2;}
    if ( baseY > mapHeight/2*TILE ){ buildY = baseY - nBaseRange/2;}
    if ( baseY < mapHeight/2*TILE ){ buildY = baseY + nBaseRange/2;}

  } else {

    //pick up the position
    nAAPos++;
    //updates buildX and buildY
    nAAPos = getPosToBuildDef(nAAPos);

  
  }//endelse
    

  //find best defense we can build.
  _cc = 0;
  count2 = -1;
  while( _cc < numGenAA)
  {
    if(isStructureAvailable(vtolGenStruct[_cc],player))
    { _nBestAADef = _cc; }
    _cc = _cc + 1;
  }
  if(_nBestAADef >= 0 ){
    boolResult = pickStructLocation(vtolGenStruct[_nBestAADef], ref buildX, ref buildY,player);
    if(boolResult and droidCanReach(_droid, buildX ,buildY) )	// build a vtol defense near the attacked struct...
    {
      printDebug1("buildAAdef; droid ("& _droid.id &")build AA def ["& _nBestAADef &"] at ("& buildX/TILE &"-"& buildY/TILE &") numAAinBase("& numAAinBase &") nAAPos("& nAAPos &")");
      orderDroidStatsLoc(_droid, DORDER_BUILD,vtolGenStruct[_nBestAADef],buildX,buildY);
      tLastAAbuilt = gameTime;
    }
  }
  return;
  
}
//----------------------------------------------------------------
//structureBuiltInRange
function void buildArtillery(DROID _droid)
{
	local	int		_nBestDef, _numWeapInRange, _numWeapInBase, _rnd;
  local STRUCTURESTAT sensStruct;
  
  eventCheckTime[26] = gameTime;
  if( _droid == NULLOBJECT ){ exit; }

  //find best defense we can build.
  count     = 0;
  _nBestDef = -1;
  while( count < numIncendrys)
  {
    if(isStructureAvailable(incendrys[count],player))
    { _nBestDef = count; }
    count++;
  }
  if ( _nBestDef < 0 ){ exit; }//no artillery

  
  
  count = 0;
  while( count < numIncendrys)
  {
    _numWeapInBase = _numWeapInBase + numStructinRange(incendrys[count],player, baseX, baseY, nBaseRange + TILE*3);
    count++;
  }
  if ( _numWeapInBase >= 5 ) { exit; }

  //dbg("buildArtillery; 0 CBTime("& gameTime - tCBSense &") senstr av("& isStructureAvailable(sensorTower,player) &")  artInBase("& _numWeapInBase &") ",player);
  //buildSensorTower
  if ( gameTime - tCBSense > 1*TIME_MINUTE ){
    if ( isStructureAvailable(sensorTower,player) )    { sensStruct = sensorTower; }
    if ( isStructureAvailable(sensorHardTower,player)) { sensStruct = sensorHardTower; }
     
    if ( isStructureAvailable(sensStruct,player) and _numWeapInBase > 0 and numStructinRange(sensStruct,player, baseX, baseY, nBaseRange + TILE*3) == 0 )
    {
      //default
      buildX = baseX;
      buildY = baseY;
      
      if ( bEnemyIsNear ){
        
        //pick up best position
        if ( baseX > aPl[nNearestEnemy][X_COORD] ){
          buildX = baseX - 5*TILE - random(4)*TILE;     
        } 
        if ( baseX < aPl[nNearestEnemy][X_COORD] ){
          buildX = baseX + 5*TILE + random(4)*TILE;
        } 
        if ( baseY > aPl[nNearestEnemy][Y_COORD] ){
          buildY = baseY - 5*TILE - random(4)*TILE;     
        } 
        if ( baseY < aPl[nNearestEnemy][Y_COORD] ){
          buildY = baseY + 5*TILE + random(4)*TILE;
        }

      } else {

        if ( baseX > mapWidth/2*TILE ){ buildX = baseX - nBaseRange/3;}
        if ( baseX < mapWidth/2*TILE ){ buildX = baseX + nBaseRange/3;}
        if ( baseY > mapHeight/2*TILE ){ buildY = baseY - nBaseRange/3;}
        if ( baseY < mapHeight/2*TILE ){ buildY = baseY + nBaseRange/3;}

      }
      //dbg("buildArtillery; 0a CBTime("& gameTime - tCBSense &") senstr av("& isStructureAvailable(sensorTower,player) &")  artInBase("& _numWeapInBase &") ",player);
      
      if( pickStructLocation(sensStruct, ref buildX, ref buildY, player ) ){
  			if ( droidCanReach(_droid, buildX, buildY) ){
          printDebug1("buildArtillery; force building of sensorTower in ("& buildX/TILE &"-"& buildY/TILE &") ");
          orderDroidStatsLoc(_droid, DORDER_BUILD,sensStruct,buildX,buildY);
          tCBSense = gameTime;
          return;
        }
      }
    }
  }
  
  //CBSense
  if ( gameTime - tCBSense > 1*TIME_MINUTE ){
    if ( isStructureAvailable(CBSense,player) and _numWeapInBase > 1 and numStructinRange(CBSense,player, baseX, baseY, nBaseRange + TILE*3) == 0 )
    {
      buildX = baseX;
      buildY = baseY;

      if ( bEnemyIsNear ){
        
        //pick up best position
        if ( baseX > aPl[nNearestEnemy][X_COORD] ){
          buildX = baseX - 5*TILE - random(4)*TILE;     
        } 
        if ( baseX < aPl[nNearestEnemy][X_COORD] ){
          buildX = baseX + 5*TILE + random(4)*TILE;
        } 
        if ( baseY > aPl[nNearestEnemy][Y_COORD] ){
          buildY = baseY - 5*TILE - random(4)*TILE;     
        } 
        if ( baseY < aPl[nNearestEnemy][Y_COORD] ){
          buildY = baseY + 5*TILE + random(4)*TILE;
        }

      } else {

        if ( baseX > mapWidth/2*TILE ){ buildX = baseX - nBaseRange/3;}
        if ( baseX < mapWidth/2*TILE ){ buildX = baseX + nBaseRange/3;}
        if ( baseY > mapHeight/2*TILE ){ buildY = baseY - nBaseRange/3;}
        if ( baseY < mapHeight/2*TILE ){ buildY = baseY + nBaseRange/3;}
        if( pickStructLocation(CBSense, ref buildX, ref buildY, player ) ){
    			if ( droidCanReach(_droid, buildX, buildY) ){
            printDebug1("buildArtillery; force building of CBSense in ("& buildX/TILE &"-"& buildY/TILE &")");
            orderDroidStatsLoc(_droid, DORDER_BUILD,CBSense,buildX,buildY);
            tCBSense = gameTime;
            return;
          }
        }
      
      }
    }
  }

  //dbg("buildArtillery; 1 lMinStr("& lMinBaseStructBuilt &") bEnemyIsNear("& bEnemyIsNear &")  nArtilleryPos("& nArtilleryPos &") artInBase("& _numWeapInBase &") lStopBuildDef("& lStopBuildDef &") tLastArtilleryBuilt("& tLastArtilleryBuilt &")",player);
  //if ( gameTime - tLastArtilleryBuilt < 1 * TIME_MINUTE ){ exit; }  
  
  // build AA defenses.
  if ( _droid != NULLOBJECT ){

    //pick up the position - nNearestEnemy
    if ( bEnemyIsNear ){
      
      //default
      buildX = baseX;
      buildY = baseY;
      
      //pick up best position
      if ( baseX > aPl[nNearestEnemy][X_COORD] ){
        buildX = baseX - 5*TILE - random(4)*TILE;     
      } 
      if ( baseX < aPl[nNearestEnemy][X_COORD] ){
        buildX = baseX + 5*TILE + random(4)*TILE;
      } 
      if ( baseY > aPl[nNearestEnemy][Y_COORD] ){
        buildY = baseY - 5*TILE - random(4)*TILE;     
      } 
      if ( baseY < aPl[nNearestEnemy][Y_COORD] ){
        buildY = baseY + 5*TILE + random(4)*TILE;
      }
  
  //dbg("buildArtillery; 1a nNearestEnemy("& nNearestEnemy &") dist("& count/TILE &") myBase("& baseX/TILE &"-"& baseY/TILE &") EnemyBase("& aPl[nNearestEnemy][X_COORD]/TILE &"-"& aPl[nNearestEnemy][Y_COORD]/TILE &")  Build("& buildX/TILE &"-"& buildY/TILE &")",player);

    } else {
      
      nArtilleryPos++;
      
      //updates buildX and buildY
      nArtilleryPos = getPosToBuildDef(nArtilleryPos);
    
    }
    
    //dbg("buildArtillery; 2 build def ["& _nBestDef &"] ("& buildX/TILE &"-"& buildY/TILE &")",player);
    if ( buildX < TILE*4 ) { buildX = TILE*4; }
    if ( buildY < TILE*4 ) { buildY = TILE*4; }
    
    if(_nBestDef >= 0 ){
      boolResult = pickStructLocation(incendrys[_nBestDef], ref buildX, ref buildY,player);
      if(boolResult and droidCanReach(_droid, buildX ,buildY) )	
      {
        
        //dbg("buildArtillery; 3 build def ["& _nBestDef &"] ("& buildX/TILE &"-"& buildY/TILE &")",player);
        printDebug1("buildArtillery;  build def ["& _nBestDef &"] _numWeapInBase("& _numWeapInBase &")");
        orderDroidStatsLoc(_droid, DORDER_BUILD,incendrys[_nBestDef],buildX,buildY);
        tLastArtilleryBuilt = gameTime;
        if ( bEnemyIsNear ){ nEarlyMortars++; }

      }
    } //else { displayMsg("buildArtillery: No def struc found"); }
  } //else { displayMsg("buildArtillery: No idle droid found"); }

  return;
  
}
//--------------------------------------------------------------------
function void defFromLongRangeWeap(DROID _droid)
{	
  local int _nCBSense,_nMortar,_nBombard,_nPepperpot,_nRippleRocket;
  local bool _bProceed;
  
  _bProceed = true;
  
  if ( nKineticX < 0 or nKineticY < 0 ) { return; }
  if( _droid == NULLOBJECT ){ exit; }

  //check if CB tower has been build in range of myattacked object
  _nCBSense       = numStructinRange(CBSense, player, nKineticX, nKineticY, 12*TILE);
  _nMortar        = numStructinRange(defMortar, player, nKineticX, nKineticY, 6*TILE);
  _nBombard       = numStructinRange(defBombard, player, nKineticX, nKineticY, 6*TILE);
  _nPepperpot     = numStructinRange(defPepperpot, player, nKineticX, nKineticY, 6*TILE);
  _nRippleRocket  = numStructinRange(defRippleRockets, player, nKineticX, nKineticY, 6*TILE);
  
  buildX = nKineticX;
  buildY = nKineticY;

  if (bAttackedByMortars or bAttackedByLongRangeWeap){   
    
    //help build CB Sense First
    initEnumStruct(false,CBSense,player,player);
  	structure = enumStruct();
  	while(structure != NULLOBJECT)
  	{
      if ( !structureComplete(structure) ){          
        if ( distBetweenTwoPoints(nKineticX,nKineticY,structure.x,structure.y) <= 6*TILE ) 
        {
           orderDroidObj(_droid, DORDER_HELPBUILD,structure);
           return;
        }
      }
      structure = enumStruct();
    }
    

    //CB Sense
    if ( isStructureAvailable(CBSense,player) ){
      if ( _nCBSense == 0  ){ //and gameTime - tCBSense > 1*TIME_MINUTE  
        if( pickStructLocation(CBSense, ref buildX, ref buildY, player ) ){
					if ( droidCanReach(_droid, buildX, buildY) ){
            printDebug1("defFromLongRangeWeap; force building of CBSense in ("& buildX/TILE &"-"& buildY/TILE &")");
            orderDroidStatsLoc(_droid, DORDER_BUILD,CBSense,buildX,buildY);
            _bProceed= false;
            tCBSense = gameTime;
          }
        }
      }
    }
    
    //Defences
    if (_bProceed){ 
      
      if ( isStructureAvailable(defRippleRockets,player) ){
        if( _nRippleRocket < 1 ){
          if( pickStructLocation(defRippleRockets, ref buildX, ref buildY, player ) ){
  					if ( droidCanReach(_droid, buildX, buildY) ){
              printDebug1("defFromLongRangeWeap (2); building of defRippleRockets in ("& buildX/TILE &"-"& buildY/TILE &")");
              orderDroidStatsLoc(_droid, DORDER_BUILD,defRippleRockets,buildX,buildY);
            }
          }
        } else { //Ripple already in Zone add some pepperpot or bombard
          if ( isStructureAvailable(defPepperpot,player) ){
            if( _nPepperpot < 3 ){
              if( pickStructLocation(defPepperpot, ref buildX, ref buildY, player ) ){
      					if ( droidCanReach(_droid, buildX, buildY) ){
                  printDebug1("defFromLongRangeWeap;  building of defPepperpot in ("& buildX/TILE &"-"& buildY/TILE &")");
                  orderDroidStatsLoc(_droid, DORDER_BUILD,defPepperpot,buildX,buildY);
                }
              }
            }
          } else if ( isStructureAvailable(defBombard,player) ) {
            if( _nBombard < 3 ){
              if( pickStructLocation(defBombard, ref buildX, ref buildY, player ) ){
      					if ( droidCanReach(_droid, buildX, buildY) ){
                  printDebug1("defFromLongRangeWeap;  building of defBombard in ("& buildX/TILE &"-"& buildY/TILE &")");
                  orderDroidStatsLoc(_droid, DORDER_BUILD,defBombard,buildX,buildY);
                }
              }
            }        
          }        
        }      
      } else if ( isStructureAvailable(defPepperpot,player) ) {
        if( _nPepperpot < 3 ){
          if( pickStructLocation(defPepperpot, ref buildX, ref buildY, player ) ){
  					if ( droidCanReach(_droid, buildX, buildY) ){
              printDebug1("defFromLongRangeWeap;  building of defPepperpot in ("& buildX/TILE &"-"& buildY/TILE &")");
              orderDroidStatsLoc(_droid, DORDER_BUILD,defPepperpot,buildX,buildY);
            }
          }
        }        
      } else if ( isStructureAvailable(defBombard,player) ) {
        if( _nBombard < 3 ){
          if( pickStructLocation(defBombard, ref buildX, ref buildY, player ) ){
  					if ( droidCanReach(_droid, buildX, buildY) ){
              printDebug1("defFromLongRangeWeap;  building of defBombard in ("& buildX/TILE &"-"& buildY/TILE &")");
              orderDroidStatsLoc(_droid, DORDER_BUILD,defBombard,buildX,buildY);
            }
          }
        }        
      } else if ( isStructureAvailable(defMortar,player) ) {
        if( _nMortar < 3 ){
          if( pickStructLocation(defMortar, ref buildX, ref buildY, player ) ){
  					if ( droidCanReach(_droid, buildX, buildY) ){
              printDebug1("defFromLongRangeWeap; building of Mortar in ("& buildX/TILE &"-"& buildY/TILE &")");
              orderDroidStatsLoc(_droid, DORDER_BUILD,defMortar,buildX,buildY);
            }
          }
        }        
      }
    }
  
  } 

  return;

}
//=======================================================================
function void defendBase(DROID _droid)
{
  local STRUCTURESTAT _defStruct;
	local int _rnd,_i;
	local	STRUCTURE	_defense;
    
  if( _droid == NULLOBJECT ){ exit; }

  eventCheckTime[15] = gameTime;
  
  //dbg("defendBase: force("& gameTime - tLastbuildBaseDef &")>("& TIME_TOFORCE_BUILDDEF &")lStopBuildDef("& lStopBuildDef &")("& nProdSelect &") totdef("& nTotBaseDefences &") lForceUnitsProduciton("& lForceUnitsProduciton &")defSpots("& defSpotX &")("& defSpotY &")",player);    

  if(pickDefQueueDepth <= 0 and pickWallDefQueueDepth <= 0 ){ 
    exit; 
  }
  
	if (gameTime < 2*TIME_MINUTE ){//hack, check time to avoid building at very beginning
	 exit;
  }	
    
  buildX = -1;
  buildY = -1;

  _rnd = random(100);
  if ( AIPersonality == AI_TURTLE ) { _rnd = count+25;  }
  if ( pickFortQueueDepth > 0 and _rnd > 75 and lMinBaseStructBuilt){  
    _rnd       = random(pickFortQueueDepth);
    _defStruct  = pickFortQueue[_rnd];
  } else {
    _defStruct = getDefStruct(false);
  }

  // ----------- build! ----------------
  if(isStructureAvailable(_defStruct,player))
	{
		
    if ( buildX < 0 and buildY < 0){//getDefStruct() sets them in few cases
      if( defSpotX > 0 and defSpotY > 0 ){
  			
        //best option
        buildX = defSpotX;                              
  			buildY = defSpotY;
  		
      } else	{

        nDefendBasePos++;
        //updates buildX and buildY
        nDefendBasePos = getPosToBuildDef(nDefendBasePos);


      }
    }
    
    //check number of def already built in area
    if( numFriendlyWeapStructsInRange(player, buildX, buildY, TILE*6, false) < MAX_DEFSTR_SPOT)
    {
			boolResult = pickStructLocation(_defStruct, ref buildX, ref buildY,player);
			if(boolResult and gameTime - tLastbuildBaseDef > 80) 
			{
				if ( droidCanReach(_droid, buildX, buildY) ){
          //printDebug1("defendBase; building base defence on coord _rnd("& _rnd &") ("& buildX/TILE &"-"& buildY/TILE &") defSpotX-Y("& defSpotX/TILE &")("& defSpotY/TILE &") pos("& nDefendBasePos &")");
          orderDroidStatsLoc(_droid, DORDER_BUILD,_defStruct,buildX,buildY);
          tLastbuildBaseDef = gameTime;
        }
			}
		} 
    
	} else { 
    printDebug1("defendBase; #### Trying to build a def struct which is not available"); 
  }
	
  return;  	
}
//-----------------------------------------------------------------------------
// use numFriendlyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE, onlycompletedStruct);
function void buildGatewayDef(DROID _defTruck)
{
  local int _x,_y,_tmpl,_n,_loop,_nDef;
  local bool _bOK,_bOK2;
  local STRUCTURESTAT _defStruct;

  if (_defTruck == NULLOBJECT ){ return; }
  if(pickWallDefQueueDepth <= 0 and pickDefQueueDepth <= 0){ return; }

  _loop = 0;
  boolResult = true;
  while ( _loop < nRealGatewaysFound and boolResult)
  {
    _nDef = numFriendlyWeapStructsInRange(player, aGatewayPosX[_loop], aGatewayPosY[_loop], 2*TILE, false);
    if ( _nDef < numDefStrAtGateway and !threatInRange(player,  aGatewayPosX[_loop], aGatewayPosY[_loop], THREAT_RANGE_TILES*128, false))
    {
      _x = aGatewayPosX[_loop];
      _y = aGatewayPosY[_loop];
        
      _defStruct = getDefStruct(true);
        
      if(isStructureAvailable(_defStruct,player) and gameTime - tGtwDefBuilt > 80 ){
        if( _defStruct != demAnomallyFix){ //hack to avoid a warzone BUG!!!
          if( droidCanReach(_defTruck, _x ,_y) ){
            _bOK = skDefenseLocationB(ref _x, ref _y, wall, _defStruct, _defTruck, player);
            if ( !_bOK ){
              _bOK2 = skDefenseLocation(ref _x, ref _y, wall, _defStruct, _defTruck, player);
            }
            //printDebug1("buildGatewayDef();  ok("& _bOK &") ok2("& _bOK2 &") build WALL DEF, at("& _x/TILE &"-"& _y/TILE &")");
            tGtwDefBuilt = gameTime;
          }
        } else {
          printDebug1("#### buildGatewayDef();  TRYING to build demolish struct!! ");
        }
      } 
          
      boolResult = false;//exit the loop
    }
    _loop++;
  }  
  return;
}
//============================================================================
function void defendDerrick(DROID _droid) 
{
  local STRUCTURESTAT _defStruct;
  local int _n,_nBestArt;
  
  eventCheckTime[12] = gameTime;
  
  if (_droid == NULLOBJECT ){ return; }
  if ( pickDefQueueDepth <= 0 and pickWallDefQueueDepth <= 0 ) {exit;}
  
  //also checks there are already enough def around the derrick
  _derrick = closestDerrickToDefend();
  
  if(gameTime>300 and _derrick != NULLOBJECT){//check on time is to avoid this event starts before AIbrain
    //this is the difference against event harvestOperate
    
    if(_droid != NULLOBJECT)
    {
      
      //build Artillery too
      if ( random(10) < 4 ){
        _n     = 0;
        _nBestArt = 0;
        while( _n < numIncendrys)
        {
          if(isStructureAvailable(incendrys[_n],player))
          { _defStruct = incendrys[_n]; _nBestArt++; }
          _n++;
        }
        if ( _nBestArt == 0 ){ 
          _defStruct = getDefStruct(false);
        }
      } else {
        _defStruct = getDefStruct(false);
      }
     
      
  		if( isStructureAvailable(_defStruct,player) )
  		{
  			
        buildX = _derrick.x ;
  			buildY = _derrick.y ;
        if(!threatInRange(player,buildX, buildY, THREAT_RANGE_TILES*128, false)){
    			if(pickStructLocation(_defStruct, ref buildX, ref buildY,player)) {
  				 if (droidCanReach(_droid, buildX, buildY) ){
             orderDroidStatsLoc(_droid, DORDER_BUILD, _defStruct, buildX, buildY); 				
           }
    			}
        }	
  		}	  
    } 
  } 
}
//----------------------------------------------------------------
//
function void buildRippleRockets(DROID _droid)
{

	local	int		_nBestDef, _numWeapInRange, _numWeapInBase, _rnd;
  
  eventCheckTime[31] = gameTime;

  if (_droid == NULLOBJECT ){ return; }
  if(!isStructureAvailable(defRippleRockets,player)){ exit; }

  _numWeapInBase = numStructinRange(defRippleRockets,player, baseX, baseY, nDefendRange );

  //dbg("buildRippleRockets Weap: lMinBaseStructBuilt("& lMinBaseStructBuilt &") _numWeapInBase("& _numWeapInBase &") lStopBuildDef("& lStopBuildDef &") tLastRRBuilt("& tLastRRBuilt &")",player);

  if ( AIPersonality == AI_TURTLE ){
    if ( _numWeapInBase >= 3 and gameTime < 30*TIME_MINUTE)  { exit; }
    if ( _numWeapInBase >= 4 and gameTime < 60*TIME_MINUTE)  { exit; }
    if ( _numWeapInBase >= 6 and gameTime > 60*TIME_MINUTE)  { exit; }
  } else {
    if ( _numWeapInBase >= 2 and gameTime < 30*TIME_MINUTE)  { exit; }
    if ( _numWeapInBase >= 3 and gameTime < 60*TIME_MINUTE)  { exit; }
    if ( _numWeapInBase >= 4 and gameTime > 60*TIME_MINUTE)  { exit; }
  }      
  
  if ( gameTime - tLastRRBuilt < 5 * TIME_MINUTE ){ exit; }  

  // build AA defenses.
  if ( _droid != NULLOBJECT ){

    //pick up the position
    nRippleRocketsPos++;
    //updates buildX and buildY
    nRippleRocketsPos = getPosToBuildDef(nRippleRocketsPos);
    
    if(_nBestDef >= 0 ){
      boolResult = pickStructLocation(defRippleRockets, ref buildX, ref buildY, player);
      if(boolResult and droidCanReach(_droid, buildX ,buildY) )	
      {
        printDebug1("buildRippleRockets; build Ripple Rockets _numWeapInBase("& _numWeapInBase &")");
        orderDroidStatsLoc(_droid, DORDER_BUILD,defRippleRockets,buildX,buildY);
        tLastRRBuilt = gameTime;
      }
    } //else { displayMsg("buildRippleRockets: No def struc found"); }
  } //else { displayMsg("buildRippleRockets: No idle droid found"); }
  
  return;
}
//------------------------------------------------------------------
//Updates buildX and buildY to obtain the best position
function int getPosToBuildDef(int _pos){
  
  local int _tiles;
  
  _tiles  = nBaseRange/3;
  
  //dbg("getPosToBuildDef: MapPos("& aPl[player][PL_POSITION] &")  _pos("& _pos &") _tiles("& _tiles/TILE &") baseRng("& nBaseRange/TILE &") base("&  baseX/TILE &")("& baseY/TILE &") ",player);
  //printDebug1("getPosToBuildDef: MapPos("& aPl[player][PL_POSITION] &")  _pos("& _pos &") _tiles("& _tiles/TILE &") baseRng("& nBaseRange/TILE &") base("&  baseX/TILE &")("& baseY/TILE &") ");
  if ( aPl[player][PL_POSITION] == 0 ){
    if ( _pos > 2 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX+_tiles; buildY = baseY+_tiles; }
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY; }
    if ( _pos == 2 ){ buildX = baseX; buildY = baseY+_tiles; }
    //if ( _pos == 3 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 1 ){
    if ( _pos > 1 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY+_tiles; }
    //if ( _pos == 2 ){ buildX = baseX+_tiles; buildY = baseY; }
    //if ( _pos == 3 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 2 ){
    if ( _pos > 2 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    if ( _pos == 1 ){ buildX = baseX-_tiles; buildY = baseY; }
    if ( _pos == 2 ){ buildX = baseX; buildY = baseY+_tiles; }
    //if ( _pos == 3 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 3 ){
    if ( _pos > 1 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX+_tiles; buildY = baseY+_tiles; }
    if ( _pos == 1 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    //if ( _pos == 2 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    //if ( _pos == 1 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 4 ){
    if ( _pos > 2 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX-_tiles; buildY = baseY; }
    if ( _pos == 1 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
    if ( _pos == 2 ){ buildX = baseX; buildY = baseY-_tiles; }
    //if ( _pos == 3 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 5 ){
    if ( _pos > 1 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
    //if ( _pos == 1 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    //if ( _pos == 2 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 6 ){
    if ( _pos > 2 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX; buildY = baseY-_tiles; }
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
    if ( _pos == 2 ){ buildX = baseX+_tiles; buildY = baseY; }
    //if ( _pos == 3 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == 7 ){
    if ( _pos > 1 ){ _pos = 0; }
    if ( _pos == 0 ){ buildX = baseX+_tiles; buildY = baseY+_tiles; }
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
    //if ( _pos == 2 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    //if ( _pos == 2 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  if ( aPl[player][PL_POSITION] == -1 ){
    if ( _pos > 3 ){ _pos = 0; }
    //bottom-right
    if ( _pos == 0 ){ buildX = baseX+_tiles; buildY = baseY+_tiles; }
    //top-right
    if ( _pos == 1 ){ buildX = baseX+_tiles; buildY = baseY-_tiles; }
    //bottom-left
    if ( _pos == 2 ){ buildX = baseX-_tiles; buildY = baseY+_tiles; }
    //top-left
    if ( _pos == 3 ){ buildX = baseX-_tiles; buildY = baseY-_tiles; }
  }
  
  
  if ( buildX < 3*TILE ) { buildX = 3*TILE; }
  if ( buildY < 3*TILE ) { buildY = 3*TILE; }
  if ( buildX > mapWidth*TILE-(3*TILE) ) { buildX = mapWidth*TILE - (3*TILE); }
  if ( buildY > mapHeight*TILE-(3*TILE) ) { buildY = mapHeight*TILE - (3*TILE); }
  
  return _pos;
  
}
//------------------------------------------------------
function int playerIsNear(int _player)
{
  local int _val1,_val2,_dist;
  
  if ( aPl[player][PL_POSITION] == -1 ) {
    _dist = distBetweenTwoPoints( aPl[_player][X_COORD] , aPl[_player][Y_COORD] , baseX, baseY);
    if ( _dist < ((mapWidth+mapHeight)/2*TILE)/3  ) {
      return 1; //ok
    }  else {
      return 0;
    }
  }
  
  count = aPl[player][PL_POSITION];
  count--;
  _val2 = count;
  _val1 = aPl[player][PL_POSITION]+1;
  
  if ( _val1 > 7 ){ _val1 = 0; }
  if ( _val2 < 0 ){ _val2 = 7; }

  if ( nPlayersInGame > 4 ){

    if ( aPl[_player][PL_POSITION] == _val1 or aPl[_player][PL_POSITION] == _val2  )
    {
      return 1;
    }

  } else { //4 players game

    _val1 = aPl[_player][PL_POSITION];
    _val2 = aPl[player][PL_POSITION];
    if ( _val1 == 0 and _val2 == 2 or _val2 == 1 or _val2 == 6 or _val2 == 7 )
    if ( _val1 == 2 and _val2 == 0 or _val2 == 1 or _val2 == 3 or _val2 == 4 )
    if ( _val1 == 4 and _val2 == 2 or _val2 == 3 or _val2 == 5 or _val2 == 6 )
    if ( _val1 == 6 and _val2 == 4 or _val2 == 5 or _val2 == 7 or _val2 == 0 )

    if ( _val1 == 1 and _val2 == 7 or _val2 == 0 or _val2 == 2 or _val2 == 3 )
    if ( _val1 == 3 and _val2 == 1 or _val2 == 2 or _val2 == 4 or _val2 == 5 )
    if ( _val1 == 5 and _val2 == 3 or _val2 == 4 or _val2 == 6 or _val2 == 7 )
    if ( _val1 == 7 and _val2 == 5 or _val2 == 6 or _val2 == 0 or _val2 == 1 )

    { return 1; }

  }
  
  return -1;
}
//-----------------------------------------------------------------------------
// If a VTOL has a target even if you guve it a DORDER_RTR he still keeps attacking
function void resetVTOLAttack()
{
  
  local int _i;
  //dbg("resetVTOLAttack",player);

  _i = 0;
  while ( _i < 3){
    oTargetVTOLAtt[_i] = NULLOBJECT;
    _i++;
  }

  tVTOLAttackReset = gameTime;
  attTargetVTOL     = NULLOBJECT;
  dNearestEnemyCmd  = NULLOBJECT;
  targetPlayerVTOL  = -1;
}
//-----------------------------------------------------------------------------
//creturns the numbers of AA in range on the way from _grpX/Y to _destX/Y
function int getAA_OnTheWay(int _grpX, int _grpY, int _destX, int _destY, int _range)
{
  local int _steps,_x,_y,_aa, _tot;
  local bool _bStopX, _bStopY;
  
  _steps  = AA_THREAT_RANGE+2*TILE;
  _bStopX = false;
  _bStopY = false;
  _aa     = 0;
  _tot = 0;
  
  if ( _grpX <= 0 ){ _x = baseX; } else { _x = _grpX; }
  if ( _grpY <= 0 ){ _y = baseY; } else { _y = _grpY; }
  
  while ( !(_bStopX and _bStopY) )
  {
  
    if ( _grpX > _destX ){ 
      _x = _x - _steps; if ( _x <= _destX ){ _x = _destX; _bStopX = true;} 
    }
    if ( _grpY > _destY ){ 
      _y = _y - _steps; if ( _y <= _destY ){ _y = _destY; _bStopY = true;} 
    }
    if ( _grpX < _destX ){ 
      _x = _x + _steps; if ( _x >= _destX ){ _x = _destX; _bStopX = true;} 
    }
    if ( _grpY < _destY ){ 
      _y = _y + _steps; if ( _y >= _destY ){ _y = _destY; _bStopY = true; } 
    }
    _aa = _aa + numEnemyAAInRange( _x, _y, _range );
    _tot++;
  
  }//endwhile
  
  //dbg("getAA_OnTheWay: points checked ("& _tot &") AA:("& _aa &") from("& _grpX/TILE &")/("& _grpY/TILE &") to ("& _destX/TILE &")/("& _destY/TILE &")",player);
  return _aa;

}

/*
		"DACTION_VTOLATTACK",				// (36) a VTOL droid doing attack runs
		"DACTION_MOVETOREARM",			// (32)moving to a rearming pad - VTOLS
		"DACTION_WAITFORREARM",			// (33)waiting for rearm - VTOLS
		"DACTION_MOVETOREARMPOINT",		// (34)move to rearm point - VTOLS - this actually moves them onto the pad
		"DACTION_WAITDURINGREARM",		// (35)waiting during rearm process- VTOLS
		"DACTION_NONE",					// not doing anything
		"DACTION_DROIDREPAIR",			// repairing a droid

*/
/*
function int numIdleVTOLs(GROUP _grp)
function int numVTOLRepRearm(GROUP _grp)
function int numAttackVTOLs(GROUP _grp)
function bool isVTOLidle(DROID _droid)
function bool isVTOLRepRearm(DROID _droid)
function bool isVTOLRepairing(DROID _droid)
*/
//------------------------------------------------------
function int numIdleVTOLs(GROUP _grp)
{
 local DROID _droid;
 local int _n;
 
 _n = 0;

	initIterateGroup(_grp);
	_droid = iterateGroup(_grp);
	while(_droid != NULLOBJECT)
	{
    if ( _droid.action == DACTION_NONE ){ _n++; }
    _droid = iterateGroup(_grp);
  }  
 
  return _n;
}
//------------------------------------------------------
function int numVTOLRepRearm(GROUP _grp)
{
 local DROID _droid;
 local int _n;
 
 _n = 0;
 
	initIterateGroup(_grp);
	_droid = iterateGroup(_grp);
	while(_droid != NULLOBJECT)
	{
    if ( _droid.action == DACTION_DROIDREPAIR )    { _n++; }
    else {
      if ( _droid.action == DACTION_WAITDURINGREARM ){ _n++; }
      else {
        if ( _droid.action == DACTION_WAITFORREARM )   { _n++; }
      }
    }
    _droid = iterateGroup(_grp);
  }

  return _n;

}
//------------------------------------------------------
function int numAttackVTOLs(GROUP _grp)
{
 local DROID _droid;
 local int _n;
 
 _n = 0;

	initIterateGroup(_grp);
	_droid = iterateGroup(_grp);
	while(_droid != NULLOBJECT)
	{
    if ( _droid.action == DACTION_ATTACK ){ _n++; }
    _droid = iterateGroup(_grp);
  }  
 
  return _n;
}
//------------------------------------------------------
function bool isVTOLidle(DROID _droid)
{
  if ( _droid.action == DACTION_NONE ){ return true; }
  return false;
}
//------------------------------------------------------
function bool isVTOLRepRearm(DROID _droid)
{
  if ( _droid.action == DACTION_DROIDREPAIR )    { return true; }
  if ( _droid.action == DACTION_WAITDURINGREARM ){ return true; }
  if ( _droid.action == DACTION_WAITFORREARM )   { return true; }
  return false;
}
//------------------------------------------------------
function bool isVTOLRepairing(DROID _droid)
{
  if ( _droid.action == DACTION_DROIDREPAIR ){ return true; }
  return false;
}
                                           
